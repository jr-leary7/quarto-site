[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Background",
    "section": "",
    "text": "My undergrad degree is in statistics, which I did at the University of North Carolina at Chapel Hill (Go Heels!). After graduating in 2020, I spent some of the next two years earning a Master’s in biostatistics from the University of Florida. During my second year in that program, I applied to PhD programs and ended up deciding to continue at UF and start a PhD in the same department. I’m currently entering the second semester of my first year. My most relevant studies include courses on generalized linear models, statistical learning theory, convex optimization, probability theory, mathematical statistics, and statistical computing & software development."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Background",
    "section": "",
    "text": "My undergrad degree is in statistics, which I did at the University of North Carolina at Chapel Hill (Go Heels!). After graduating in 2020, I spent some of the next two years earning a Master’s in biostatistics from the University of Florida. During my second year in that program, I applied to PhD programs and ended up deciding to continue at UF and start a PhD in the same department. I’m currently entering the second semester of my first year. My most relevant studies include courses on generalized linear models, statistical learning theory, convex optimization, probability theory, mathematical statistics, and statistical computing & software development."
  },
  {
    "objectID": "about.html#work-experience",
    "href": "about.html#work-experience",
    "title": "Background",
    "section": "Work Experience",
    "text": "Work Experience\nIn the summer after my junior year at UNC, I joined Dr. Jen Jen Yeh’s lab at Lineberger Comprehensive Cancer Center. There I learned how to process and analyze genomic and transcriptomic data, and in Fall 2019 started focusing on developing methods for scRNA-seq analysis. My primary contribution there was the development of reproducible bioinformatics pipelines for bulk & single cell RNA-seq, ChIP-seq, and whole genome & exome sample processing. In addition, I developed a robust, evidence-based downstream analysis workflow for the lab’s scRNA-seq samples.\nAfter leaving the Yeh Lab in July 2020, I moved to Jacksonville and started working full-time as a junior data analyst at Blue Cross Blue Shield of Florida. While there, I completed a year-long rotational program during which I applied regression and clustering methods to several complex business problems. A highlight was my usage of graph-based clustering and dimension reduction algorithms (concepts lifted directly from my experience with scRNA-seq data) to identify well-performing subsets of specialist doctors. After my rotations ended, I became a full analyst and spent the next year working in care analytics, where I tested and deployed machine learning algorithms used to identify people to be targeted for various preventive healthcare programs. During this time, I also completed a manuscript started while I was at the Yeh Lab detailing a method for improved clustering of single cell data containing rare cell types.\nWhile all this was going on, I also started doing research work (once again focused on scRNA-seq method development) in Dr. Rhonda Bacher’s group at UF. Our original focus was in profiling, testing, and improving existing methods for RNA velocity and trajectory inference through simulations and analysis of publicly available single cell datasets.\nAfter two years at Blue Cross, and graduating with my master’s in May of 2022, I decided to join Dr. Bacher as a PhD student in Fall 2022. My first semester was spent pursuing scRNA-seq research, with a focus on improving the interpretability of trajectory differential expression methods. I also provided downstream analysis of single cell data generated by Dr. Phillip Efron’s lab containing different types of peripheral blood mononuclear cells. In addition, I was the instructor for the online section of PHC 6790 (Biostatistical Computing with SAS), a master’s-level course developed by fellow Tar Heel Dr. John Kairalla."
  },
  {
    "objectID": "about.html#personal-interests",
    "href": "about.html#personal-interests",
    "title": "Background",
    "section": "Personal Interests",
    "text": "Personal Interests\nOutside of research, I enjoy reading (my favorite genres are nautical adventure, weird history, and narrative science), riding my bike, cooking for my friends, and rock climbing."
  },
  {
    "objectID": "about.html#r-packages",
    "href": "about.html#r-packages",
    "title": "Background",
    "section": "R Packages",
    "text": "R Packages\n\n{SCISSORS}\n\nAn extension of the {Seurat} framework that implements a semi-supervised scRNA-seq reclustering method built around the silhouette scores. Useful for identifying rare cell types & annotating cell subtypes.\n\n{scLANE}\n\nEver wished scRNA-seq trajectory differential expression models were more interpretable? This package implements piecewise linear GLMs, GEEs, & GLMMs in order to generate easier-to-understand models that perform just as well as GAM-based methods in classifying dynamic genes."
  },
  {
    "objectID": "about.html#publications",
    "href": "about.html#publications",
    "title": "Background",
    "section": "Publications",
    "text": "Publications\n\nJack R. Leary, Yi Xu, Ashley Morrison, Chong Jin, Emily C. Shen, Ye Su, Naim U. Rashid, Jen Jen Yeh, Xianlu Laura Peng. Sub-cluster identification through semi-supervised optimization of rare-cell silhouettes (SCISSORS) in single-cell sequencing. BioRxiv. 466448, (2021).\nMatthew E. Berginski, Madison R. Jenner, Chinmaya U. Joisa, Silvia G.Herrera Loeza, Brian T. Golitz, Matthew B. Lipner, Jack R. Leary, Naim U. Rashid, Gary L. Johnson, Jen Jen Yeh, Shawn M. Gomez. Kinome state is predictive of cell viability in pancreatic cancer tumor and stroma cell lines. BioRxiv. 451515, (2021)."
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html",
    "href": "derivations/Intercept_Interpretation.html",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "",
    "text": "Code\nlibrary(dplyr)    # data manipulation\nlibrary(ggplot2)  # plots"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#multiplication",
    "href": "derivations/Intercept_Interpretation.html#multiplication",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Multiplication",
    "text": "Multiplication\n\nTheory\nFirst define two matrices \\(\\mathbf{A}\\) and \\(\\mathbf{B}\\), each with 2 rows and 2 columns:\n\\[\n\\begin{aligned}\n\\mathbf{A} &=\n    \\begin{bmatrix}\n      a_{11} & a_{21} \\\\\n      a_{12} & a_{22} \\\\\n    \\end{bmatrix} \\\\\n\\mathbf{B} &=\n  \\begin{bmatrix}\n    b_{11} & b_{21} \\\\\n    b_{12} & b_{22} \\\\\n  \\end{bmatrix} \\\\\n\\end{aligned}\n\\]\nTheir product, another matrix \\(C\\), also has 2 rows and 2 columns, and its elements are defined like so, with \\(i\\) specifying the row and \\(j\\) the column of each element. What we’re doing is finding the dot product of the \\(i^{\\text{th}}\\) row of \\(\\mathbf{A}\\) and the \\(j^{\\text{th}}\\) column of \\(\\mathbf{B}\\), the expanded definition of which is below.\n\\[\n\\begin{aligned}\nc_{ij} &= \\mathbf{A}_{i*} \\cdot \\mathbf{B}_{*j} \\\\\nc_{ij} &= \\sum_{k=1}^n a_{ik}b_{kj} \\\\\nc_{ij} &= a_{i1}b_{1j} + \\dots + a_{n1}b_{nj} \\\\\n\\end{aligned}\n\\]\nAs such, we can define the product of \\(\\mathbf{A}\\) and \\(\\mathbf{B}\\) like so:\n\\[\n\\begin{aligned}\n\\mathbf{C} &=  \\mathbf{A} \\mathbf{B} \\\\\n\\mathbf{C} &=\n  \\begin{bmatrix}\n    \\mathbf{A}_{1*} \\cdot \\mathbf{B}_{*1} & \\mathbf{A}_{2*} \\cdot \\mathbf{B}_{*1} \\\\\n    \\mathbf{A}_{2*} \\cdot \\mathbf{B}_{*1} & \\mathbf{A}_{2*} \\cdot \\mathbf{B}_{*2} \\\\\n  \\end{bmatrix} \\\\\n\\mathbf{C} &=\n  \\begin{bmatrix}\n    a_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\\\\n    a_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22} \\\\\n  \\end{bmatrix} \\\\\n\\end{aligned}\n\\]\nImportant Note: To multiply two matrices \\(\\mathbf{A}\\) and \\(\\mathbf{B}\\) together, the number of rows of \\(\\mathbf{B}\\) must be equal to the number of columns in \\(\\mathbf{A}\\). To generalize:\n\\[\n\\mathbf{A}_{m \\times n} \\cdot \\mathbf{B}_{n \\times p} = \\mathbf{C}_{m \\times p}\n\\]\n\n\nExample\nLet’s define two matrices:\n\\[\n\\begin{aligned}\n\\mathbf{A} &=\n  \\begin{bmatrix}\n    3 & 2 \\\\\n    0 & 7 \\\\\n  \\end{bmatrix} \\\\\n\\mathbf{B} &=\n  \\begin{bmatrix}\n    1 & 4 \\\\\n    1 & 2 \\\\\n  \\end{bmatrix} \\\\\n\\end{aligned}\n\\]\nTheir product \\(\\mathbf{C}\\) is defined as:\n\\[\n\\begin{aligned}\n\\mathbf{C} &=\n  \\begin{bmatrix}\n    3 \\times 1 + 2 \\times 1 & 3 \\times 4 + 2 \\times 2 \\\\\n    0 \\times 1 + 7 \\times 1 & 0 \\times 4 + 7 \\times 2 \\\\\n  \\end{bmatrix} \\\\\n\\mathbf{C} &=\n  \\begin{bmatrix}\n    5 & 16 \\\\\n    7 & 14 \\\\\n  \\end{bmatrix} \\\\\n\\end{aligned}\n\\]\nWe can check this using R:\n\n\nCode\nA_mat &lt;- matrix(c(3, 2, 0, 7), \n                nrow = 2, \n                ncol = 2, \n                byrow = TRUE)\nB_mat &lt;- matrix(c(1, 4, 1, 2), \n                nrow = 2, \n                ncol = 2, \n                byrow = TRUE)\nC_mat &lt;- A_mat %*% B_mat\nC_mat\n\n\n     [,1] [,2]\n[1,]    5   16\n[2,]    7   14"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#transposition",
    "href": "derivations/Intercept_Interpretation.html#transposition",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Transposition",
    "text": "Transposition\n\nTheory\nVery simply, the transpose of a matrix can be thought of as simply flipping the rows & columns. The transpose of an \\(m \\times n\\) matrix is thus \\(n \\times m\\). A matrix that is its own transpose is symmetric. Notation-wise, some write the matrix transpose as \\(A^T\\), others as \\(A^\\mathsf{T}\\), and still others denote it by \\(A^\\intercal\\), but I personally prefer \\(A^\\prime\\). The matrix transpose is more formally defined as:\n\\[\n\\begin{aligned}\n  & \\mathbf{A}_{m \\times n} \\\\\n  & \\mathbf{B}_{n \\times n} = A^\\prime \\\\\n  & \\mathbf{B}_{i, j} = \\mathbf{A}_{j, i} \\\\\n\\end{aligned}\n\\]\n\n\nExample\nIf we define the following matrix \\(\\mathbf{A}_{2 \\times 3}\\), we would expect its transpose to be the \\(3 \\times 2\\) matrix \\(\\mathbf{A}^\\prime\\):\n\\[\n\\begin{aligned}\n\\mathbf{A} &=\n  \\begin{bmatrix}\n    0 & -2 & 2 \\\\\n    3 & -10 & 0 \\\\\n  \\end{bmatrix} \\\\\n\\mathbf{A}^\\prime &=\n  \\begin{bmatrix}\n    0 & 3 \\\\\n    -2 & -10 \\\\\n    2 & 0 \\\\\n  \\end{bmatrix} \\\\\n\\end{aligned}\n\\]\nWe can confirm this in R using the t() function:\n\n\nCode\nA &lt;- matrix(c(0, -2, 2, 3, -10, 0), \n            nrow = 2, \n            ncol = 3, \n            byrow = TRUE)\nt(A)\n\n\n     [,1] [,2]\n[1,]    0    3\n[2,]   -2  -10\n[3,]    2    0"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#inversion",
    "href": "derivations/Intercept_Interpretation.html#inversion",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Inversion",
    "text": "Inversion\n\nTheory\nThe last matrix operation we’ll go over is inversion - this one is very important & is applied all throughout statistics & computing in general. The inverse of a matrix is simply another matrix that, when multiple by the first matrix, returns the identity matrix (a \\(n \\times n\\) matrix with 1s on the diagonal and 0s everywhere else). Matrices must be square to be invertible, but not even all square matrices are invertible; the ones that aren’t are called singular. We’ll gloss over that fact though, & simply assume / fervently hope that the matrices we encounter will have an easily-computable (approximate) inverse. See this article for more information on inverse computation. We define the inverse of \\(\\mathbf{A}_{n \\times n}\\) as:\n\\[\n\\mathbf{A} \\mathbf{A}^{-1} = \\mathbf{I}_n\n\\]\n\n\nExample\nIn R, the solve() function is used most frequently to compute the matrix inverse; since the result is an approximation, we round the results to show that the result is the identity matrix:\n\n\nCode\nA &lt;- matrix(rnorm(9), nrow = 3, ncol = 3)\nA_inv &lt;- solve(A)\nround(A %*% A_inv)\n\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\nThere are many other ways to compute a matrix inverse, as well as several different types of pseudoinverses. We can compute the Moore-Penrose pseudoinverse using the {MASS} package:\n\n\nCode\nA_mp_inv &lt;- MASS::ginv(A)\nround(A %*% A_mp_inv)\n\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#the-identity-matrix",
    "href": "derivations/Intercept_Interpretation.html#the-identity-matrix",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "The Identity Matrix",
    "text": "The Identity Matrix\n\nTheory\nAs mentioned previously, the identity matrix \\(\\mathbf{I}_{n}\\) is a square matrix composed entirely of zeroes except along the diagonal, which is composed of ones. This matrix carries some unique properties (which are listed below) that will be helpful to us later on.\n\\[\n\\begin{aligned}\n\\mathbf{I}_{n} &=\n  \\begin{bmatrix}\n    1 & 0 & \\cdots & 0 \\\\\n    0 & 1 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\ddots & 0 \\\\\n    0 & 0 & 0 & 1 \\\\\n  \\end{bmatrix} \\\\\n\\mathbf{I}_{n}^\\prime &= \\mathbf{I}_{n} \\\\\n\\mathbf{I}_{n}^{-1} &= \\mathbf{I}_{n} \\\\\n\\end{aligned}\n\\]\n\n\nExample\nWe can set up a \\(3 \\times 3\\) identity matrix \\(\\mathbf{I}_{3}\\) in R using the diag() function:\n\n\nCode\nident_mat &lt;- diag(nrow = 3)\nident_mat\n\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\nThe transpose is also equal to \\(\\mathbf{I}_{3}\\):\n\n\nCode\nt(ident_mat)\n\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\nAs is the inverse:\n\n\nCode\nsolve(ident_mat)\n\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#setup",
    "href": "derivations/Intercept_Interpretation.html#setup",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Setup",
    "text": "Setup\nFor now, we’ll take it for granted that the solution to a linear regression problem is defined as follows:\n\\[\n\\widehat{\\boldsymbol{\\beta}} = \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime \\mathbf{y}\n\\]"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#the-intercept-only-model",
    "href": "derivations/Intercept_Interpretation.html#the-intercept-only-model",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "The Intercept-only Model",
    "text": "The Intercept-only Model\nThe intercept-only model (also sometimes called the null model) is defined as linear regression when \\(\\mathbf{X}\\) is simply a column vector of ones:\n\\[\n\\mathbf{X} =\n  \\begin{bmatrix}\n    1 \\\\\n    \\vdots \\\\\n    1 \\\\\n  \\end{bmatrix}\n\\]\nWe know the intercept-only model produces the mean as the one predicted value, as the mean minimizes the sum of squared errors in the absence of any other covariates. We can check this using R - we’ll first generate a vector \\(\\mathbf{y}\\) consisting of 5 realizations of a random variable, such that \\(Y \\sim \\mathcal{N}(0, 3)\\).\n\n\nCode\ny &lt;- rnorm(5, mean = 0, sd = 3)\ny &lt;- matrix(y, ncol = 1)\ny\n\n\n          [,1]\n[1,] -5.415350\n[2,]  4.356184\n[3,] -2.261118\n[4,]  3.439089\n[5,] -2.163296\n\n\nThe mean of \\(\\mathbf{y}\\) is:\n\n\nCode\nmean(y)\n\n\n[1] -0.4088981\n\n\nWe can use R to fit an intercept-only model. We can see that the intercept coefficient \\(\\beta_0\\) is equal to the mean of \\(\\mathbf{y}\\).\n\n\nCode\nnull_mod &lt;- lm(y ~ 1)\ncoef(null_mod)\n\n\n(Intercept) \n -0.4088981 \n\n\nLet’s use linear algebra to figure out why this is true. Once again, we know that the linear regression closed-form solution is given by the following:\n\\[\n\\widehat{\\boldsymbol{\\beta}} = \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime \\mathbf{y}\n\\]\nLet’s first define \\(\\mathbf{X}\\) - just a column vector of 1s with \\(n = 5\\) rows:\n\n\nCode\nX &lt;- c(1, 1, 1, 1, 1)\nX &lt;- matrix(X, ncol = 1)\nX\n\n\n     [,1]\n[1,]    1\n[2,]    1\n[3,]    1\n[4,]    1\n[5,]    1\n\n\nThe value of \\(\\mathbf{X}^\\prime \\mathbf{X}\\) is given by the following - note that this is equal to our sample size \\(n = 5\\). We knew that this quantity would be a scalar (a \\(1 \\times 1\\) matrix) since \\(\\mathbf{X}^\\prime\\) has 1 row and 5 columns, and \\(\\mathbf{X}\\) has 5 rows and 1 column, thus by the rule we defined above their product has 1 row and 1 column.\n\n\nCode\nt(X) %*% X\n\n\n     [,1]\n[1,]    5\n\n\nThe inverse of which, \\(\\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1}\\), is of course \\(n^{-1}\\):\n\n\nCode\nsolve(t(X) %*% X)\n\n\n     [,1]\n[1,]  0.2\n\n\nWe multiply the above by \\(\\mathbf{X}^\\prime\\) again to obtain \\(\\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime\\), which gives us a constant vector of length \\(n\\) with all values being equal to \\(n^{-1}\\):\n\n\nCode\nsolve(t(X) %*% X) %*% t(X)\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]  0.2  0.2  0.2  0.2  0.2\n\n\nLastly, we multiply the above by \\(\\mathbf{y}\\). Remember how multiplying vectors works - in this case we are multiplying each element of the above vector \\(\\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime\\) with each element of \\(\\mathbf{y}\\) and adding them together. We’ll define \\(\\mathbf{Z} = \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime\\) for convenience of notation:\n\\[\n\\mathbf{Z} \\mathbf{y} = \\sum_{i=1}^n \\mathbf{Z}_i \\mathbf{y}_i\n\\]\nSince each element of \\(\\mathbf{Z}\\) is the same, \\(n^{-1}\\), by the transitive property the above quantity is equivalent to:\n\\[\n\\begin{aligned}\n  \\mathbf{Z} \\mathbf{y} &= \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime \\mathbf{y} \\\\\n  \\mathbf{Z} \\mathbf{y} &= \\sum_{i=1}^n \\mathbf{Z}_i \\mathbf{y}_i \\\\\n  \\mathbf{Z} \\mathbf{y} &= n^{-1} \\sum_{i=1}^n \\mathbf{y}_i \\\\\n\\end{aligned}\n\\]\nThis is simply the sum of all the elements of \\(\\mathbf{y}\\) divided by \\(n\\) - the mean! We can verify this with R by using linear algebra to compute the OLS solution:\n\n\nCode\nsolve(t(X) %*% X) %*% t(X) %*% y\n\n\n           [,1]\n[1,] -0.4088981\n\n\nThis is equal to simply taking the mean of \\(\\mathbf{y}\\):\n\n\nCode\nmean(y)\n\n\n[1] -0.4088981"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#models-with-categorical-predictors",
    "href": "derivations/Intercept_Interpretation.html#models-with-categorical-predictors",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Models with Categorical Predictors",
    "text": "Models with Categorical Predictors\nIn practice of course we usually build models with predictors of interest outside of the intercept. Categorical variables are composed of discrete values, each with a different meaning e.g., we could have a variable containing the type of treatment a patient has received. In order to fit models with categorical variables, it’s necessary to expand a categorical variable into multiple indicator variables - variables composed of 1s and 0s depending on whether a certain observation belongs to a certain category. This is a little confusing, so let’s show an example. We’ll start by creating a categorical variable .\n\n\nCode\nX &lt;- sample(c(\"A\", \"B\"), size = 10, replace = TRUE)\nX &lt;- matrix(X, ncol = 1)\nX\n\n\n      [,1]\n [1,] \"B\" \n [2,] \"B\" \n [3,] \"B\" \n [4,] \"A\" \n [5,] \"B\" \n [6,] \"B\" \n [7,] \"A\" \n [8,] \"B\" \n [9,] \"B\" \n[10,] \"A\" \n\n\nTo convert \\(\\mathbf{X}\\) into a numeric variable that we can use in a model, we use the model.matrix() function. To use this function though, we need to define the model we’re interested in using R’s formula syntax. The output we see shows an intercept column, which we understand, and another column composed of 1s and 0s called XB. This column is an indicator variable that tells us whether each observation belongs to category B or not - thus when XB is equal to 0, we know that the observation belongs to category A. This process of converting non-numeric categorical data to indicator variables has many names (one-hot encoding, dummifying, etc.), and there’s many ways of doing it. You can read more about the various ways of doing so here, but for now we’ll take it for granted that this is how it works under the hood in the lm() function that we use to fit linear models.\n\n\nCode\nX_2 &lt;- model.matrix(~X)\nX_2\n\n\n   (Intercept) XB\n1            1  1\n2            1  1\n3            1  1\n4            1  0\n5            1  1\n6            1  1\n7            1  0\n8            1  1\n9            1  1\n10           1  0\nattr(,\"assign\")\n[1] 0 1\nattr(,\"contrasts\")\nattr(,\"contrasts\")$X\n[1] \"contr.treatment\"\n\n\nFrom what we already know about matrix multiplication, we can see that the B group is going to have a different predicted average than the A group. We’ll also need to generate a new response variable \\(\\mathbf{y}\\), since we’ve increased our sample size to \\(n = 10\\).\n\n\nCode\ny &lt;- rnorm(10, mean = 0, sd = 3)\ny &lt;- matrix(y, ncol = 1)\ny\n\n\n            [,1]\n [1,] -5.8375020\n [2,] -1.8924219\n [3,]  2.9715616\n [4,] -1.5104106\n [5,] -1.1778186\n [6,]  1.3690104\n [7,] -0.5117578\n [8,]  1.8279983\n [9,]  1.9796838\n[10,] -4.7857809\n\n\nThe mean of \\(\\mathbf{y}\\) for each treatment group can be computed as follows. We’re going to use a little {dplyr} code to perform the summarization, as I find it a little more readable & replicable than base R. This will necessitate creating a data.frame to hold our \\(\\mathbf{y}\\) and \\(\\mathbf{X}\\) variables. Note that we’ve switched back to the categorical representation of \\(\\mathbf{X}\\), as it’s more interpretable than the indicator variable version for summaries such as this.\n\n\nCode\ndata.frame(X = X, y = y)\n\n\n\n\n\n\nX\ny\n\n\n\n\nB\n-5.8375020\n\n\nB\n-1.8924219\n\n\nB\n2.9715616\n\n\nA\n-1.5104106\n\n\nB\n-1.1778186\n\n\nB\n1.3690104\n\n\nA\n-0.5117578\n\n\nB\n1.8279983\n\n\nB\n1.9796838\n\n\nA\n-4.7857809\n\n\n\n\n\n\nHere’s the mean for each group:\n\n\nCode\ndata.frame(X = X, y = y) %&gt;% \n  with_groups(X, \n              summarise, \n              mu = mean(y))\n\n\n\n\n\n\nX\nmu\n\n\n\n\nA\n-2.2693164\n\n\nB\n-0.1084983\n\n\n\n\n\n\nLet’s use the OLS formula to solve for \\(\\boldsymbol{\\beta} = [\\beta_0, \\beta_1]\\). Note that we’re once again using the design matrix version of \\(\\mathbf{X}\\) with the intercept column and indicator variable for group. We see that the intercept \\(\\beta_0\\) is equal to the mean of the A group - but the coefficient for the B group \\(\\beta_1\\) isn’t! This is because \\(\\beta_1\\) doesn’t have the same interpretation as \\(\\beta_0\\). While \\(\\beta_0\\) is equal to the mean of the reference group (i.e., the first level of the categorical variable, in our case group A), \\(\\beta_1\\) represents the difference between the mean for group A and the mean for group B.\n\n\nCode\ncat_mod_beta &lt;- solve(t(X_2) %*% X_2) %*% t(X_2) %*% y\ncat_mod_beta\n\n\n                 [,1]\n(Intercept) -2.269316\nXB           2.160818\n\n\nThis becomes easier to understand when we sum the coefficients and get the average for group B, which is -0.1084983.\n\n\nCode\nsum(cat_mod_beta)\n\n\n[1] -0.1084983\n\n\nThis is validated by fitting a linear model with lm() and checking the output, which matches our manual solution:\n\n\nCode\ncat_mod &lt;- lm(y ~ X)\ncoef(cat_mod)\n\n\n(Intercept)          XB \n  -2.269316    2.160818 \n\n\nTo summarize: when categorical variables are used in an ordinary linear regression, the intercept represents the mean of the response variable when each of the categorical variables is at its reference level. When running regressions like this, it’s important to make sure that 1) you know what the reference levels are for each of your categorical variables and 2) that those reference levels make sense. Sometimes it doesn’t matter what order the categorical variables are in, but it often does - so check! A final note is that this interpretation holds when only categorical variables are used in your model. When continuous variables are included too, the interpretation changes. More on that in a bit.\nNote: Working with categorical variables (or factors, as R labels them) can be confusing. If you want to gain a deeper understanding of how factors work, check out the chapter on them in the R for Data Science book. For factor-related tools, try the {forcats} R package, which is part of the {tidyverse} ecosystem and makes dealing with factors a lot simpler."
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#models-with-continuous-predictors",
    "href": "derivations/Intercept_Interpretation.html#models-with-continuous-predictors",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Models with Continuous Predictors",
    "text": "Models with Continuous Predictors\nContinuous predictors differ from categorical ones in that they do not have a discrete set of possible values. The interpretation of the intercept thus differs. For any regression, the intercept interpretation is the value of the response when all predictors are equal to zero. What “all predictors equal to zero” means depends on the types of predictors you’re using; when predictors are categorical this implies that all predictors are at their reference levels (thanks to the indicator variable encoding that’s done in the background). With continuous variables, being equal to zero might have a reasonable interpretation or it might not, depending on what the variable is. In this case, think of the intercept like you would in middle school when learning \\(y = mx + b\\). The intercept, \\(b\\), is the value of \\(y\\) where \\(x = 0\\), like the plot below.\n\n\nCode\ndata.frame(x = rnorm(500, sd = 2)) %&gt;% \n  mutate(y = x + rnorm(500, sd = 0.5)) %&gt;% \n  ggplot(aes(x = x, y = y)) + \n  geom_point(alpha = 0.8) + \n  geom_vline(xintercept = 0, color = \"forestgreen\", size = 1) +\n  labs(x = \"X\", y = \"Y\") + \n  theme_classic(base_size = 14)\n\n\n\n\n\nIn some cases, this value might be meaningful - for example, if your covariate of interest was the expression of a certain gene, then zero expression has a biological meaning. In other situations it makes little sense, such as when the covariate of interest is the age of each patient in your dataset. It’s unlikely that age being equal to zero would really mean much, as newborns aren’t often part of clinical trials. There’s ways to remedy this difficulty in interpretation, but we’ll focus first on why the interpretation is the way it is.\nWe’ll start by generating some data. The predictor variable we’re interested in will be negative-binomially distributed, with \\(X \\sim \\text{NB}(10, 0.7)\\). Note that we’re using the parameterization of the negative binomial used in the rnbinom() function defaults, with the size and probability parameters. Our response variable \\(\\mathbf{y}\\) will be a function of \\(\\mathbf{X}\\) with added normally-distributed noise. Since we’ve increased our sample size to \\(n = 500\\), we’ll only look at the first few rows of each variable.\n\n\nCode\nX &lt;- rnbinom(500, size = 10, prob = 0.7)\ny &lt;- 2 * X + rnorm(500, mean = 0, sd = 2)\nX &lt;- matrix(X, ncol = 1)\ny &lt;- matrix(y, ncol = 1)\ndata.frame(X = X[, 1], y = y[, 1]) %&gt;% \n  slice_head(n = 5)\n\n\n\n\n\n\nX\ny\n\n\n\n\n6\n12.495948\n\n\n7\n15.185192\n\n\n4\n8.957864\n\n\n6\n10.231077\n\n\n3\n4.752311\n\n\n\n\n\n\nWe can plot the data using {ggplot2} to get an idea of what the relationship between the two variables is.\n\n\nCode\ndata.frame(X = X[, 1], y = y[, 1]) %&gt;% \n  ggplot(aes(x = X, y = y)) + \n  geom_point() + \n  labs(x = \"X\", y = \"y\") + \n  theme_classic(base_size = 14)\n\n\n\n\n\nUsing {dplyr}, we can find the mean of \\(\\mathbf{y}\\) when \\(\\mathbf{X} = 0\\).\n\n\nCode\ndata.frame(X = X[, 1], y = y) %&gt;% \n  filter(X == 0) %&gt;% \n  summarise(mu = mean(y))\n\n\n\n\n\n\nmu\n\n\n\n\n0.6471092\n\n\n\n\n\n\nLet’s fit a linear model manually and see what the coefficients are. We’ll first need to create the design matrix again using model.matrix(). This gives us a two column matrix, with the first column being the intercept (all 1s), and the second column being the negative binomial random variable \\(\\mathbf{X}\\) we just simulated. Unlike models with categorical predictors, the intercept is not simply equal to the expected value when \\(\\mathbf{X} = 0\\). Instead, the intercept is the expected value of the response variable conditional on the line of best fit that has been obtained i.e., conditional on the rest of the data in \\(\\mathbf{X}\\). See this StackOverflow post for another example.\n\n\nCode\nX_3 &lt;- model.matrix(~X)\ncont_mod_beta &lt;- solve(t(X_3) %*% X_3) %*% t(X_3) %*% y\ncont_mod_beta\n\n\n                  [,1]\n(Intercept) -0.1207059\nX            2.0299096\n\n\nWe can validate the above by fitting a linear model with lm() and checking the coefficients \\(\\boldsymbol{\\beta} = [\\beta_0, \\beta_1]\\), which are equal to our manually-computed coefficients.\n\n\nCode\ncont_mod &lt;- lm(y ~ X)\ncoef(cont_mod)\n\n\n(Intercept)           X \n -0.1207059   2.0299096 \n\n\n\nCentering Continuous Predictors\nOne way to make models like this more interpretable is to center continuous variables around their means. Doing so ensures that the centered version of continuous variable is equal to zero when the original version of the variable is at its mean. This can give a better interpretation to some models e.g., if the continuous variable of interest was patient age, then the intercept would be the expected value of the response for a patient of mean age. Since centering doesn’t change the units of the continuous variable, only the intercept \\(\\beta_0\\) will change i.e., the coefficient for our predictor of interest will stay the same. We can validate this by creating a centered version of \\(\\mathbf{X}\\) and re-running the regression. The scale() function centers (subtracts the mean) and standardizes (divides by the standard deviation) by default, so we need to set scale = FALSE in order to only center the data.\n\n\nCode\nX_cent &lt;- scale(X, scale = FALSE)\ncont_mod_centered &lt;- lm(y ~ X_cent)\ncoef(cont_mod_centered)\n\n\n(Intercept)      X_cent \n    8.74188     2.02991 \n\n\n\n\nStandardizing Continuous Predictors\nStandardizing (or scaling, as R calls it) can also occasionally be useful. Dividing by the standard deviation in addition to centering results in our continuous random variable having mean 0 and standard deviation 1. This does change the units of the variable though, which is important to remember. It does not, however, change the interpretation of the intercept - which remains unchanged from the model we fit above with only centering. The coefficient \\(\\beta_1\\) differs though, and now represents the change in \\(\\mathbf{y}\\) given a one standard deviation increase in \\(\\mathbf{X}\\). For more on standardization see this StatLect post and this blog post from Columbia’s Dr. Andrew Gelman.\n\n\nCode\nX_scaled &lt;- scale(X)\ncont_mod_scaled &lt;- lm(y ~ X_scaled)\ncoef(cont_mod_scaled)\n\n\n(Intercept)    X_scaled \n   8.741880    5.010312 \n\n\nLastly, with respect to standardization at least, it’s important to note that if we standardize the response variable \\(\\mathbf{y}\\) in addition to standardizing the predictor matrix \\(\\mathbf{X}\\), the intercept will disappear i.e., it will become zero. This is because after standardization, the means of both the predictor and response variables are equal to zero. Since the intercept is the mean of the response when the predictor is zero, the intercept is also zero. Note that because of how integers work in computer memory the value of the intercept shown below isn’t quite zero, but it is very close. For another example of this, see this Stackoverflow post.\n\n\nCode\ny_scaled &lt;- scale(y)\ncont_mod_resp_scaled &lt;- lm(y_scaled ~ X_scaled)\ncoef(cont_mod_resp_scaled)\n\n\n  (Intercept)      X_scaled \n-1.233443e-16  9.276516e-01"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#models-with-categorical-continuous-predictors",
    "href": "derivations/Intercept_Interpretation.html#models-with-categorical-continuous-predictors",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Models with Categorical & Continuous Predictors",
    "text": "Models with Categorical & Continuous Predictors\nFinally, let’s put it all together. In most real-life modeling scenarios you’ll have a mix of categorical and continuous predictors, and thus care must be taken when preparing the data. You generally will want your intercept to be meaningful - whatever that means for the data you’re analyzing. In this case, we’ll simulate data under the following scenario: our response variable \\(\\mathbf{y}\\) is the expression of some gene of interest in each of \\(n = 500\\) patients, and our predictor matrix \\(\\mathbf{X}\\) is composed of one categorical variable representing a treatment, a continuous variable representing patient age in years, and another categorical variable representing the facility at which each patient was treated.\n\n\nCode\nX_df &lt;- data.frame(age = rpois(500, lambda = 30), \n                   treatment = sample(c(\"A\", \"B\"), 500, replace = TRUE), \n                   facility = sample(c(\"Hosp1\", \"Hosp2\"), 500, replace = TRUE)) %&gt;% \n        mutate(y = 2 * age + rpois(500, lambda = 10), \n               y = case_when(treatment == \"A\" ~ 0.7 * y - rpois(1, lambda = 20), \n                             TRUE ~ y), \n               y = case_when(facility == \"Hosp2\" ~ y + rpois(1, lambda = 10), \n                             TRUE ~ y))\n\n\nThe above code to might be a bit confusing - we simulate age as a Poisson random variable with a mean of 30 years, and randomly assign one of two treatments and one of two facilities to each patient. Our response variable \\(\\mathbf{y}\\) is a function of all three predictors. We start by multiplying age by two and then adding Poisson-distributed random noise. We change the slope and subtract Poisson noise for treatment group A, and add Poisson-distributed noise for facility group Hosp2. Visualizing the data should help make sense of this process:\n\n\nCode\nggplot(X_df, aes(x = age, y = y, color = treatment)) + \n  facet_wrap(~facility) + \n  geom_point(alpha = 0.8) + \n  geom_smooth(mapping = aes(group = treatment), \n              color = \"black\",\n              method = \"lm\", \n              show.legend = FALSE) + \n  labs(x = \"Age (Years)\", \n       y = \"Gene Expression\", \n       color = \"Treatment\") + \n  theme_classic()\n\n\n\n\n\nWe can see that the lowest value of age in our dataset is 15, and thus it doesn’t really make sense to have our intercept correspond to age being equal to 0. Instead, we should center age, which will ensure that our intercept represents the expected value of \\(\\mathbf{y}\\) for a patient of mean age that was given treatment A at facility Hosp1. The reference groups for each categorical variable are known since R sorts categorical variables alphabetically by default (though this can be overridden through functions like relevel()).\n\n\nCode\nX_df &lt;- mutate(X_df, \n               age_centered = scale(age, scale = FALSE))\n\n\nNow that we have our centered variable, we can set up our design matrix. We use the formula syntax to specify which predictors we’re interested in.\n\n\nCode\nX_design_mat &lt;- model.matrix(~age_centered + treatment + facility, data = X_df)\nhead(X_design_mat)\n\n\n  (Intercept) age_centered treatmentB facilityHosp2\n1           1        -7.25          0             0\n2           1         1.75          1             0\n3           1        -7.25          1             1\n4           1        -0.25          0             1\n5           1         3.75          1             0\n6           1         0.75          1             1\n\n\nWe can now solve the ordinary linear regression problem by hand to obtain the coefficient vector \\(\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3]\\).\n\n\nCode\nfull_mod_beta &lt;- solve(t(X_design_mat) %*% X_design_mat) %*% t(X_design_mat) %*% X_df$y\nfull_mod_beta\n\n\n                   [,1]\n(Intercept)   33.434628\nage_centered   1.706063\ntreatmentB    37.137926\nfacilityHosp2 11.861502\n\n\nWe can verify the result once again using lm(). The interpretation for \\(\\beta_0\\) is the expected response for a patient of mean age who is taking treatment A at facility Hosp1.\n\n\nCode\nfull_mod &lt;- lm(y ~ age_centered + treatment + facility, X_df)\ncoef(full_mod)\n\n\n  (Intercept)  age_centered    treatmentB facilityHosp2 \n    33.434628      1.706063     37.137926     11.861502"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#setup-1",
    "href": "derivations/Intercept_Interpretation.html#setup-1",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Setup",
    "text": "Setup\nWe’ll next move to the more complicated case of the generalized linear model (GLM). We’ll start by defining the basic form of a GLM; the main difference from an ordinary linear model is that the model’s response variable is a transformation of the actual response variable. This transformation is taken via what we call a link function. There are some detail here I’m skipping over, but in practice the link function is usually the natural log, and can be others such as the logit (for logistic regression). The link function is usually denoted \\(g(\\cdot)\\), which gives us the following general form of a GLM with \\(p\\) covariates:\n\\[\ng(\\mathbb{E}[\\mathbf{y}]) = \\beta_0 + \\beta_1 \\mathbf{X}_1 + \\dots + \\beta_p\\mathbf{X}_p\n\\]\nLike ordinary linear models, GLMs are linear in their covariates (as shown above), which is what gives them their relatively easy interpretations. However, unlike with ordinary linear regression, there is no simple closed-form solution to the above equation. Instead, a solution is estimated using something like iteratively reweighted least squares or Newton’s method. As such, we won’t be able to provide exact calculations of the GLM solutions like we did above with the ordinary linear models, so we’ll stick to first providing the interpretation and then checking to make sure the fitted model matches that interpretation."
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#the-intercept-only-model-1",
    "href": "derivations/Intercept_Interpretation.html#the-intercept-only-model-1",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "The Intercept-only Model",
    "text": "The Intercept-only Model\nIn the intercept-only model, the GLM formula becomes:\n\\[\n\\begin{aligned}\ng(\\mathbb{E}[\\mathbf{y}]) &= \\beta_0 \\\\\n\\mathbb{E}[\\mathbf{y}] &= g^{-1}(\\beta_0) \\\\\n\\end{aligned}\n\\]\nIf we’re using \\(g(\\cdot) = \\text{log}(\\cdot)\\) (the log-link), then the inverse of \\(g(\\cdot)\\) is \\(g^{-1}(\\cdot) = \\text{exp}(\\cdot)\\). In this case, it’s easy to see that the intercept \\(\\beta_0\\) is actually the natural log of the mean of the response variable \\(\\mathbf{y}\\).\nWe can verify this in R. In this example we’ll use a Poisson GLM with a log link function, as it’s probably the simplest to understand. We’ll start by simulating a Poisson-distributed response \\(\\mathbf{y} \\sim \\text{Poisson}(5)\\) with \\(n = 10\\).\n\n\nCode\ny &lt;- rpois(10, lambda = 5)\ny &lt;- matrix(y, ncol = 1)\ny\n\n\n      [,1]\n [1,]    4\n [2,]   10\n [3,]    4\n [4,]    6\n [5,]    8\n [6,]    4\n [7,]    3\n [8,]    3\n [9,]    5\n[10,]    6\n\n\nThe mean of \\(\\mathbf{y}\\) is 5.3, and the log of that quantity is:\n\n\nCode\nlog(mean(y))\n\n\n[1] 1.667707\n\n\nWe can fit a Poisson GLM like so. We can clearly see that \\(\\beta_0 = \\text{log}(\\bar{\\mathbf{y}})\\).\n\n\nCode\nnull_mod_pois &lt;- glm(y ~ 1, family = poisson(link = \"log\"))\ncoef(null_mod_pois)\n\n\n(Intercept) \n   1.667707 \n\n\nThus, when we use the inverse of the link function (exponentiation) on the estimated value of \\(\\beta_0\\), we get the value of \\(\\mathbb{E}[\\mathbf{y}] = 5.3\\).\n\n\nCode\nexp(coef(null_mod_pois))\n\n\n(Intercept) \n        5.3"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#models-with-categorical-predictors-1",
    "href": "derivations/Intercept_Interpretation.html#models-with-categorical-predictors-1",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Models with Categorical Predictors",
    "text": "Models with Categorical Predictors\nThe extension to categorical predictors is much the same as we saw before with ordinary linear models, with the primary change being that we’re now working on the log scale. Let’s add a categorical predictor to our model. First we simulate a categorical \\(\\mathbf{X}\\):\n\n\nCode\nX &lt;- sample(c(\"A\", \"B\"), size = 10, replace = TRUE)\nX &lt;- matrix(X, ncol = 1)\nX\n\n\n      [,1]\n [1,] \"A\" \n [2,] \"B\" \n [3,] \"A\" \n [4,] \"A\" \n [5,] \"B\" \n [6,] \"A\" \n [7,] \"A\" \n [8,] \"B\" \n [9,] \"B\" \n[10,] \"B\" \n\n\nAgain using {dplyr}, we can find \\(\\bar{\\mathbf{y}}\\) and \\(\\text{log}(\\bar{\\mathbf{y}})\\) for each group in our categorical variable:\n\n\nCode\ndata.frame(y = y, \n           X = X[, 1]) %&gt;% \n  with_groups(X, \n              summarise, \n              mu = mean(y), \n              log_mu = log(mean(y)))\n\n\n\n\n\n\nX\nmu\nlog_mu\n\n\n\n\nA\n4.2\n1.435085\n\n\nB\n6.4\n1.856298\n\n\n\n\n\n\nWe fit a Poisson GLM using the glm() function, again using the natural log as our link function. We see that the intercept is equal to the log of the mean of our response variable for group A.\n\n\nCode\ncat_mod_pois &lt;- glm(y ~ X, family = poisson(link = \"log\"))\ncoef(cat_mod_pois)\n\n\n(Intercept)          XB \n  1.4350845   0.4212135 \n\n\nNext, if we sum the coefficients, we get the log of the response variable for group B:\n\n\nCode\nsum(coef(cat_mod_pois))\n\n\n[1] 1.856298\n\n\nIf we exponentiate the coefficients the intercept becomes simply the mean of \\(\\mathbf{y}\\) for group A.\n\n\nCode\nexp(coef(cat_mod_pois))\n\n\n(Intercept)          XB \n    4.20000     1.52381 \n\n\nLastly, if we exponentiate the sum of the coefficients (the order of these operations is important), we get the mean of \\(\\mathbf{y}\\) for group B:\n\n\nCode\nexp(sum(coef(cat_mod_pois)))\n\n\n[1] 6.4"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#models-with-continuous-predictors-1",
    "href": "derivations/Intercept_Interpretation.html#models-with-continuous-predictors-1",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Models with Continuous Predictors",
    "text": "Models with Continuous Predictors\nAs with ordinary linear models, in the presence of a continuous predictor the intercept becomes the expected value of the response variable conditional on the line of best fit that we generate. First we generate another \\(\\mathbf{y}\\) with a larger sample size and a slightly lower value of \\(\\lambda\\). Then we generate Gamma random noise, and define the predictor \\(\\mathbf{X} = 3.1y + \\epsilon\\).\n\n\nCode\ny &lt;- rpois(300, lambda = 3)\ny &lt;- matrix(y, ncol = 1)\nX &lt;- 3.1 * y + rgamma(300, shape = 20, rate = 4)\nX &lt;- matrix(X, ncol = 1)\n\n\nWe can plot \\(\\mathbf{X}\\) and \\(\\mathbf{y}\\) to get an idea of what their relationship is. Since \\(\\mathbf{X}\\) is a Gamma random variable, it doesn’t actually have any zero values; the minimum value we’ve generated is actually 3.8055922. As such, the intercept will be an extrapolation of the data that we do have.\n\n\nCode\ndata.frame(y = y, \n           X = X[, 1]) %&gt;% \n  ggplot(aes(x = X, y = y)) + \n  geom_point(alpha = 0.8) + \n  labs(x = \"X\", y = \"Y\") + \n  theme_classic(base_size = 14)\n\n\n\n\n\nWe fit another Poisson GLM and check the coefficients. The intercept in this case is interpreted as the log of the expected value of the response when our predictor variable is equal to zero. However - since \\(\\mathbf{X}\\) is essentially a Gamma random variable, it can actually never take a value of zero, as its support is \\((0, \\infty)\\). As such, the interpretation of \\(\\beta_0\\) is somewhat useless here, and thus it makes sense to center \\(\\mathbf{X}\\) as we did earlier with the ordinary linear model.\n\n\nCode\ncont_mod_pois &lt;- glm(y ~ X, family = poisson(link = \"log\"))\ncoef(cont_mod_pois)\n\n\n(Intercept)           X \n-0.37029176  0.09311951 \n\n\nAfter centering and refitting the Poisson GLM, the intercept takes on a new interpretation - the log of \\(\\mathbf{y}\\) when \\(\\mathbf{X}\\) is at its mean. Note that the coefficient for \\(\\mathbf{X}\\) does not change, as centering does not change the units of \\(\\mathbf{X}\\).\n\n\nCode\nX_cent &lt;- scale(X, scale = FALSE)\ncont_mod_pois_centered &lt;- glm(y ~ X_cent, family = poisson(link = \"log\"))\ncoef(cont_mod_pois_centered)\n\n\n(Intercept)      X_cent \n 0.95596361  0.09311951 \n\n\nLet’s plot both the raw data and the fitted values obtained from our model. The blue horizontal line shows \\(\\text{exp}(\\beta_0)\\) i.e., the expected value of \\(\\mathbf{y}\\) when \\(\\mathbf{X}\\) is at its mean value (again, conditional on the line of best fit that we obtained). The vertical yellow line shows where the mean of \\(\\mathbf{X}\\) is; since we centered \\(\\mathbf{X}\\) this is equal to zero. Lastly, the green line shows the predicted values from our model, and this line intersects nicely with the value of the intercept as we would expect.\n\n\nCode\nintercept_exp &lt;- exp(coef(cont_mod_pois_centered)[1])\ndata.frame(y = y, \n           y_pred = fitted(cont_mod_pois_centered), \n           X = X_cent[, 1]) %&gt;% \n  ggplot(aes(x = X, y = y)) + \n  geom_point(alpha = 0.8) + \n  geom_hline(yintercept = intercept_exp, color = \"dodgerblue\", size = 1) + \n  geom_vline(xintercept = 0, color = \"goldenrod\", size = 1) + \n  geom_line(aes(y = y_pred), color = \"forestgreen\", size = 1) + \n  labs(x = \"X (centered)\", y = \"Y\") + \n  theme_classic()"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#models-with-categorical-continuous-predictors-1",
    "href": "derivations/Intercept_Interpretation.html#models-with-categorical-continuous-predictors-1",
    "title": "Understanding Intercepts in Linear Regression Models",
    "section": "Models with Categorical & Continuous Predictors",
    "text": "Models with Categorical & Continuous Predictors\nLastly, we’ll again examine the most common real-life situation - models with both categorical and continuous predictors. Consider a dataset where the response is a Poisson-distributed random variable, say the number of copies of viral RNA in a sample taken from a patient. First, let’s say that our sample size is set to a generous \\(n = 1000\\). Next, imagine that we have two continuous predictors; the first being patient age in years, and the second being the number of months that the patient has been in treatment. We’ll simulate age as a Poisson random variable with a mean of 25 years, and months in treatment as a negative binomial random variable with a mean of 3 months and overdispersion parameter (denoted size in the rnbinom() function) of 4. Lastly, let’s define a categorical predictor with 3 possible treatment categories. We store all 3 predictors in a data.frame.\n\n\nCode\nX_age &lt;- rpois(1000, 25)\nX_months &lt;- rnbinom(1000, size = 4, mu = 3)\nX_treat &lt;- sample(c(\"Drug_A\", \"Drug_B\", \"Drug_C\"), \n                  size = 1000, \n                  replace = TRUE)\nmod_df &lt;- data.frame(age = X_age, \n                     months = X_months, \n                     treat = X_treat)\nslice_head(mod_df, n = 5)\n\n\n\n\n\n\nage\nmonths\ntreat\n\n\n\n\n17\n2\nDrug_B\n\n\n24\n0\nDrug_C\n\n\n24\n2\nDrug_A\n\n\n18\n1\nDrug_C\n\n\n36\n4\nDrug_C\n\n\n\n\n\n\nFinally, we’ll define \\(\\mathbf{y}\\) to be a function of all 3 predictor variables along with a large amount of Poisson-distributed random noise following the distribution \\(\\epsilon \\sim \\text{Poisson}(50)\\). We use the handy dplyr::case_when() function to create \\(\\mathbf{y}\\) as a piecewise function whose relationship to the predictor variable changes based on the treatment each patient was given. After generating \\(\\mathbf{y}\\), we round it to ensure that it is integer-valued, since we’re focused here on using Poisson GLMs.\n\n\nCode\nepsilon &lt;- rpois(1000, 50)\nmod_df &lt;- mod_df %&gt;% \n          mutate(y = case_when(treat == \"Drug_A\" ~ 2.25 * age - 1.2 * months, \n                               treat == \"Drug_B\" ~ 2 * age - 3 * months, \n                               treat == \"Drug_C\" ~ 1.75 * age - 5 * months), \n                 y = round(y + epsilon))\nslice_head(mod_df, n = 5)\n\n\n\n\n\n\nage\nmonths\ntreat\ny\n\n\n\n\n17\n2\nDrug_B\n79\n\n\n24\n0\nDrug_C\n86\n\n\n24\n2\nDrug_A\n104\n\n\n18\n1\nDrug_C\n84\n\n\n36\n4\nDrug_C\n86\n\n\n\n\n\n\nWe know that for our two continuous predictors, the intercept will indicate the predicted value of \\(\\mathbf{y}\\) for patients with values of zero for those two variables. Since we also have a categorical variable, the intercept will refer to the reference group of that variable - in this case patients who were assigned Drug_A. Lastly, since we’re using a Poisson GLM, we know that the intercept will be the natural log of that quantity. Our model will be of the following form:\n\\[\n\\text{log}(\\mathbb{E}[\\text{Viral RNA}]) = \\beta_0 + \\beta_{\\text{age}} X_{\\text{age}} + \\beta_{\\text{months}} X_{\\text{months}} + \\beta_{\\text{treat}} X_{\\text{treat}} + \\epsilon\n\\]\nLet’s visualize the data so that we can get some idea of what the relationships between our variables are, and what the intercept of the model we’re going to fit will tell us. First let’s look at the relationship between age and the response, splitting by treatment group. We add a purple vertical line showing where the overall mean of age is.\n\n\nCode\nggplot(mod_df, aes(x = age, y = y, color = treat)) + \n  geom_vline(aes(xintercept = mean(age)), color = \"purple\", size = 1) + \n  geom_point(alpha = 0.8) + \n  labs(x = \"Age\", y = \"Viral RNA\", color = \"Treatment\") + \n  theme_classic(base_size = 14)\n\n\n\n\n\nWe repeat the visualization for months.\n\n\nCode\nggplot(mod_df, aes(x = months, y = y, color = treat)) + \n  geom_vline(aes(xintercept = mean(months)), color = \"purple\", size = 1) + \n  geom_point(alpha = 0.8) + \n  labs(x = \"Months Treated\", y = \"Viral RNA\", color = \"Treatment\") + \n  theme_classic(base_size = 14)\n\n\n\n\n\nLastly, let’s simply compare the distribution of the response between the three treatment groups using a beeswarm plot, which is a variation on the classic violin plot that I’ve preferred recently. Check out the ggbeeswarm package docs for more. We also add a horizontal line showing \\(\\bar{\\mathbf{y}}\\) for each group.\n\n\nCode\nggplot(mod_df, aes(x = treat, y = y, color = treat)) + \n  ggbeeswarm::geom_quasirandom() + \n  stat_summary(fun = \"mean\",\n               geom = \"crossbar\", \n               width = 0.5,\n               size = 0.75, \n               color = \"black\") + \n  labs(x = \"Treatment\", y = \"Viral RNA\", color = \"Treatment\") + \n  theme_classic(base_size = 14)\n\n\n\n\n\nLet’s fit a model. As previously noted, we use the log link function. Since our treatment variable has three categories, we now have two coefficients for each of the non-reference group levels. The intercept \\(\\beta_0\\) gives us the log of the expected value of the response for a patient that is 0 years old, has spent 0 months in treatment, and is assigned to be treated with Drug_A. We can tell right away that this isn’t the most useful interpretation, as there are no patients in our study who are zero years old (and even if there were, it probably wouldn’t be that useful to know that quantity).\n\n\nCode\nfull_mod_pois &lt;- glm(y ~ age + months + treat, \n                     data = mod_df, \n                     family = poisson(link = \"log\"))\ncoef(full_mod_pois)\n\n\n(Intercept)         age      months treatDrug_B treatDrug_C \n 4.18370839  0.02170154 -0.03522072 -0.12013892 -0.25924502 \n\n\nSince we’re using the log-link, exponentiating the intercept gives us the expected value of \\(\\mathbf{y}\\) under the conditions we described just above.\n\n\nCode\nexp(coef(full_mod_pois))[1]\n\n\n(Intercept) \n   65.60871 \n\n\nClearly, the age variable is a prime target for centering. While it could be useful to center months (depending on the goals of the study), there are a total of 113 patients in the study who have spent zero months in treatment, so it’s at least somewhat anchored in reality. We center age, then refit the model. We see that the estimate of \\(\\beta_0\\) changes, while none of the coefficients for our predictors do (as expected).\n\n\nCode\nmod_df &lt;- mutate(mod_df, \n                 age_cent = scale(age, scale = FALSE))\nfull_mod_pois_centered &lt;- glm(y ~ age_cent + months + treat, \n                              data = mod_df, \n                              family = poisson(link = \"log\"))\ncoef(full_mod_pois_centered)\n\n\n(Intercept)    age_cent      months treatDrug_B treatDrug_C \n 4.72589977  0.02170154 -0.03522072 -0.12013892 -0.25924502 \n\n\nExponentiating \\(\\beta_0\\) now gives us the expected value of \\(\\mathbf{y}\\) for a patient of average age (which is 24.984 years) who was assigned treatment Drug_A and has spent zero months being treated. This quantity is useful because it tells us the baseline pre-treatment value for the average patient who takes Drug_A.\n\n\nCode\nexp(coef(full_mod_pois_centered))[1]\n\n\n(Intercept) \n    112.832"
  },
  {
    "objectID": "derivations/Large_Sample_Practice.html",
    "href": "derivations/Large_Sample_Practice.html",
    "title": "Assorted Large Sample Theory Practice Problems",
    "section": "",
    "text": "Here are a couple practice problems I wrote up while studying for a course in statistical asymptotics. The main focus is on the application of influence functions & U-statistics, though there are some simulation examples of statistical properties with code as well. Sources for the problems are listed throughout; some are taken directly from the original source while others I have modified slightly."
  },
  {
    "objectID": "derivations/Large_Sample_Practice.html#exercise-3.1---asymptotic-statistics",
    "href": "derivations/Large_Sample_Practice.html#exercise-3.1---asymptotic-statistics",
    "title": "Assorted Large Sample Theory Practice Problems",
    "section": "Exercise 3.1 - Asymptotic Statistics",
    "text": "Exercise 3.1 - Asymptotic Statistics\nThis is exercise 3.1 from A.W. van der Vaart’s textbook. The setup is as follows:\n\\[\n\\begin{aligned}\n  & X_1, ..., X_n \\overset{\\small{\\text{IID}}}{\\sim} F \\\\\n  &\\bar{X}_n = n^{-1} \\sum_{i=1}^n X_i \\\\\n  & S^2_n = n^{-1} \\sum_{i=1}^n \\left( X_i - \\bar{X}_n \\right)^2 \\\\\n  & \\mu_4 = \\mathbb{E} \\left[ (X - \\mu)^4 \\right];\\: \\mu_4 \\in \\mathbb{R} \\\\\n\\end{aligned}\n\\]\nWe’re interested in finding the joint asymptotic distribution of the following, and in determining what assumptions are necessary for the two quantities to be considered asymptotically independent:\n\\[\n\\begin{pmatrix}\n  \\sqrt{n}(\\bar{X}_n - \\mu) \\\\\n  \\sqrt{n}(S^2_n - \\sigma^2)\n\\end{pmatrix}\n\\]\nWe’ll start by defining the basics; we know that the sample mean converges in expectation to the population mean, and thus converges in probability as well.\n\\[\n\\mathbb{E} \\left[ \\bar{X}_n \\right]\\mu \\implies \\bar{X}_n \\overset{p}{\\to} \\mu\n\\]\nOn the other hand, \\(S^2_n\\) is not an unbiased estimator, with expectation:\n\\[\n\\mathbb{E} \\left[ S^2_n \\right] = \\frac{n-1}{n} \\sigma^2\n\\]\nHowever, we can show that it converges to \\(\\sigma^2\\) in probability. Note: going forwards, raw moments will be denoted \\(m_k\\), and central moments \\(\\mu_k\\).\n\\[\n\\begin{aligned}\n  S^2_n\n    &= n^{-1} \\sum_{i=1}^n \\left( X_i - \\bar{X}_n \\right)^2 \\\\\n    &= n^{-1} \\sum_{i=1}^n X_i^2 - 2X_i\\bar{X}_n + \\bar{X}_n^2 \\\\\n    &= \\bar{X^2_n} - \\bar{X}^2_n \\\\\n  \\underset{n \\to \\infty}{\\text{lim}} S^2_n\n    &= m_2 - m_1^2 \\\\\n    &= \\sigma^2 \\\\\n  \\implies S^2_n &\\overset{p}{\\to} \\sigma^2 \\\\\n\\end{aligned}\n\\]\nSince both estimators converge in probability to their population parameters, they converge in distribution as well thanks to the following property of stochastic convergence:\n\\[\nX_n \\overset{p}{\\to} X \\implies X_n \\overset{d}{\\to} X\n\\]\nThe asymptotic variance of the sample mean is derived like so:\n\\[\n\\begin{aligned}\n  \\text{Var}(\\bar{X}_n)\n    &= \\text{Var} \\left( n^{-1} \\sum_{i=1}^n X_i \\right) \\\\\n    &= n^{-2} \\sum_{i=1}^n \\text{Var}(X_i) \\\\\n    &= n^{-1}\\sigma^2 \\\\\n\\end{aligned}\n\\]\nThus, the asymptotic distribution of the sample mean is:\n\\[\n\\sqrt{n} \\left( \\bar{X}_n - \\mu \\right) \\overset{d}{\\to} \\mathcal{N}\\left( 0, \\sigma^2 \\right)\n\\]\nDeriving the asymptotic variance for \\(S^2_n\\) is slightly trickier. Going forward, we’ll assume that the observations \\(X_i\\) have been centered around \\(\\mu\\), and thus have zero mean. This will simplify the following derivation somewhat:\n\\[\n\\begin{aligned}\n\\text{Var} \\left( S^2_n \\right)\n  &= \\text{Var} \\left( n^{-1} \\sum_{i=1}^n X_i^2 - \\bar{X}_n^2  \\right) \\\\\n  &= \\text{Var} \\left( n^{-1} \\sum_{i=1}^n X_i^2 \\right) \\\\\n  &= n^{-2} \\sum_{i=1}^n \\text{Var} \\left( X_i^2 \\right) \\\\\n  &= n^{-2} \\sum_{i=1}^n \\mathbb{E}\\left[ X_i^4 \\right] - \\left( \\mathbb{E}[X_i^2] \\right)^2 \\\\\n  &= n^{-2} \\sum_{i=1}^n m_4 - m_2^2 \\\\\n  &= n^{-1} \\left( m_4 - m_2^2 \\right) \\\\\n\\end{aligned}\n\\]\nThus, the asymptotic distribution for the sample variance is:\n\\[\n\\sqrt{n} \\left( S^2_n - \\sigma^2 \\right) \\overset{d}{\\to} \\mathcal{N} \\left( 0, m_4 - m_2^2 \\right)\n\\]\nNow all we need is the covariance between the two estimators. We’ll derive this using the multivariate Delta Method. First, we’ll need to define the sample mean and variance as a functional. Then, we’ll derive the asymptotic distribution of that quantity, the general form of which will be:\n\\[\n\\sqrt{n} \\left( \\hat{\\theta}_n - \\theta \\right) \\overset{d}{\\to} \\mathcal{N}_2(\\mathbf{0}, \\boldsymbol{\\Sigma})\n\\]\nThe multivariate Delta Method then allows us to formulate the joint asymptotic distribution of the original estimators like so:\n\\[\n\\sqrt{n} \\left( \\phi(\\hat{\\theta}_n) - \\phi(\\theta) \\right) \\overset{d}{\\to} \\mathcal{N}_2 \\left( \\mathbf{0},\\: \\phi^\\prime(\\theta) \\boldsymbol{\\Sigma} \\phi^\\prime(\\theta)^T \\right)\n\\]\nWe can derive the covariance between the sample mean & sample variance in the following fashion, making use of some properties of summation:\n\\[\n\\begin{aligned}\n  \\text{Cov} \\left( \\bar{X}_n, S^2_n \\right)\n    &= \\mathbb{E} \\left[ \\left( \\bar{X}_n  - \\mathbb{E} \\left[ \\bar{X}_n \\right] \\right) \\left( S^2_n  - \\mathbb{E} \\left[ S^2_n \\right] \\right) \\right] \\\\\n    &= \\mathbb{E} \\left[ \\left( \\bar{X}_n  - m_1 \\right) \\left( S^2_n  - m_2 \\right) \\right] \\\\\n    &= \\mathbb{E} \\left[ \\bar{X}_n S^2_n -m_2\\bar{X}_n -m_1S^2_n + m_1m_2 \\right] \\\\\n    &= \\mathbb{E} \\left[ \\bar{X}_nS^2_n \\right] - m_2m_1 - m_1m_2 +m_1m_2 \\\\\n    &= \\mathbb{E} \\left[ \\bar{X}_nS^2_n \\right] - m_1m_2 \\\\\n    &= \\mathbb{E} \\left[ \\left( n^{-1} \\sum_{i=1}^n X_i \\right) \\left( n^{-1} \\sum_{i=1}^n X_i^2 \\right)  \\right] - m_1m_2 \\\\\n    &= \\mathbb{E} \\left[ n^{-2} \\sum_{i=1}^n X_i \\sum_{i=1}^n X_i^2 \\right] - m_1m_2 \\\\\n    &= \\mathbb{E} \\left[ n^{-2} \\sum_{i=1}^n \\sum_{j=1}^n X_i X_j^2 \\right] - m_1m_2 \\\\\n    &= n^{-2} \\sum_{i=1}^n \\sum_{j=1}^n \\mathbb{E} \\left[ X_j^3 \\right] -m_1m_2 \\\\\n    &= n^{-2} (n^2m_3) -m_1m_2 \\\\\n    &= m_3 - m_1m_2 \\\\\n\\end{aligned}\n\\]\nThus we have the asymptotic distribution for the first and second moments (this can be verified by checking p.27 of the van der Vaart textbook). For expediency’s sake, we’ll refer to the variance-covariance matrix of the asymptotic distribution as \\(\\boldsymbol{\\Sigma^*}\\) going forwards.\n\\[\n\\sqrt{n} \\left( \\begin{pmatrix} \\bar{X}_n \\\\ \\bar{X^2}_n \\end{pmatrix} - \\begin{pmatrix} m_1 \\\\ m_2 \\end{pmatrix} \\right)\n\\overset{d}{\\to}\n\\mathcal{N}_2 \\left( \\mathbf{0},\\: \\begin{pmatrix} m_2 - m_1^2 & m_3 - m_1m_2 \\\\ m_3 - m_1m_2 & m_4 - m_2^2 \\end{pmatrix} \\right)\n\\]\nNext we need to set up our function, which we do like so:\n\\[\n\\begin{aligned}\n  \\phi(x, y) &= \\begin{pmatrix} x \\\\ y - x^2 \\end{pmatrix} \\\\\n  \\phi \\left( m_1, m_2 \\right) &= \\begin{pmatrix} \\bar{X}_n \\\\ S^2_n \\end{pmatrix} \\\\\n\\end{aligned}\n\\]\nThe gradient of \\(\\phi\\) is then:\n\\[\n\\begin{aligned}\n  \\phi^\\prime_{m_1, m_2}\n    &= \\begin{pmatrix}\n         \\frac{\\partial}{\\partial m_1} \\phi_1(m_1, m_2) & \\frac{\\partial}{\\partial m_1} \\phi_2(m_1, m_2) \\\\\n         \\frac{\\partial}{\\partial m_2} \\phi_1(m_1, m_2) & \\frac{\\partial}{\\partial m_2} \\phi_2(m_1, m_2) \\\\\n       \\end{pmatrix} \\\\\n    &= \\begin{pmatrix}\n         1 & -2m_1 \\\\\n         0 & 1 \\\\\n       \\end{pmatrix}\n\\end{aligned}\n\\]\nUsing the multivariate Delta Method, we have thus arrived at the joint asymptotic distribution of the sample mean & sample variance:\n\\[\n\\sqrt{n} \\left( \\begin{pmatrix} \\bar{X}_n \\\\ S^2_n \\end{pmatrix} - \\begin{pmatrix} \\mu \\\\ \\sigma^2 \\end{pmatrix} \\right)\n\\overset{d}{\\to}\n\\mathcal{N}_2 \\left( \\mathbf{0},\\: \\phi^\\prime_{m_1, m_2} \\boldsymbol{\\Sigma^*} \\left( \\phi^\\prime_{m_1, m_2} \\right)^T \\right)\n\\]\nIn deriving the above quantity, we’ve also figured out what conditions are necessary for \\(\\bar{X}_n\\) and \\(S^2_n\\) to be independent. We defined the covariance between the two estimators above:\n\\[\n\\text{Cov} \\left( \\bar{X}_n, S^2_n \\right) = m_3 - m_1m_2\n\\]\nKeeping in mind that we have centered our data, we know that our raw moments are equivalent to central moments. For symmetric distributions, the expectations of the odd moments are all equal to zero, and thus the covariance as defined above will go to zero if the distribution function \\(F\\) is symmetric. In order for us to strictly say that \\(\\bar{X}_n\\) and \\(S^2_n\\) are independent and not just uncorrelated, the two quantities must be jointly normally distributed, which we have shown above. Thus, as long as \\(F\\) is symmetric, the sample mean and sample variance are independent."
  },
  {
    "objectID": "derivations/Large_Sample_Practice.html#exercise-12.3---asymptotic-statistics",
    "href": "derivations/Large_Sample_Practice.html#exercise-12.3---asymptotic-statistics",
    "title": "Assorted Large Sample Theory Practice Problems",
    "section": "Exercise 12.3 - Asymptotic Statistics",
    "text": "Exercise 12.3 - Asymptotic Statistics\nThis problem is also pulled from the van der Vaart book; the goal is simply to determine an appropriate kernel for a U-statistic for the third central moment.\n\\[\n\\mu_3 = \\mathbb{E} \\left[ (X - \\mathbb{E}[X])^3 \\right]\n\\]\nWe could attempt to define the kernel as we would when creating a U-statistic for the sample variance, as shown below:\n\\[\nh(X_i, X_j) = (X_i - X_j)^3\n\\]\nHowever, this kernel is no symmetric, which is a highly desirable property in U-statistic kernels i.e., \\(h(x_i, x_j) \\neq h(x_j, x_i)\\) as shown below:\n\\[\n\\begin{aligned}\n  h(X_i, X_j)\n    &= (X_i - X_j)^3 \\\\\n    &= X_i^3 -3X_jX_i^2 + 3X_j^2X_i - X_j^3 \\\\\n  h(X_j, X_i)\n    &= (X_j - X_i)^3 \\\\\n    &= X_j^3 -3X_iX_j^2 + 3X_i^2X_j - X_i^3 \\\\\n\\implies h(X_i, X_j) &= -h(X_j, X_i) \\\\\n\\end{aligned}\n\\]\nHowever, any asymmetric U-statistic of degree \\(r\\) may be symmetrized by averaging over all possible input permutations using the following technique:\n\\[\ng(X_1, ..., X_r) = (r!)^{-1} \\sum_{i_1, ..., i_r} h(X_{i_1}, ..., X_{i_r})\n\\]\nWe’ll thus use the following symmetric kernel of degree 3 as detailed in Locke & Spurrier (1978):\n\\[\nh(X_1, X_2, X_3) = \\frac{1}{3} \\sum_{i=1}^3 \\left( X_i - \\frac{1}{3} (X_1 + X_2 + X_3) \\right)^3\n\\]\nThis in turn leads to the following U-statistic for \\(\\mu_k\\):\n\\[\n\\begin{aligned}\n  U_n\n    &= \\binom{n}{3}^{-1} \\sum_{i=1}^n \\sum_{i&lt;j} \\sum_{j&lt;k} h(X_i, X_j, X_k) \\\\\n    &= \\binom{n}{3}^{-1} \\sum_{i=1}^n \\sum_{i&lt;j} \\sum_{j&lt;k} \\frac{1}{3} \\left( \\left( X_i - \\frac{1}{3}(X_i + X_j + X_k) \\right)^3 + \\left( X_j - \\frac{1}{3}(X_i + X_j + X_k) \\right)^3 + \\left( X_k - \\frac{1}{3}(X_i + X_j + X_k) \\right)^3\\right)\n\\end{aligned}\n\\]\nWe can show this empirically by testing it via simulation. Here we simulate \\(n = 1000\\) realizations from \\(X_1, \\dots, X_n \\overset{\\small{\\text{IID}}}{\\sim} \\mathcal{N}(3,\\: 1)\\). Since we’re sampling from a normal distribution, which is symmetric about \\(\\mu\\), the expectation of the third central moment is equal to zero. In the interest of showing how the U-statistic converges towards \\(\\mu_3\\) as sample size grows, we’ll compute the statistic for several values of \\(n\\) and then visualize the results. First, we’ll need to define a helper function for our kernel:\n\n\nCode\nh_ijk &lt;- function(x_i, x_j, x_k) {\n  sum_ijk &lt;- x_i + x_j + x_k\n  mean_ijk &lt;- 1/3 * ((x_i - 1/3 * sum_ijk)^3 + (x_j - 1/3 * sum_ijk)^3 + (x_k - 1/3 * sum_ijk)^3)\n  return(mean_ijk)\n}\n\n\nNow we iterate over sample sizes & save the results. We’ll perform a few replications per sample size value for reproducibility reasons.\n\n\nCode\nn_vals &lt;- purrr::map(c(5, 10, 15, 25, 40, 50, 75, 100, 150, 200, 250, 300, 400, 500), \\(x) rep(x, 3)) %&gt;% \n          purrr::reduce(c)\nU_n_vals &lt;- numeric(length = length(n_vals)) \nfor (n in seq(n_vals)) {\n  set.seed(n)\n  sample_n &lt;- n_vals[n]\n  mu &lt;- 3\n  sigma &lt;- 1\n  x &lt;- rnorm(sample_n, mean = mu, sd = sigma)\n  i &lt;- 1\n  U_sum &lt;- 0\n  while (i &lt;= sample_n) {\n    j &lt;- i + 1\n    while (j &lt;= sample_n) {\n      k &lt;- j + 1\n      while (k &lt;= sample_n) {\n        h_val &lt;- h_ijk(x_i = x[i], x_j = x[j], x_k = x[k])\n        U_sum &lt;- U_sum + h_val\n        k &lt;- k + 1\n      }\n      j &lt;- j + 1\n    }\n    i &lt;- i + 1\n  }\n  U_n &lt;- choose(sample_n, 3)^(-1) * U_sum\n  U_n_vals[n] &lt;- U_n\n}\n\n\nWe can see that the U-statistic grows very close to the true value of zero as \\(n\\) increases. The drawback of this approach is the computational cost; even for this relatively small sample size the runtime is several minutes, and grows on the order of \\(O(n^3)\\).\n\n\nCode\ndata.frame(U = U_n_vals, \n           N = n_vals) %&gt;% \n  ggplot(aes(x = N, y = abs(U))) + \n  geom_point() + \n  geom_smooth(color = \"forestgreen\", se = FALSE) + \n  labs(x = latex2exp::TeX(r\"($\\textit{n}$)\"), \n       y = latex2exp::TeX(r\"($|\\textit{U_n} - \\theta|$)\")) + \n  theme_classic(base_size = 14)"
  },
  {
    "objectID": "derivations/Large_Sample_Practice.html#example-1.3.2---u-statistics-theory-and-practice",
    "href": "derivations/Large_Sample_Practice.html#example-1.3.2---u-statistics-theory-and-practice",
    "title": "Assorted Large Sample Theory Practice Problems",
    "section": "Example 1.3.2 - U-Statistics: Theory and Practice",
    "text": "Example 1.3.2 - U-Statistics: Theory and Practice\nThis problem is a slight modification of one of the examples from Lee (1990) seen on page 13. Instead of deriving the asymptotic distribution of the U-statistic for the sample variance, we’ll do so for the second raw moment \\(m_2\\).\n\\[\n\\theta = E[X^2] = m_2\n\\]\nFrom the definition of variance, we know that \\(m_2 = \\mu_2 + m_1^2\\). Our kernel, which is symmetric, will thus be a combination of the kernels for the sample variance and for the expectation squared:\n\\[\nh(X_1, X_2) = \\frac{(X_1 - X_2)^2}{2} + X_1X_2\n\\]\nhaving expectation:\n\\[\n\\begin{aligned}\n  \\mathbb{E}[h(X_1, X_2)]\n    &= \\mathbb{E} \\left[ \\frac{(X_1 - X_2)^2}{2} + X_1X_2 \\right] \\\\\n    &= \\frac{1}{2}(\\mathbb{E} \\left[ (X_1 - X_2)^2 \\right]) - \\mathbb{E}[X_1X_2] \\\\\n    &= \\frac{1}{2}(m_2 - 2\\mu^2 + m_2) + \\mu^2 \\\\\n    &= m_2 \\\\\n\\end{aligned}\n\\]\nThis leads us to the following U-statistic:\n\\[\nU_n = \\binom{n}{2}^{-1} \\sum_{i=1}^n \\sum_{i&lt;j} \\frac{(X_i - X_j)^2}{2} + X_iX_j\n\\]\nWe define the following:\n\\[\n\\begin{aligned}\n  h_1(X_1, X_2) &= \\mathbb{E}[h(X_1, X_2) | X_1] \\\\\n  h_1^c(X_1, X_2)\n    &= \\mathbb{E}[h(X_1, X_2) | X_1] - \\theta \\\\\n    &= \\mathbb{E}[h(X_1, X_2) | X_1] - m_2 \\\\\n  \\zeta_1\n    &= \\mathbb{E} \\left[ (h_1^c(X_1, X_2))^2 \\right] \\\\\n    &= \\mathbb{E} \\left[ (\\mathbb{E}[h(X_1, X_2) | X_1] - m_2)^2 \\right] \\\\\n    &= \\text{Var} \\left( \\mathbb{E}[h(X_1, X_2) | X_1] \\right) \\\\\n  \\text{Var}(U_n) &\\overset{p}{\\to} \\frac{r^2}{n} \\zeta_1 \\\\\n  \\sqrt{n}(U_n - m_2) &\\overset{d}{\\to} \\mathcal{N}(0,\\: r^2\\zeta_1) \\\\\n\\end{aligned}\n\\]\nWe begin with the expectation of the kernel conditional on \\(X_1\\):\n\\[\n\\begin{aligned}\n  h_1(X_1, X_2)\n    &= \\mathbb{E} \\left[ \\frac{(X_1 - X_2)^2}{2} + X_1X_2 | X_1 \\right] \\\\\n    &= \\frac{1}{2} \\mathbb{E}[X_1^2 -2X_1X_2 + X_2^2 | X_1] + \\mathbb{E}[X_1X_2 | X_1] \\\\\n    &= \\frac{1}{2}(X_1^2 - 2X_1\\mu + m_2) + X_1\\mu \\\\\n    &= \\frac{X_1^2 + m_2}{2}\n\\end{aligned}\n\\]\nFrom which we can derive \\(\\zeta_1\\):\n\\[\n\\begin{aligned}\n  \\zeta_1\n    &= \\text{Var} \\left( \\frac{X_1^2 + m_2}{2} \\right) \\\\\n    &= \\frac{1}{4} \\text{Var}(X_1^2 + m_2) \\\\\n    &= \\frac{1}{4} \\left( \\text{Var}(X_1^2) + \\text{Var}(m_2) \\right) \\\\\n    &= \\frac{1}{4} \\text{Var}(X_1^2 \\\\\n    &= \\frac{1}{4} \\mathbb{E} \\left[ (X_1^2 - m_2)^2 \\right] \\\\\n    &= \\frac{1}{4}(m_4 - 2m_2m_2 + m_2^2) \\\\\n    &= \\frac{m_4 - m_2^2}{4} \\\\\n\\end{aligned}\n\\]\nFinally, since our kernel has degree \\(r = 2\\):\n\\[\n\\sqrt{n}(U_n - m_2) \\overset{d}{\\to} \\mathcal{N}(0,\\: m_4 - m_2^2)\n\\]\nWe can confirm this using simulation as well. First, we define a new function that computes our kernel:\n\n\nCode\nh_ij &lt;- function(x_i, x_j) {\n  m2_ij &lt;- ((x_i - x_j)^2) / 2 + x_i * x_j\n  return(m2_ij)\n}\n\n\nWe’ll simulate observations from the following distribution. From the definition of variance, we know that \\(m_2 = \\text{Var}(X) + \\left( \\mathbb{E}(X) \\right)^2\\), which in our case is: \\(m_2 = 1 + 2^2 = 5\\). This is the value against which we’ll compare our U-statistics, whose expectation is \\(m_2\\).\n\\[\nX_1, \\dots, X_n \\overset{\\small{\\text{IID}}}{\\sim} \\mathcal{N}(2,\\: 1)\n\\]\nNow we iterate over a range of possible values for \\(n\\), running the simulation 3x per value, and recording the U-statistics that we estimate.\n\n\nCode\nn_vals &lt;- purrr::map(c(5, 10, 15, 25, 40, 50, 75, 100, 150, 200, 250, 300, 400, 500, 750, 1000, 1250), \\(x) rep(x, 3)) %&gt;% \n          purrr::reduce(c)\nU_n_vals &lt;- numeric(length = length(n_vals)) \nfor (n in seq(n_vals)) {\n  set.seed(n)\n  sample_n &lt;- n_vals[n]\n  mu &lt;- 2\n  sigma &lt;- 1\n  x &lt;- rnorm(sample_n, mean = mu, sd = sigma)\n  i &lt;- 1\n  U_sum &lt;- 0\n  while (i &lt;= sample_n) {\n    j &lt;- i + 1\n    while (j &lt;= sample_n) {\n      h_val &lt;- h_ij(x_i = x[i], x_j = x[j])\n      U_sum &lt;- U_sum + h_val\n      j &lt;- j + 1\n    }\n    i &lt;- i + 1\n  }\n  U_n &lt;- choose(sample_n, 2)^(-1) * U_sum\n  U_n_vals[n] &lt;- U_n\n}\n\n\nPlotting the results, we see a monotonically decreasing trend of the absolute error of \\(U_n\\) when compared to the true value \\(m_2 = 5\\).\n\n\nCode\ndata.frame(U = U_n_vals, \n           N = n_vals) %&gt;% \n  ggplot(aes(x = N, y = abs(U - 5))) + \n  geom_point() + \n  geom_smooth(color = \"forestgreen\", se = FALSE) + \n  labs(x = latex2exp::TeX(r\"($\\textit{n}$)\"), \n       y = latex2exp::TeX(r\"($|\\textit{U_n} - \\theta|$)\")) + \n  theme_classic(base_size = 14)"
  },
  {
    "objectID": "derivations/Large_Sample_Practice.html#example-3.2---zepeda-tello-r.-et-al",
    "href": "derivations/Large_Sample_Practice.html#example-3.2---zepeda-tello-r.-et-al",
    "title": "Assorted Large Sample Theory Practice Problems",
    "section": "Example 3.2 - Zepeda-Tello, R. et al",
    "text": "Example 3.2 - Zepeda-Tello, R. et al\nThis example is pulled from The delta-method and influence function in medical statistics: A reproducible tutorial, a preprint from June 2022. Section 3 includes several examples of asymptotic distributions of estimators derived using the functional delta method. Example 3.2 shows the derivation of the asymptotic distribution of the sample mean using the influence function instead of the Central Limit Theorem; they use a discrete distribution for simplicity, but here we’ll use a continuous distribution instead.\nWe assume that observations are generated from the following distribution with mean \\(\\mu\\) and variance \\(\\sigma^2\\):\n\\[\nX_1, \\dots, X_n \\overset{\\small{\\text{IID}}}{\\sim} F\n\\]\nThe estimator can be formulated as a functional, with \\(\\phi(\\cdot)\\) simply being the identity function:\n\\[\n\\begin{aligned}\n  \\Psi\n    &= \\phi(\\mathbb{P}_X) \\\\\n    &= \\phi(\\theta) \\\\\n    &= \\mu \\\\\n  \\widehat{\\Psi}_n\n    &= \\phi(\\widehat{P}_X) \\\\\n    &= \\phi(\\hat{\\theta}_n) \\\\\n    &= \\bar{X}_n \\\\\n\\end{aligned}\n\\]\nVia a Taylor expansion, we have:\n\\[\n\\begin{aligned}\n\\widehat{\\Psi}_n &\\approx \\Psi + IF(X) \\\\\n\\implies IF(X) &= \\bar{X}_n - \\mu + o_p(1) \\\\\n\\end{aligned}\n\\]\nThe asymptotic distribution is as follows; we note that the expectation of the influence function is always equal to zero, and thus its variance is equal to its second raw moment.\n\\[\n\\phi(\\hat{\\theta}_n - \\theta) \\overset{d}{\\to} \\mathcal{N} \\left( 0,\\: \\text{Var} \\left( IF(X) \\right) \\right)\n\\]\nWe derive the variance of the influence function, and obtain the same result as we would have in using the CLT:\n\\[\n\\begin{aligned}\n  \\text{Var} \\left( IF(X) \\right)\n    &= \\text{Var} \\left( \\bar{X}_n - \\mu \\right) \\\\\n    &= \\text{Var} \\left( n^{-1} \\sum_{i=1}^n X_i \\right) \\\\\n    &= n^{-2} \\sum_{i=1}^n \\text{Var}(X_i) \\\\\n    &= n^{-1}\\sigma^2 \\\\\n\\end{aligned}\n\\]\nThus the asymptotic distribution of the sample mean is:\n\\[\n\\sqrt{n} \\left( \\bar{X}_n - \\mu \\right) \\overset{d}{\\to} \\mathcal{N}(0,\\: \\sigma^2)\n\\]"
  },
  {
    "objectID": "derivations/Large_Sample_Practice.html#exercise-12.7---asymptotic-statistics",
    "href": "derivations/Large_Sample_Practice.html#exercise-12.7---asymptotic-statistics",
    "title": "Assorted Large Sample Theory Practice Problems",
    "section": "Exercise 12.7 - Asymptotic Statistics",
    "text": "Exercise 12.7 - Asymptotic Statistics\nI’m modifying this question slightly; the original asks for the asymptotic distribution of the U-statistic for \\(\\mu^2\\), and in addition we’ll derive its joint distribution with the U-statistic for \\(m_2\\) that we found previously using influence functions.\nFirst, we define the given quantities:\n\\[\n\\begin{aligned}\n  X_1, \\dots, X_n &\\overset{\\small{\\text{IID}}}{\\sim} F \\\\\n  \\mathbb{E} \\left[ X^2_1 \\right] &&lt; \\infty \\\\\n\\end{aligned}\n\\]\nWe define the following symmetric kernel to use in the U-statistic for \\(\\mu^2\\):\n\\[\nh(X_1, X_2) = X_1X_2\n\\]\nThe expectation of that kernel is given by:\n\\[\n\\begin{aligned}\n  \\mathbb{E} \\left[ h(X_1, X_2) \\right]\n    &= \\mathbb{E}[X_1X_2] \\\\\n    &= \\mathbb{E}[X_1]\\mathbb{E}[X_2] \\\\\n    &= \\mu^2 \\\\\n\\end{aligned}\n\\]\nThe U-statistic is thus:\n\\[\nU_n = \\binom{n}{2}^{-1} \\sum_{i=1}^n \\sum_{i&lt;j} X_iX_j\n\\]\nNext we derive the asymptotic distribution of the U-statistic:\n\\[\n\\begin{aligned}\n  h_1(X_1, X_2)\n    &= \\mathbb{E} \\left[ h(X_1, X_2) | X_1 \\right] \\\\\n    &= \\mathbb{E}[X_1X_2 | X_1] \\\\\n    &= X_1\\mu \\\\\n  \\implies \\zeta_1\n    &= \\mathbb{E} \\left[ (h_1^c(X_1, X_2))^2 \\right] \\\\\n    &= \\mathbb{E} \\left[(h_1(X_1, X_2) - \\mu^2)^2 \\right] \\\\\n    &= \\text{Var}(h_1(X_1, X_2)) \\\\\n    &= \\text{Var}(X_1\\mu) \\\\\n    &= \\mu^2\\text{Var}(X_1) \\\\\n    &= \\mu^2\\sigma^2 \\\\\n  \\implies \\sqrt{n}(U_n - \\mu^2) &\\overset{d}{\\to} \\mathcal{N}(0,\\: 4\\mu^2\\sigma^2)\n\\end{aligned}\n\\]\nThe influence function of a U-statistic is given by:\n\\[\nIF_U(X) = r h_1^c(X_1, \\dots, X_r)\n\\]\nThus the influence function for our U-statistic is:\n\\[\nIF_U(X) = 2\\mu(X_1 - \\mu)\n\\]\nRemembering the U-statistic we derived earlier for \\(m_2\\), which we’ll now refer to as \\(U^*\\) in order to distinguish it from the other statistic:\n\\[\nU_n^* = \\binom{n}{2}^{-1} \\sum_{i=1}^n \\sum_{i&lt;j} \\frac{(X_i - X_j)^2}{2} + X_iX_j\n\\]\nWe now define its influence function as:\n\\[\n\\begin{aligned}\n  IF_{U^*}(X)\n    &= 2 \\left( \\frac{X_1^2 + m_2}{2} - m_2 \\right) \\\\\n    &= X_1^2 - m_2 \\\\\n\\end{aligned}\n\\]\nThus, the joint distribution of the two U-statistics is:\n\\[\n\\sqrt{n} \\begin{pmatrix} U_n - \\mu^2 \\\\ U_n^* - m_2 \\end{pmatrix}\n\\overset{d}{\\to}\n\\boldsymbol{\\mathcal{N}}_2 \\left(\\mathbf{0},\\:\n  \\begin{pmatrix}\n    \\text{Var} \\left( IF_U \\right) & \\text{Cov} \\left( IF_U, IF_{U^*} \\right) \\\\\n    \\text{Cov} \\left( IF_U, IF_{U^*} \\right) & \\text{Var} \\left( IF_{U^*} \\right) \\\\\n  \\end{pmatrix} \\right)\n\\]\nThe variance of an influence function is equal to its second raw moment, as its first raw moment is always equal to zero. Ergo, the variances of the two U-statistics are as follows (they should match the asymptotic variances from earlier):\n\\[\n\\begin{aligned}\n  \\text{Var} \\left( IF_U(X) \\right)\n    &= \\mathbb{E} \\left[ IF_U(X)^2 \\right] \\\\\n    &= \\mathbb{E} \\left[ (2\\mu(X_1 - \\mu))^2 \\right] \\\\\n    &= \\mathbb{E} \\left[ 4\\mu^2(X_1 - \\mu)^2 \\right] \\\\\n    &= 4\\mu^2\\sigma^2 \\\\\n  \\implies \\text{Var} \\left( IF_{U^*}(X) \\right)\n    &= \\mathbb{E} \\left[ (X_1^2 - m_2)^2 \\right] \\\\\n    &= \\text{Var} \\left( X_1^2 \\right) \\\\\n    &= \\mathbb{E} \\left[ (X_1^2)^2 \\right] - \\left( \\mathbb{E} \\left[ X_1^2 \\right] \\right)^2 \\\\\n    &= m_4 - m_2^2 \\\\\n\\end{aligned}\n\\]\nLastly, the covariance term:\n\\[\n\\begin{aligned}\n  \\text{Cov} \\left( IF_U, IF_{U^*} \\right)\n    &= \\mathbb{E} \\left[ IF_U IF_{U^*} \\right] - \\mathbb{E}[IF_U]\\mathbb{E}[IF_{U^*}] \\\\\n    &= \\mathbb{E} \\left[ 2\\mu(X_1 - \\mu)(X_1 - m_2) \\right] - \\mathbb{E}[2\\mu(X_1 - \\mu)] \\mathbb{E}[X_1 - m_2] \\\\\n    &= \\mathbb{E}[2\\mu(X_1^2 - X_1m_2 - \\mu X_1 + \\mu m_2)] - 2\\mu \\left( \\mathbb{E}[X_1] - \\mu \\right)(\\mu - m_2) \\\\\n    &= 2\\mu(m_2 - \\mu m_2 - \\mu^2 + \\mu m_2) \\\\\n    &= 2\\mu(m_2 - \\mu^2) \\\\\n\\end{aligned}\n\\]\nThus we have arrived at the joint asymptotic distribution:\n\\[\n\\sqrt{n} \\begin{pmatrix} U_n - \\mu^2 \\\\ U_n^* - m_2 \\end{pmatrix}\n\\overset{d}{\\to}\n\\boldsymbol{\\mathcal{N}}_2 \\left(\\mathbf{0},\\:\n  \\begin{pmatrix}\n    4\\mu^2\\sigma^2 & 2\\mu(m_2 - \\mu^2) \\\\\n    2\\mu(m_2 - \\mu^2) & m_4 - m_2^2 \\\\\n  \\end{pmatrix} \\right)\n\\]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "I am a first-year PhD student at the University of Florida under Dr. Rhonda Bacher. My primary research interest are genomics and genetics, and particularly single cell RNA-seq computational method development. I mostly develop tools related to clustering, trajectory inference, and differential expression analysis. In addition, I also focus on scientific reproducibility, computational scalability, and interpretable inference."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\nUniversity of Florida | PhD Biostatistics\nAug 2022 - Current\nUniversity of Florida | MS Biostatistics\nAug 2020 - May 2022\nUniversity of North Carolina | BS Statistics\nAug 2016 - May 2020"
  },
  {
    "objectID": "index.html#work-experience",
    "href": "index.html#work-experience",
    "title": "About",
    "section": "Work Experience",
    "text": "Work Experience\nUniversity of Florida | Graduate Research & Teaching Assistant\nMay 2021 - present\nBlue Cross Blue Shield of Florida | Data Analyst\nJuly 2020 - July 2022\nUniversity of North Carolina | Undergraduate Research Assistant\nJune 2019 - July 2020"
  },
  {
    "objectID": "knowledge_base/R_Development.html",
    "href": "knowledge_base/R_Development.html",
    "title": "R Development Resources",
    "section": "",
    "text": "Introduction\nThis document houses a list of resources I’ve put together that have helped me in my journey from novice R user to experienced (kinda) R package developer. Most of the resources will be centered around developing packages specifically, but some pertain to other types of R projects.\n\n\nPackage Development\n\nR Packages\n\nThe official R package development book, written by Hadley Wickham & Jenny Bryan. Contains a startup guide and sections on metadata, dependencies, unit testing, and documentation. Good comprehensive resource, but not the quickest way to get up & running. This package does have non-R dependencies, but they’re free & easy to install.\n\nThe {usethis} package\n\nThis R package removes a lot of headaches from setting up a new R package or other project. It contains functions to create a new R package, set up continuous integration (CI) tools, connect your package to a GitHub repository, and much more. Essentially, it removes a lot of the point-and-click steps that used to be necessary to set up an R package & get it version-controlled, and generally just makes development a lot easier.\n\nWriting R Extensions\n\nThis book, written by the R Core Team, is a lower-level guide to creating R packages, writing R documentation, debugging, linking R with C / C++, and other advanced topics. It’s useful if you’re getting deeper into package development & already have a very solid handle on the basics.\n\n\n\n\nComputational Efficiency\n\nCode profiling with {proffer}\n\nCode profiling allows you to see a breakdown in graph or table form of which functions in a piece of code are taking the longest to execute. This is done at varying hierarchical levels of resolution, which means you can see that e.g., a function you wrote called run_analysis() is taking up 50% of your computation time, and that within that function the main culprit is the subfunction load_large_dataset(). As such, it becomes very simple & quick to identify the best targets for further optimization of your code with respect to runtime.\n\nBenchmarking runtime using {microbenchmark}\n\nThis package is a very light benchmarking utility. It allows you to compare a list of different functions’ runtime by executing each function a given number of times e.g., 100 times, and returning the distribution of runtime for each function. This makes it very easy to quickly see which implementation of a given task is better with respect to runtime. The source repository can be found here.\n\n\n\n\nReproducible Research\n\nReproducible pipelines in R using {targets}\n\nThe {targets} package is one of my favorite R tools, & the well-written docs above show how to create version-controlled pipelines entirely using R. This framework is an absolute godsend for large projects, simulation studies, etc., and I’ve used it on every longterm computational project I’ve worked on in the past 2 years. It makes tracking, reproducing, & parallelizing the execution of large codebases very easy, and makes reproducible research accessible to anyone with a good handle on R.\n\nScientific writing via quarto\n\nquarto is a more fully-featured successor to RMarkdown, and enables the user to combine code, Markdown-formatted text, images, equations, etc. in a single document. Citations via supported as well, which makes technical writing relatively easy. There is support for LaTeX, which is great for homework assignments, proofs, and Methods sections. In addition, you can use quarto to create websites, books, presentations, and more. This site itself is actually run using quarto. I’d highly recommend it over RMarkdown at this point, both for its breadth of features & its expanded support of languages (Python, Julia, R, etc.) & IDEs (RStudio, VS Code, Jupyter notebooks). Full documentation can be found here.\n\nHow to control stochasticity when processing in parallel\n\nThis presentation describes how to produce reproducible random number streams when using one of R’s several parallel processing frameworks. It’s pretty applied (not theoretical), and several useful code examples are shown.\n\n\n\n\nDevelopment Best Practices\n\nWhat They Forgot to Teach You About R\n\nThis online book is less about package development & more about R’s idiosyncrasies, but it contains a bunch of useful tips & tricks on how to make your code more reproducible & less brittle. The debugging section is clear & concise, and contains links to other, more detailed resources as well.\n\n\n\n\nInterfacing with Other Languages\n\n{reticulate}\n\nSeamlessly interact with Python from your R session. Super easy to use & fairly full-featured, this package makes things like performing scRNA-seq analysis with both R & Python libraries a breeze. This package is developed by the team at RStudio & is actively maintained.\n\n{JuliaCall}\n\nAllows you to use Julia from within an R session. A great vignette can be found here.\n\n\n\n\nMiscellaneous\n\nThe R Inferno\n\nThis amusingly-titled & engagingly-written book covers a variety of oddities & frustrating idiosyncrasies that R has, many of which are holdovers from when R was being first developed. If you’re having an annoyingly difficult low-level problem, this book might have the answer.\n\nradian: an improved R console\n\nIf you often use R in the terminal, it can be a frustrating experience when compared to all the features (syntax highlighting, autocomplete, bracket-matching, etc.) that RStudio has. radian is a command line tool that adds all these aesthetic features to your R console. Simply install the Python-based library, then start calling radian instead of R when using R from the terminal."
  },
  {
    "objectID": "knowledge_base/scRNAseq.html",
    "href": "knowledge_base/scRNAseq.html",
    "title": "scRNA-seq Resources",
    "section": "",
    "text": "Here I’ll catalog useful papers, preprints, method vignettes, Twitter discussions, etc. that I’ve found helpful while learning how to process and analyze single cell RNA-seq data. When possible, I’ll link to static versions of things in the hopes that links don’t break. I’ll categorize resources according to which problem they address e.g., raw data processing, clustering, visualization, etc., though some resources will of course touch on multiple topics."
  },
  {
    "objectID": "knowledge_base/scRNAseq.html#via-pseudotime",
    "href": "knowledge_base/scRNAseq.html#via-pseudotime",
    "title": "scRNA-seq Resources",
    "section": "Via Pseudotime",
    "text": "Via Pseudotime\n\nSlingshot: cell lineage and pseudotime inference for single-cell transcriptomics\n\nThe {slingshot} package is my currently preferred method for estimating a pseudotemporal cellular ordering. A decent vignette can be found here. I would absolutely recommend using principal components as input to the algorithm instead of UMAP / t-SNE components.\n\nTrajectory-based differential expression analysis for single-cell sequencing data\n\nThis paper describes the development of the {tradeSeq} R package, which uses generalized additive models (GAMs) to perform differential expression over an inferred cellular trajectory. The package has some limitations, but provides a variety of different tests of different patterns of gene expression, and overall strikes a good balance between running quickly & providing accurate results. A good vignette can be accessed here. A nice characteristic of the method is that it is agnostic with respect to the type of pseudotime estimation used, meaning the user can derive their cellular ordering using any pseudotime or RNA velocity method prior to running {tradeSeq}."
  },
  {
    "objectID": "knowledge_base/scRNAseq.html#via-rna-velocity",
    "href": "knowledge_base/scRNAseq.html#via-rna-velocity",
    "title": "scRNA-seq Resources",
    "section": "Via RNA Velocity",
    "text": "Via RNA Velocity\n\nRNA velocity unravaled\nOn the mathematics of RNA velocity I: Theoretical analysis"
  },
  {
    "objectID": "tutorials/GEE_Benchmarking.html",
    "href": "tutorials/GEE_Benchmarking.html",
    "title": "Benchmarking Negative Binomial GEE Model Backends",
    "section": "",
    "text": "In the course of my recent work on trajectory differential expression, I’ve spent a fair amount of time fitting generalized estimating equation (GEE) models. These models are like classical GLMs in that they can handle non-normally distributed response variables via some specified link function & iterative estimation of coefficients, but they differ in that they can account for the variation inherent to longitudinal or otherwise clustered datasets in which observations are measured repeatedly from multiple subjects & are thus not independent. Since scRNA-seq experiments are almost always composed of samples from multiple subjects nowadays, GEEs can be of great use when building models of gene expression, as they allow us to be more confident that our standard errors are accurate. Note that unlike (generalized) linear mixed models, the GEE is a marginal model and thus provides only a population-level fit - GLMMs are conditional models as they provide subject-specific fits.\nSince single cell mRNA abundance follows the negative binomial distribution, it’s necessary that whatever GEE fitting algorithm we use support that distribution. Since the negative binomial is a two-parameter distribution, this does complicate things; the most commonly-used R packages for GEEs do not support NB models. We do have a couple options in R though, the Python statsmodels ecosystem supports NB GEEs as well, and there’s a Julia package too. Our goal here will be to benchmark the available options in terms of runtime and model accuracy in terms of the fitted values & the estimated parameters. We’ll keep our simulated data simple, with a negative binomial response \\(Y\\) and a single continuously-valued covariate \\(X\\); thus we’ll estimate the coefficient vector \\(\\boldsymbol{\\beta} = [\\beta_0, \\beta_1]^T\\) using each method for each set of simulations."
  },
  {
    "objectID": "tutorials/GEE_Benchmarking.html#r",
    "href": "tutorials/GEE_Benchmarking.html#r",
    "title": "Benchmarking Negative Binomial GEE Model Backends",
    "section": "R",
    "text": "R\n\n\nCode\nlibrary(dplyr)       # data manipulation\nlibrary(ggplot2)     # plots \nlibrary(JuliaCall)   # call Julia from R\nlibrary(reticulate)  # call Python from R"
  },
  {
    "objectID": "tutorials/GEE_Benchmarking.html#python",
    "href": "tutorials/GEE_Benchmarking.html#python",
    "title": "Benchmarking Negative Binomial GEE Model Backends",
    "section": "Python",
    "text": "Python\nWe’ll call the Python code from R using {reticulate}, but we’ll need to make sure to use the virtual environment I set up previously that has the statsmodels and pandas libraries (and their various dependencies) installed.\n\n\nCode\nuse_virtualenv(\"~/Desktop/Python/science/venv/\", required = TRUE)\nsm &lt;- import(\"statsmodels.api\")\npd &lt;- import(\"pandas\")"
  },
  {
    "objectID": "tutorials/GEE_Benchmarking.html#julia",
    "href": "tutorials/GEE_Benchmarking.html#julia",
    "title": "Benchmarking Negative Binomial GEE Model Backends",
    "section": "Julia",
    "text": "Julia\nWe’ll also need to activate a Julia environment, into which I’ve installed the GEE.jl package and its necessary dependencies.\n\n\nCode\njulia_setup(verbose = FALSE)\njulia_command('using Pkg; Pkg.activate(\"/Users/jack/Desktop/Julia/science/\");')\njulia_command(\"using Distributions, GLM, GEE, DataFrames;\")"
  },
  {
    "objectID": "tutorials/GEE_Benchmarking.html#helper-functions",
    "href": "tutorials/GEE_Benchmarking.html#helper-functions",
    "title": "Benchmarking Negative Binomial GEE Model Backends",
    "section": "Helper Functions",
    "text": "Helper Functions\nUsing the same general simulation procedure from the example above, we’ll write a function to simulate negative binomial data suitable for using GEEs. We’ll generate multiple observations per subject, though the resulting data will be in the same format, albeit with an added subject ID column. We’ll keep things simple by allocating our total sample size evenly across subjects & keeping \\(\\boldsymbol{\\beta}\\) constant across all subjects.\n\n\nCode\nsim_gee_data &lt;- function(n.subjects = NULL, \n                         n.per.subject = NULL, \n                         dropout.rate = 0.1, \n                         theta.y = 3) {\n  # simulate true coefficients\n  sim_beta &lt;- rnorm(2, mean = 0, sd = 0.5)\n  # simulate X & Y per subject\n  subject_names &lt;- paste0(\"S\", seq(n.subjects))\n  subject_sims &lt;- purrr::map(subject_names, function(s) {\n    sim_df &lt;- data.frame(ID = s, \n                         X = rnorm(n.per.subject, mean = 0, sd = 1)) %&gt;% \n              mutate(Beta_X = sim_beta[1] + sim_beta[2] * X, \n                     Exp_Beta_X = exp(Beta_X)) %&gt;% \n              rowwise() %&gt;% \n              mutate(Y = rnbinom(1, mu = Exp_Beta_X, size = theta.y)) %&gt;% \n              ungroup()\n  })\n  subject_sim_df &lt;- purrr::reduce(subject_sims, rbind) %&gt;% \n                    mutate(ID = as.factor(ID))\n  # add stochastic dropout\n  dropout_idx &lt;- sample(seq(nrow(subject_sim_df)), size = round(dropout.rate * nrow(subject_sim_df)))\n  subject_sim_df$Y[dropout_idx] &lt;- 0\n  res_list &lt;- list(beta = sim_beta, \n                   sim_df = subject_sim_df)\n  return(res_list)\n}\n\n\nNext, we’ll write a function to run all of our different model types. If we use the R implementations of the GEE framework, we need to provide an estimate for \\(\\theta\\), since the estimation procedure depends on \\(\\theta\\) being “known”. To approximate this, we provide the value of \\(\\theta\\) estimated using the intercept-only model, which in my experience has been a good enough approximation for simpler datasets like this one.\n\n\nCode\nrun_model &lt;- function(sim.data = NULL, model.type = NULL) {\n  # run correct model framework\n  if (model.type == \"NB GLM\") {\n    start_time &lt;- Sys.time()\n    model_fit &lt;- MASS::glm.nb(Y ~ X, \n                              data = sim.data, \n                              link = \"log\")\n    diff_time &lt;- Sys.time() - start_time\n    model_preds &lt;- predict(model_fit, type = \"link\")\n    model_coef &lt;- coef(model_fit)\n    model_est_alpha &lt;- NA_real_\n  } else if (model.type == \"geeM\") {\n    start_time &lt;- Sys.time()\n    theta_hat &lt;- MASS::theta.mm(y = sim.data$Y,\n                                mu = mean(sim.data$Y),\n                                dfr = nrow(sim.data) - 1)\n    model_fit &lt;- geeM::geem(Y ~ X, \n                            id = sim.data$ID, \n                            data = sim.data, \n                            family = MASS::negative.binomial(theta = theta_hat, link = \"log\"), \n                            corstr = \"exchangeable\", \n                            sandwich = TRUE)\n    diff_time &lt;- Sys.time() - start_time\n    model_preds &lt;- predict(model_fit, type = \"link\")\n    model_coef &lt;- coef(model_fit)\n    model_est_alpha &lt;- model_fit$alpha\n  } else if (model.type == \"mmmgee\") {\n    theta_hat &lt;- MASS::theta.mm(y = sim.data$Y,\n                                mu = mean(sim.data$Y),\n                                dfr = nrow(sim.data) - 1)\n    start_time &lt;- Sys.time()\n    model_fit &lt;- mmmgee::geem2(Y ~ X, \n                               id = sim.data$ID, \n                               data = sim.data, \n                               family = MASS::negative.binomial(theta = theta_hat, link = \"log\"), \n                               corstr = \"exchangeable\", \n                               sandwich = TRUE)\n    diff_time &lt;- Sys.time() - start_time\n    model_preds &lt;- predict(model_fit, type = \"link\")\n    model_coef &lt;- coef(model_fit)\n    model_est_alpha &lt;- model_fit$alpha\n  } else if (model.type == \"statsmodels\") {\n    start_time &lt;- Sys.time()\n    nb_family &lt;- sm$families$NegativeBinomial(link = sm$genmod$families$links$log)\n    cor_structure &lt;- sm$cov_struct$Exchangeable()\n    py_gee &lt;- sm$GEE$from_formula(\"Y ~ X\", \n                                  \"ID\", \n                                  data = sim.data, \n                                  cov_struct = cor_structure, \n                                  family = nb_family)\n    model_fit &lt;- py_gee$fit()\n    diff_time &lt;- Sys.time() - start_time\n    model_preds &lt;- model_fit$get_prediction()$linpred$predicted_mean\n    model_coef &lt;- model_fit$params\n    model_est_alpha &lt;- model_fit$cov_struct$dep_params\n  } else if (model.type == \"GEE.jl\") {\n    start_time &lt;- Sys.time()\n    JuliaCall::julia_assign(\"sim_data\", sim.data)\n    JuliaCall::julia_command('model_fit = gee(@formula(Y ~ X), sim_data, sim_data.ID, NegativeBinomial(), ExchangeableCor(), LogLink(), cov_type=\"robust\");')\n    diff_time &lt;- Sys.time() - start_time\n    model_est_alpha &lt;- JuliaCall::julia_eval(\"GEE.corparams(model_fit)\")\n    model_coef &lt;- JuliaCall::julia_eval(\"GEE.coef(model_fit)\")\n    model_preds &lt;- log(JuliaCall::julia_eval(\"GEE.predict(model_fit)\"))  # GEE.predict() gives fitted values \n  }\n  # format results & compute model error\n  names(model_coef) &lt;- c(\"B0\", \"B1\")\n  model_rmse &lt;- yardstick::rmse_vec(truth = sim.data$Y, \n                                    estimate = exp(model_preds))\n  model_huber_loss &lt;- yardstick::huber_loss_vec(truth = sim.data$Y, \n                                                estimate = exp(model_preds), \n                                                delta = 2)\n  res_list &lt;- list(model_type = model.type, \n                   model_runtime = as.numeric(diff_time), \n                   model_runtime_units = attributes(diff_time)$units, \n                   model_rmse = model_rmse, \n                   model_huber_loss = model_huber_loss, \n                   model_beta = model_coef, \n                   model_alpha = model_est_alpha)\n  return(res_list)\n}"
  },
  {
    "objectID": "tutorials/GEE_Benchmarking.html#running-the-experiment",
    "href": "tutorials/GEE_Benchmarking.html#running-the-experiment",
    "title": "Benchmarking Negative Binomial GEE Model Backends",
    "section": "Running the Experiment",
    "text": "Running the Experiment\nWe fit each model over 100 iterations, and save the results in a list ({purrr} is great for this kind of thing).\n\n\nCode\nsim_list &lt;- purrr::map(seq(100), function(i) {\n  set.seed(i)\n  sim_data &lt;- sim_gee_data(n.subjects = 3, \n                           n.per.subject = 400, \n                           dropout.rate = 0.1, \n                           theta.y = 5)\n  glm_res &lt;- run_model(sim.data = sim_data$sim_df, model.type = \"NB GLM\")\n  geeM_res &lt;- run_model(sim.data = sim_data$sim_df, model.type = \"geeM\")\n  mmmgee_res &lt;- run_model(sim.data = sim_data$sim_df, model.type = \"mmmgee\")\n  statsmodels_res &lt;- run_model(sim.data = sim_data$sim_df, model.type = \"statsmodels\")\n  julia_GEE_res &lt;- run_model(sim.data = sim_data$sim_df, model.type = \"GEE.jl\")\n  all_models &lt;- list(glm_res, \n                     geeM_res, \n                     mmmgee_res, \n                     statsmodels_res, \n                     julia_GEE_res)\n  overall_res_df &lt;- data.frame(Iter = i, \n                               Beta_0 = sim_data$beta[1], \n                               Beta_1 = sim_data$beta[2], \n                               Method = purrr::map_chr(all_models, \\(x) x$model_type), \n                               Est_Beta_0 = purrr::map_dbl(all_models, \\(x) x$model_beta[1]), \n                               Est_Beta_1 = purrr::map_dbl(all_models, \\(x) x$model_beta[2]), \n                               Est_Alpha = purrr::map_dbl(all_models, \\(x) x$model_alpha), \n                               RMSE = purrr::map_dbl(all_models, \\(x) x$model_rmse), \n                               Huber_Loss = purrr::map_dbl(all_models, \\(x) x$model_huber_loss), \n                               Runtime = purrr::map_dbl(all_models, \\(x) x$model_runtime), \n                               Runtime_Units = purrr::map_chr(all_models, \\(x) x$model_runtime_units))\n  return(overall_res_df)\n})\n\n\nLet’s coerce the results to a dataframe & add a couple more features.\n\n\nCode\nsim_res_df &lt;- purrr::reduce(sim_list, rbind) %&gt;% \n              mutate(Abs_Error_Beta0 = abs(Beta_0 - Est_Beta_0), \n                     Abs_Error_Beta1 = abs(Beta_1 - Est_Beta_1), \n                     Runtime_Seconds = if_else(Runtime_Units == \"secs\", Runtime, Runtime * 60))"
  },
  {
    "objectID": "tutorials/SCISSORS_Reclustering.html",
    "href": "tutorials/SCISSORS_Reclustering.html",
    "title": "scRNA-seq Reclustering with {SCISSORS}",
    "section": "",
    "text": "In this tutorial we’ll walk through a basic single cell analysis, with a focus on fine-tuning clustering results using the {SCISSORS} package, which I wrote during my time at UNC Chapel Hill."
  },
  {
    "objectID": "tutorials/SCISSORS_Reclustering.html#preprocessing",
    "href": "tutorials/SCISSORS_Reclustering.html#preprocessing",
    "title": "scRNA-seq Reclustering with {SCISSORS}",
    "section": "Preprocessing",
    "text": "Preprocessing\nWe’ll do some minor quality-control checking first by filtering out cells with a high percentage of mitochondrial reads or very low or high numbers of detected genes.\n\n\nCode\npbmc &lt;- PercentageFeatureSet(pbmc, \n                             pattern = \"^MT-\", \n                             col.name = \"percent_MT\")\npbmc &lt;- pbmc[, pbmc$nFeature_RNA &gt;= 200 & pbmc$nFeature_RNA &lt;= 2500 & pbmc$percent_MT &lt;= 10]\n\n\nWe’ll process the raw counts in the usual fashion: QC, normalization, identification of highly variable genes (HVGs), linear & non-linear dimension reduction, and a broad clustering that will (hopefully) capture our major celltypes. When computing the shared nearest-neighbor (SNN) graph, we use the heuristic \\(k = \\sqrt{n}\\) for the number of nearest-neighbors to consider for each cell. This ensures that the clustering will be broad i.e., a smaller number of large clusters will be returned instead of a larger number of small clusters.\n\n\nCode\npbmc &lt;- NormalizeData(pbmc, \n                      normalization.method = \"LogNormalize\", \n                      verbose = FALSE) %&gt;% \n        FindVariableFeatures(selection.method = \"vst\", \n                             nfeatures = 3000, \n                             verbose = FALSE) %&gt;% \n        CellCycleScoring(s.features = cc.genes.updated.2019$s.genes, \n                         g2m.features = cc.genes.updated.2019$g2m.genes, \n                         set.ident = FALSE) %&gt;% \n        AddMetaData(metadata = c(.$S.Score - .$G2M.Score), col.name = \"CC_difference\") %&gt;% \n        ScaleData(vars.to.regress = \"CC_difference\", verbose = FALSE) %&gt;% \n        RunPCA(features = VariableFeatures(.), \n               npcs = 50, \n               verbose = FALSE, \n               seed.use = 312) %&gt;% \n        RunUMAP(reduction = \"pca\",\n                dims = 1:20, \n                n.components = 2, \n                metric = \"cosine\", \n                seed.use = 312, \n                verbose = FALSE) %&gt;% \n        FindNeighbors(reduction = \"pca\", \n                      dims = 1:20, \n                      k.param = sqrt(ncol(.)), \n                      nn.method = \"annoy\", \n                      annoy.metric = \"cosine\", \n                      verbose = FALSE) %&gt;% \n        FindClusters(resolution = 0.3, \n                     random.seed = 312, \n                     verbose = FALSE)\n\n\nLet’s visualize the principal components. Notable genes in PC 1 include MALAT1, high abundance of which is a common artifact of 10X-sequenced data. PC 2 seems to separate NK cells (NKG7, GZMB) and myeloid cells (HLA-DRA, CD79A). PC 3 is composed of variation that could originate from platelets (PPBP). PCs 4-6 look like they separate several types of monocytic, T, NK, and dendritic cells.\n\n\nCode\nDimHeatmap(pbmc, \n           reduction = \"pca\", \n           dims = 1:6, \n           nfeatures = 15, \n           combine = TRUE)\n\n\n\n\n\nWe visualize the Louvain clustering via a UMAP plot. We see 5 major clusters, which we’ll annotate next.\n\n\nCode\nDimPlot(pbmc, pt.size = 1) + \n  scale_color_paletteer_d(\"ggsci::nrc_npg\") + \n  labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank())"
  },
  {
    "objectID": "tutorials/SCISSORS_Reclustering.html#broad-annotations",
    "href": "tutorials/SCISSORS_Reclustering.html#broad-annotations",
    "title": "scRNA-seq Reclustering with {SCISSORS}",
    "section": "Broad Annotations",
    "text": "Broad Annotations\nFirst we identify CD8+ T-cells via CD8A, and CD4+ T-cells with IL7R. Lastly, FCGR3A (aka CD16) is specific to CD16+ monocytes. We can combine the plots using the {patchwork} package.\n\n\nCode\np1 &lt;- FeaturePlot(pbmc, features = \"CD8A\", pt.size = 1) + \n      scale_color_gradientn(colours = paletteer_d(\"wesanderson::Zissou1\")) + \n      labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n      theme(axis.ticks = element_blank(), \n            axis.text = element_blank())\np2 &lt;- FeaturePlot(pbmc, features = \"IL7R\", pt.size = 1) + \n      scale_color_gradientn(colours = paletteer_d(\"wesanderson::Zissou1\")) + \n      labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n      theme(axis.ticks = element_blank(), \n            axis.text = element_blank())\np1 / p2\n\n\n\n\n\nNext, we use HLA-DRA to broadly identify monocytic cells, and FCGR3A (aka CD16) to single out the CD16+ monocytes.\n\n\nCode\np1 &lt;- FeaturePlot(pbmc, features = \"HLA-DRA\", pt.size = 1) + \n      scale_color_gradientn(colours = paletteer_d(\"wesanderson::Zissou1\")) + \n      labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n      theme(axis.ticks = element_blank(), \n            axis.text = element_blank())\np2 &lt;- FeaturePlot(pbmc, features = \"FCGR3A\", pt.size = 1) + \n      scale_color_gradientn(colours = paletteer_d(\"wesanderson::Zissou1\")) + \n      labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n      theme(axis.ticks = element_blank(), \n            axis.text = element_blank())\np1 / p2\n\n\n\n\n\nLastly, abundance of MS4A1 points out a cluster of B cells.\n\n\nCode\nFeaturePlot(pbmc, features = \"MS4A1\", pt.size = 1) + \n  scale_color_gradientn(colours = paletteer_d(\"wesanderson::Zissou1\")) + \n  labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank())\n\n\n\n\n\nWe’ll add broad celltype labels to our object’s metadata.\n\n\nCode\npbmc@meta.data &lt;- mutate(pbmc@meta.data, \n                         broad_celltype = case_when(seurat_clusters == 0 ~ \"CD4+ T\", \n                                                    seurat_clusters == 1 ~ \"Monocyte\", \n                                                    seurat_clusters == 2 ~ \"CD8+ T\", \n                                                    seurat_clusters == 3 ~ \"B\", \n                                                    seurat_clusters == 4 ~ \"CD16+ Monocyte\", \n                                                    TRUE ~ NA_character_), \n                         broad_celltype = factor(broad_celltype, levels = c(\"CD4+ T\", \n                                                                            \"Monocyte\", \n                                                                            \"CD8+ T\", \n                                                                            \"B\", \n                                                                            \"CD16+ Monocyte\")))\n\n\nAnd visualize the results.\n\n\nCode\nDimPlot(pbmc, pt.size = 1, group.by = \"broad_celltype\") + \n  scale_color_paletteer_d(\"ggsci::nrc_npg\") + \n  labs(x = \"UMAP 1\", \n       y = \"UMAP 2\", \n       color = \"Broad Celltype\") + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank(), \n        plot.title = element_blank())"
  },
  {
    "objectID": "tutorials/SCISSORS_Reclustering.html#reclustering",
    "href": "tutorials/SCISSORS_Reclustering.html#reclustering",
    "title": "scRNA-seq Reclustering with {SCISSORS}",
    "section": "Reclustering",
    "text": "Reclustering\nFrom the plot above, there appears to be some visible subgroups in the monocyte cluster. With that being said - I would generally be very cautious about using UMAPs alone to define heterogeneous groups. In general, I would suggest using something like silhouette score distributions, other clustering statistics, or biological knowledge to determine subclustering targets. We can do this below using SCISSORS::ComputSilhouetteScores(), which returns a silhouette score for each individual cell. Visualizing the results can help us identify which clusters are “poor” fits. For more information, check out the Wikipedia article on clustering scores.\n\n\nCode\nsil_scores &lt;- ComputeSilhouetteScores(pbmc, avg = FALSE)\n\n\nWe can see that the B cell and CD16+ monocyte clusters seem to be well-fit, but the other clusters are less so. We’ll focus on the other monocyte cluster, as it seems to have the highest variance.\n\n\nCode\nsil_scores %&gt;% \n  left_join(distinct(pbmc@meta.data, seurat_clusters, broad_celltype), \n            by = c(\"Cluster\" = \"seurat_clusters\")) %&gt;% \n  ggplot(aes(x = broad_celltype, y = Score, fill = broad_celltype)) + \n  geom_violin(scale = \"width\", \n              color = \"black\", \n              draw_quantiles = 0.5, \n              size = 0.75) + \n  scale_fill_paletteer_d(\"ggsci::nrc_npg\") + \n  labs(y = \"Silhouette Score\", fill = \"Broad Celltype\") + \n  theme_classic(base_size = 14) + \n  theme(panel.grid.major.y = element_line(), \n        axis.title.x = element_blank())\n\n\n\n\n\n\nMonocytes\n\n\nCode\nmono_reclust &lt;- ReclusterCells(pbmc, \n                               which.clust = 1, \n                               use.parallel = FALSE, \n                               n.HVG = 3000,\n                               n.PC = 15, \n                               k.vals = c(20, 30, 40), \n                               resolution.vals = c(.2, .3, .4), \n                               random.seed = 312)\n\n\n[1] \"Reclustering cells in cluster 1 using k = 20 & resolution = 0.2; S = 0.419\"\n\n\nLet’s check out the UMAP embedding:\n\n\nCode\nDimPlot(mono_reclust) + \n  scale_color_paletteer_d(\"MetBrewer::Egypt\") + \n  labs(x = \"UMAP 1\", \n       y = \"UMAP 2\", \n       color = \"Subcluster\") + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank(), \n        plot.title = element_blank())\n\n\n\n\n\nHighly-specific abundance of FCER1A allows us to identify the dendritic cells in cluster 2.\n\n\nCode\ndata.frame(exp = mono_reclust@assays$RNA@data[\"FCER1A\", ], \n           label = mono_reclust$seurat_clusters) %&gt;% \n  ggplot(aes(x = label, y = exp, fill = label)) + \n  geom_violin(scale = \"width\",\n              color = \"black\", \n              draw_quantiles = 0.5, \n              size = 0.75) + \n  scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n  labs(y = \"FCER1A\", fill = \"Subcluster\") + \n  theme_classic(base_size = 14) + \n  theme(panel.grid.major.y = element_line(), \n        axis.title.x = element_blank())\n\n\n\n\n\nBoth cluster 0 & cluster 1 seem to be CD14+, and cluster 1 appears to have slightly higher (but still low) abundance of FCGR3A.\n\n\nCode\np1 &lt;- data.frame(exp = mono_reclust@assays$RNA@data[\"CD14\", ], \n                 label = mono_reclust$seurat_clusters) %&gt;% \n      filter(label %in% c(0, 1)) %&gt;% \n      ggplot(aes(x = label, y = exp, fill = label)) + \n      geom_violin(scale = \"width\",\n                  color = \"black\", \n                  draw_quantiles = 0.5, \n                  size = 0.75) + \n      scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n      labs(y = \"CD14\", fill = \"Subcluster\") + \n      theme_classic(base_size = 14) + \n      theme(panel.grid.major.y = element_line(), \n            axis.title.x = element_blank())\np2 &lt;- data.frame(exp = mono_reclust@assays$RNA@data[\"FCGR3A\", ], \n                 label = mono_reclust$seurat_clusters) %&gt;% \n      filter(label %in% c(0, 1)) %&gt;% \n      ggplot(aes(x = label, y = exp, fill = label)) + \n      geom_violin(scale = \"width\",\n                  color = \"black\", \n                  draw_quantiles = 0.5, \n                  size = 0.75) + \n      scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n      labs(y = \"FCGR3A\", fill = \"Subcluster\") + \n      theme_classic(base_size = 14) + \n      theme(panel.grid.major.y = element_line(), \n            axis.title.x = element_blank())\np1 / p2\n\n\n\n\n\nFrom Kapellos et al (2019), we know that intermediate monocytes have high abundance of CD14, low but non-zero abundance of CD16 (which again is denoted FCGR3A in this dataset), and can be identified through higher abundance of other markers like HLA-DPB1 and CD74 in comparison to CD14+ monocytes. With all this information, we’ll conclude that cluster 0 is likely composed of CD14+ monocytes and cluster 1 of intermediate monocytes.\n\n\nCode\np1 &lt;- data.frame(exp = mono_reclust@assays$RNA@data[\"HLA-DQB1\", ], \n                 label = mono_reclust$seurat_clusters) %&gt;% \n      filter(label %in% c(0, 1)) %&gt;% \n      ggplot(aes(x = label, y = exp, fill = label)) + \n      geom_violin(scale = \"width\",\n                  color = \"black\", \n                  draw_quantiles = 0.5, \n                  size = 0.75) + \n      scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n      labs(y = \"HLA-DQB1\", fill = \"Subcluster\") + \n      theme_classic(base_size = 14) + \n      theme(panel.grid.major.y = element_line(), \n            axis.title.x = element_blank())\np2 &lt;- data.frame(exp = mono_reclust@assays$RNA@data[\"CD74\", ], \n                 label = mono_reclust$seurat_clusters) %&gt;% \n      filter(label %in% c(0, 1)) %&gt;% \n      ggplot(aes(x = label, y = exp, fill = label)) + \n      geom_violin(scale = \"width\",\n                  color = \"black\", \n                  draw_quantiles = 0.5, \n                  size = 0.75) + \n      scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n      labs(y = \"CD74\", fill = \"Subcluster\") + \n      theme_classic(base_size = 14) + \n      theme(panel.grid.major.y = element_line(), \n            axis.title.x = element_blank())\np1 / p2\n\n\n\n\n\nLastly, we can tell that cluster 3 is composed of platelets thanks to high abundance of PPBP.\n\n\nCode\ndata.frame(exp = mono_reclust@assays$RNA@data[\"PPBP\", ], \n           label = mono_reclust$seurat_clusters) %&gt;% \n  ggplot(aes(x = label, y = exp, fill = label)) + \n  geom_violin(scale = \"width\",\n              color = \"black\", \n              draw_quantiles = 0.5, \n              size = 0.75) + \n  scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n  labs(y = \"PPBP\", fill = \"Subcluster\") + \n  theme_classic(base_size = 14) + \n  theme(panel.grid.major.y = element_line(), \n        axis.title.x = element_blank())\n\n\n\n\n\nWe can add the new subcluster labels back in to our original object using SCISSORS::IntegrateSubclusters(). We also add labels to the original object reflecting the subcluster annotations.\n\n\nCode\npbmc &lt;- IntegrateSubclusters(pbmc, reclust.results = mono_reclust)\npbmc@meta.data &lt;- mutate(pbmc@meta.data, \n                         celltype = case_when(seurat_clusters == 0 ~ \"CD4+ T\", \n                                              seurat_clusters == 1 ~ \"Platelet\", \n                                              seurat_clusters == 2 ~ \"CD8+ T\", \n                                              seurat_clusters == 3 ~ \"B\", \n                                              seurat_clusters == 4 ~ \"CD16+ Monocyte\", \n                                              seurat_clusters == 5 ~ \"CD14+ Monocyte\", \n                                              seurat_clusters == 6 ~ \"Intermediate Monocyte\", \n                                              seurat_clusters == 7 ~ \"Dendritic Cell\", \n                                              TRUE ~ NA_character_))\n\n\nHere’s the final celltype annotations on our original UMAP embedding.\n\n\nCode\nDimPlot(pbmc, group.by = \"celltype\", pt.size = 1) + \n  scale_color_paletteer_d(\"ggsci::default_nejm\") + \n  labs(x = \"UMAP 1\", \n       y = \"UMAP 2\", \n       color = \"Celltype\") + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank(), \n        plot.title = element_blank())"
  },
  {
    "objectID": "tutorials/Seurat_AnnData_Conversion.html",
    "href": "tutorials/Seurat_AnnData_Conversion.html",
    "title": "Converting scRNA-seq Datasets from Seurat to AnnData",
    "section": "",
    "text": "if you’re like me, you switch between using R & Python pretty frequently. Despite all the hype, single cell is still a relatively nascent field, and not every method is implemented in both languages. For example: if you want to run an RNA velocity analysis you’re probably going to need to use Python, but when it comes to making figures for your publication it’s generally easier to go back to R and use {ggplot2}. Whatever the motivation, it’s useful to be able to seamlessly switch between programming environments - though doing so isn’t always easy.\nThere are several libraries that facilitate conversions from R-based scRNA-seq data structures (typically SingleCellExperiment or Seurat objects) to Python-based ones (AnnData and loom being the most common formats). I’m aware of {zellkonverter}, {SeuratDisk}, {anndata2ri}, {loomR}, & {sceasy}. While these packages generally work fairly well, they don’t always transfer every piece of data that you need, and reading through the source code to try & figure out why your objects are incomplete can take up a lot of time. In addition, some of the more niche / less used dataset attributes are often undocumented or poorly-documented in conversion packages, making it difficult to identify how the data types correspond between formats. As such, sometimes it’s necessary to get through the conversion on your own. This vignette will hopefully make doing so a bit easier by detailing the equivalencies across packages between different types of counts matrices, metadata, graphs, & more. We’ll focus on converting directly from Seurat to AnnData, since converting between formats within the same language e.g., AnnData to loom or SingleCellExperiment to Seurat is generally easier & much better-documented."
  },
  {
    "objectID": "tutorials/Seurat_AnnData_Conversion.html#r",
    "href": "tutorials/Seurat_AnnData_Conversion.html#r",
    "title": "Converting scRNA-seq Datasets from Seurat to AnnData",
    "section": "R",
    "text": "R\n\n\nCode\nlibrary(dplyr)       # data manipulation\nlibrary(Seurat)      # scRNA-seq tools \nlibrary(ggplot2)     # plots\nlibrary(biomaRt)     # gene metadata \nlibrary(paletteer)   # color palettes\nlibrary(patchwork)   # plot alignment\nlibrary(reticulate)  # Python interface"
  },
  {
    "objectID": "tutorials/Seurat_AnnData_Conversion.html#python",
    "href": "tutorials/Seurat_AnnData_Conversion.html#python",
    "title": "Converting scRNA-seq Datasets from Seurat to AnnData",
    "section": "Python",
    "text": "Python\n\n\nCode\nimport numpy as np                   # linear algebra tools\nimport pandas as pd                  # data manipulation\nimport scanpy as sc                  # scRNA-seq tools\nimport scvelo as scv                 # RNA velocity models\nimport anndata as ad                 # scRNA-seq data structures\nfrom scipy.io import mmread          # read .mtx files\nimport matplotlib.pyplot as plt      # matplotlib\nfrom plotnine import theme_classic   # plot themes\nfrom scipy.sparse import csr_matrix  # sparse matrices\n\n\nWe tweak our matplotlib settings to match ggplot2::theme_classic(), which is my preferred theme.\n\n\nCode\ngg_theme = theme_classic()\nplt.rcParams.update(gg_theme.rcParams)\nplt.ion()"
  },
  {
    "objectID": "tutorials/Seurat_AnnData_Conversion.html#preprocessing-in-r",
    "href": "tutorials/Seurat_AnnData_Conversion.html#preprocessing-in-r",
    "title": "Converting scRNA-seq Datasets from Seurat to AnnData",
    "section": "Preprocessing in R",
    "text": "Preprocessing in R\nWe’ll start by running the data through a very typical preprocessing pipeline composed of QC, HVG selection, dimension reduction, Leiden graph-based clustering, & visualization. We’ll do a couple things that are non-standard though - first, we make sure to return the fitted UMAP model after running RunUMAP(), which will allow us to later recompute the set of nearest-neighbors that UMAP uses internally. Next, we identify nearest neighbors twice, once with return.neighbor toggled & once without it. The set of NNs identified each time is the same, but the first run returns the NN indices and inter-cell distances, while the second returns the shared nearest-neighbor graph that we use as input to the Leiden clustering algorithm in FindClusters().\n\n\nCode\nbrain &lt;- brain %&gt;% \n         PercentageFeatureSet(pattern = \"^RP[SL]\", col.name = \"percent_ribo\") %&gt;% \n         PercentageFeatureSet(pattern = \"^MT-\", col.name = \"percent_mito\") %&gt;% \n         CellCycleScoring(s.features = cc.genes.updated.2019$s.genes, \n                          g2m.features = cc.genes.updated.2019$g2m.genes, \n                          set.ident = FALSE) %&gt;% \n         AddMetaData(metadata = .$S.Score - .$G2M.Score, col.name = \"CC_difference\") %&gt;% \n         NormalizeData(verbose = FALSE) %&gt;% \n         ScaleData(verbose = FALSE) %&gt;% \n         FindVariableFeatures(nfeatures = 3000, verbose = FALSE) %&gt;% \n         RunPCA(features = VariableFeatures(.), \n                npcs = 30, \n                verbose = FALSE, \n                seed.use = 312, \n                approx = TRUE) %&gt;% \n         RunUMAP(reduction = \"pca\", \n                 dims = 1:30, \n                 return.model = TRUE, \n                 n.neighbors = 20, \n                 n.components = 2, \n                 metric = \"cosine\", \n                 n.epochs = 1000, \n                 seed.use = 312, \n                 verbose = FALSE) %&gt;% \n         FindNeighbors(reduction = \"pca\", \n                       dims = 1:30, \n                       k.param = 20, \n                       return.neighbor = TRUE, \n                       nn.method = \"annoy\", \n                       annoy.metric = \"cosine\", \n                       verbose = FALSE) %&gt;% \n         FindNeighbors(reduction = \"pca\", \n                       dims = 1:30, \n                       k.param = 20, \n                       compute.SNN = TRUE, \n                       nn.method = \"annoy\", \n                       annoy.metric = \"cosine\", \n                       verbose = FALSE) %&gt;% \n         FindClusters(resolution = 0.25, \n                      algorithm = 4, \n                      method = \"igraph\", \n                      random.seed = 312, \n                      verbose = FALSE)\n\n\nWe’ll also add & clean up the metadata by creating a cell age variable and sorting the fine celltype labels into slightly coarser categories for visualization. This data is mostly derived from Figure 1 and Supplementary Table 1 in the original paper.\n\n\nCode\nbrain@meta.data &lt;- mutate(brain@meta.data, \n                          age = case_when(Timepoint == \"week_6\" ~ 6,\n                                          Timepoint == \"week_7\" ~ 7,\n                                          Timepoint == \"week_8\" ~ 8,\n                                          Timepoint == \"week_9\" ~ 9,\n                                          Timepoint == \"week_10\" ~ 10,\n                                          Timepoint == \"week_11\" ~ 11,\n                                          TRUE ~ NA_real_), \n                          age = as.factor(age), \n                          broad_celltype = case_when(Cell_type %in% c(\"hOMTN\") ~ \"Oculomotor & Trochlear Nucleus\", \n                                                     Cell_type %in% c(\"hSert\") ~ \"Serotonergic\", \n                                                     Cell_type %in% c(\"hGaba\", \"hNbGaba\") ~ \"Gabaergic\", \n                                                     Cell_type %in% c(\"hDA0\", \"hDA1\", \"hDA2\") ~ \"Dopaminergic\", \n                                                     Cell_type %in% c(\"hRgl1\", \"hRgl2a\", \"hRgl2b\", \"hRgl2c\", \"hRgl3\") ~ \"Radial Glia\", \n                                                     Cell_type %in% c(\"hOPC\") ~ \"Oligodendrocyte Precursor\", \n                                                     Cell_type %in% c(\"hPeric\") ~ \"Pericyte\", \n                                                     Cell_type %in% c(\"hEndo\") ~ \"Endothelial\", \n                                                     Cell_type %in% c(\"hNProg\", \"hProgBP\", \"hProgFPL\", \"hProgFPM\", \"hProgM\") ~ \"Progenitor\", \n                                                     Cell_type %in% c(\"hRN\") ~ \"Red Nucleus\", \n                                                     Cell_type %in% c(\"hNbM\", \"hNbML1\", \"hNbML5\") ~ \"Neuroblast\", \n                                                     Cell_type %in% c(\"hMgl\") ~ \"Microglia\", \n                                                     Cell_type %in% c(\"Unk\") ~ \"Unknown\", \n                                                     TRUE ~ NA_character_), \n                          broad_celltype = as.factor(broad_celltype))\n\n\nLet’s visualize the results. First, we’ll define a color palette for each of our key metadata features using the {paletteer} package.\n\n\nCode\npalette_cluster &lt;- paletteer_d(\"ggsci::nrc_npg\")\npalette_celltype &lt;- paletteer_d(\"ggthemes::Tableau_20\")\npalette_age &lt;- paletteer_d(\"MetBrewer::Juarez\")\npalette_cc &lt;- paletteer_d(\"ggsci::default_locuszoom\")\n\n\nWe’ll also create a clean theme & legend settings for our dimension reduction plots.\n\n\nCode\ntheme_umap &lt;- function(base.size = 14) {\n  theme_classic(base_size = base.size) + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank(), \n        plot.subtitle = element_text(face = \"italic\"), \n        plot.caption = element_text(face = \"italic\"))\n}\nguide_umap &lt;- function(key.size = 4) {\n  guides(color = guide_legend(override.aes = list(size = key.size, alpha = 1)))\n}\n\n\nWe plot the unsupervised graph-based clustering, the true celltype labels, cell ages, & estimated cell cycle phase on our UMAP embedding.\n\n\nCode\np0 &lt;- DimPlot(brain, \n              group.by = \"seurat_clusters\", \n              cols = alpha(0.75, colour = palette_cluster), \n              shuffle = TRUE, \n              seed = 312, \n              pt.size = 1) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           title = \"Leiden Graph-based Clustering\", \n           subtitle = \"k = 20, r = 0.25\") + \n      theme_umap() + \n      guide_umap()\np1 &lt;- DimPlot(brain, \n              group.by = \"broad_celltype\", \n              cols = alpha(0.75, colour = palette_celltype), \n              shuffle = TRUE, \n              seed = 312, \n              pt.size = 1) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           title = \"Coarse Celltypes\", \n           subtitle = \"Derived from authors' original annotations\") + \n      theme_umap() + \n      guide_umap()\np2 &lt;- DimPlot(brain, \n              group.by = \"age\", \n              cols = alpha(0.75, colour = palette_age), \n              shuffle = TRUE, \n              seed = 312, \n              pt.size = 1) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           title = \"Cell Age\", \n           subtitle = \"Timepoints measured in weeks\") + \n      theme_umap() + \n      guide_umap()\np3 &lt;- DimPlot(brain, \n              group.by = \"Phase\", \n              cols = alpha(0.75, colour = palette_cc), \n              shuffle = TRUE, \n              seed = 312, \n              pt.size = 1) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           title = \"Cell Cycle Phase\", \n           subtitle = \"Estimated using genes from Tirosh et al (2016)\") + \n      theme_umap() + \n      guide_umap()\n(p0 | p1) / (p2 | p3)"
  },
  {
    "objectID": "tutorials/Seurat_AnnData_Conversion.html#conversion-to-anndata",
    "href": "tutorials/Seurat_AnnData_Conversion.html#conversion-to-anndata",
    "title": "Converting scRNA-seq Datasets from Seurat to AnnData",
    "section": "Conversion to AnnData",
    "text": "Conversion to AnnData\nHaving done all this preprocessing already, when using tools in Python we’d ideally like to be able to keep our clustering, annotations, embeddings, etc. as they are instead of recomputing them with scanpy. That isn’t a terrible worst option of course, but it’s pretty much impossible to get the results of stochastic algorithms such as Leiden clustering and UMAP, and even simpler ones like HVG identification to agree when using differing implementations of differing methods. With that in mind, let’s port our results to Python!\nNote: there’s essentially two ways to do this; the first relies on the usage of RMarkdown & {reticulate}, which allows you to pass objects back & forth between languages. The second, more general method is to write the data to common file formats from R, then read them in with Python & clean up the files afterwards. We’ll show examples of both options, but the best general-practice method is the file-based way. We’ll set up a temporary directory for the conversion files now, then remove it after we’re done.\n\n\nCode\nif (!dir.exists(\"./conversion_files/\")) {\n  dir.create(\"./conversion_files\")\n}\n\n\n\nRaw Counts\nFirst, we’ll write the counts matrices to a sparse matrix market file, which can be read into Python via scipy. Note: the AnnData ecosystem is built around \\(\\text{cell} \\times \\text{gene}\\) counts matrices, which is transposed from how R-based single cell data structures store them. Make sure to transpose them in either R or Python before creating an AnnData object.\n\n\nCode\nMatrix::writeMM(brain@assays$RNA@counts, file = \"./conversion_files/RNA_counts.mtx\")\n\n\n\n\nCell & Gene Metadata\nWe’ll use CSVs to store the metadata for our cells & genes; these can be read into Python using pandas. The {biomaRt} package allows us to pull an Ensembl ID & biotype for each gene in our dataset, which we save as well.\n\n\nCode\nreadr::write_csv(brain@meta.data,\n                 file = \"./conversion_files/cell_metadata.csv\",\n                 col_names = TRUE)\nreadr::write_csv(data.frame(cell = colnames(brain)), \n                 file = \"./conversion_files/cells.csv\", \n                 col_names = TRUE)\nreadr::write_csv(data.frame(gene = rownames(brain)), \n                 file = \"./conversion_files/genes.csv\", \n                 col_names = TRUE)\nmart &lt;- useDataset(\"hsapiens_gene_ensembl\", useMart(\"ensembl\"))\ngene_mapping_table &lt;- getBM(filters = \"hgnc_symbol\",\n                            attributes = c(\"hgnc_symbol\", \"ensembl_gene_id\", \"gene_biotype\"),\n                            values = rownames(brain),\n                            mart = mart, \n                            uniqueRows = TRUE)\ngene_mapping_table &lt;- data.frame(hgnc_symbol = rownames(brain)) %&gt;% \n                      left_join(gene_mapping_table, by = \"hgnc_symbol\") %&gt;% \n                      with_groups(hgnc_symbol, \n                                  mutate, \n                                  R = row_number()) %&gt;% \n                      filter(R == 1) %&gt;% \n                      dplyr::select(-R)\nreadr::write_csv(gene_mapping_table, \n                 file = \"./conversion_files/gene_mapping.csv\", \n                 col_names = TRUE)\n\n\n\n\nEmbeddings\nNext, we’ll create CSVs of our PCA & UMAP embeddings. Once we read these into Python they’ll need to be converted to numpy arrays.\n\n\nCode\nreadr::write_csv(as.data.frame(brain@reductions$pca@cell.embeddings),\n                 file = \"./conversion_files/PCA.csv\",\n                 col_names = TRUE)\nreadr::write_csv(as.data.frame(brain@reductions$umap@cell.embeddings),\n                 file = \"./conversion_files/UMAP.csv\",\n                 col_names = TRUE)\n\n\n\n\nGraph Structures\nLastly, we’ll save our nearest-neighbor graph data using a couple different formats - sparse matrices for the NN distance & UMAP connectivity graphs, and a CSV for the NN indices. First we need to actually create the NN distance graph though; in a Seurat object this graph is stored in an \\(n \\times k\\) matrix containing only the distances for each cell’s nearest neighbors, while in an AnnData object the matrix is expanded to also include a value of 0 for all non-neighbor cells i.e., a \\(n \\times n\\) sparse matrix. Luckily this is a fairly quick conversion to make: we simply record the row & column index for each cell’s nearest neighbors along with the accompanying cosine distance, then use that data to build a sparse matrix.\n\n\nCode\nknn_param &lt;- ncol(brain@neighbors$RNA.nn@nn.idx)\nrow_idx &lt;- col_idx &lt;- X &lt;- vector(\"numeric\", length = ncol(brain) * knn_param)\nfor (i in seq(ncol(brain))) {\n  row_idx[(knn_param * i - (knn_param - 1)):(knn_param * i)] &lt;- i\n  col_idx[(knn_param * i - (knn_param - 1)):(knn_param * i)] &lt;- brain@neighbors$RNA.nn@nn.idx[i, ]\n  X[(knn_param * i - (knn_param - 1)):(knn_param * i)] &lt;- brain@neighbors$RNA.nn@nn.dist[i, ]\n  \n}\nknn_dist_mat &lt;- Matrix::sparseMatrix(i = row_idx, j = col_idx, x = X)\n\n\nThe trickiest bit is the cell-level connectivities. This term is used pretty often in analyses done with scanpy and scvelo, but there isn’t really a direct equivalent in R. In short, scanpy (and the other packages built on top of it) uses part of the UMAP algorithm to both compute the nearest-neighbor graph & embed the cells in one step, rather than computing the neighbors separately from the UMAP embedding as is done in R. More technically, scanpy borrows the computation of the fuzzy simplicial set from UMAP, which is essentially a local approximation of the distances between points for a given distance metric (cosine, in our case). See here, specifically the section entitled “Adapting to Real World Data”, for many more details.\nSince the UMAP embeddings you get from {Seurat} & scanpy will differ somewhat because of differences in their underlying implementations, we’d like to be able to extract the connectivities from our pre-computed embedding and bring them in Python, instead of recomputing them with scanpy and thus having a set of neighbors that doesn’t exactly correspond to our UMAP. We can do this by refitting the UMAP model using the exact settings that we did when running it through the {Seurat} wrapper function, but this time we specify the parameter ret_extra = c(\"fgraph\"), which indicates that the fuzzy simplicial set matrix should be returned. Some of the parameters aren’t stored in the returned uwot model, so we need to set them manually. The only tricky one is the initialization; RunUMAP() uses the spectral (normalized Laplacian plus Gaussian noise) initialization as of the time of writing. Note: make sure to use the same random seed as you did when calling RunUMAP() originally.\n\n\nCode\nset.seed(312)\numap_reembed &lt;- uwot::umap(X = brain@reductions$pca@cell.embeddings, \n                           n_neighbors = brain@reductions$umap@misc$model$n_neighbors,\n                           n_components = 2,\n                           metric = \"cosine\", \n                           n_epochs = brain@reductions$umap@misc$model$n_epochs, \n                           init = \"spectral\", \n                           learning_rate = brain@reductions$umap@misc$model$alpha, \n                           min_dist = 0.1, \n                           local_connectivity = brain@reductions$umap@misc$model$local_connectivity, \n                           nn_method = \"annoy\", \n                           negative_sample_rate = brain@reductions$umap@misc$model$negative_sample_rate, \n                           ret_extra = c(\"fgraph\"),\n                           n_threads = 2,\n                           a = brain@reductions$umap@misc$model$a, \n                           b = brain@reductions$umap@misc$model$b, \n                           search_k = brain@reductions$umap@misc$model$search_k, \n                           approx_pow = brain@reductions$umap@misc$model$approx_pow, \n                           verbose = FALSE)\n\n\nNow that we’ve created our data, we write it to files.\n\n\nCode\nMatrix::writeMM(knn_dist_mat, file = \"./conversion_files/KNN_distances.mtx\")\nMatrix::writeMM(umap_reembed$fgraph, file = \"./conversion_files/UMAP_connectivity_matrix.mtx\")\nreadr::write_csv(as.data.frame(brain@neighbors$RNA.nn@nn.idx), \n                 file = \"./conversion_files/KNN_indices.csv\", \n                 col_names = TRUE)"
  },
  {
    "objectID": "tutorials/Seurat_AnnData_Conversion.html#downstream-analysis-in-python",
    "href": "tutorials/Seurat_AnnData_Conversion.html#downstream-analysis-in-python",
    "title": "Converting scRNA-seq Datasets from Seurat to AnnData",
    "section": "Downstream Analysis in Python",
    "text": "Downstream Analysis in Python\nWe read our data into Python, & do some necessary reformatting.\n\n\nCode\n# raw counts \nRNA_counts = mmread('./conversion_files/RNA_counts.mtx').transpose().tocsr().astype('float64')\n# cell metadata\ncell_metadata = pd.read_csv('./conversion_files/cell_metadata.csv').rename(columns={'Cell_ID': 'cell'}).set_index('cell', drop=False)\ncell_metadata['seurat_clusters'] = cell_metadata['seurat_clusters'].astype('category')\ncell_metadata['age'] = pd.Categorical(cell_metadata['age'].astype('str'), categories=['6', '7', '8', '9', '10', '11'])\ncat_cols = ['broad_celltype', 'Phase', 'Cell_type']\ncell_metadata[cat_cols] = cell_metadata[cat_cols].apply(lambda x: pd.Categorical(x, categories=list(dict.fromkeys(sorted(x, key=str.lower)))))\ncell_names = pd.read_csv('./conversion_files/cells.csv').set_index('cell', drop=False)\n# gene metadata\ngene_names = pd.read_csv('./conversion_files/genes.csv').set_index('gene', drop=False)\ngene_mapping_table = pd.read_csv('./conversion_files/gene_mapping.csv').set_index('hgnc_symbol', drop=False)\n# reduced dimensional embeddings\npca_embedding = pd.read_csv('./conversion_files/PCA.csv').set_index(pd.Index(cell_names['cell'])).to_numpy()\numap_embedding = pd.read_csv('./conversion_files/UMAP.csv').set_index(pd.Index(cell_names['cell'])).to_numpy()\n# KNN graphs\nknn_idx = pd.read_csv('./conversion_files/KNN_indices.csv').to_numpy().astype('int32') - 1\nknn_dist_mat = mmread('./conversion_files/KNN_distances.mtx').tocsr().astype('float64')\nknn_conn_mat = mmread('./conversion_files/UMAP_connectivity_matrix.mtx').tocsr().astype('float64')\n\n\nNow we can finally create our AnnData object. We make sure to store the unprocessed version of the data in the AnnData.raw slot.\n\n\nCode\nlayers_dict = {'RNA': RNA_counts}\ndimred_dict = {'X_pca': pca_embedding, 'X_umap': umap_embedding}\ngraph_dict = {'distances': knn_dist_mat, 'connectivities': knn_conn_mat}\nuns_dict = {\n    'broad_celltype_colors': np.array(r.palette_celltype[0:13]), \n    'seurat_clusters_colors': np.array(r.palette_cluster[0:7]), \n    'age_colors': np.array(r.palette_age[0:7]), \n    'Phase_colors': np.array(r.palette_cc[0:3]), \n    'neighbors': {\n        'connectivities_key': 'connectivities', \n        'distances_key': 'distances', \n        'indices': knn_idx, \n        'params': {\n            'n_neighbors': knn_idx.shape[1], \n            'method': 'Seurat::FindNeighbors()', \n            'metric': 'cosine', \n            'n_pcs': pca_embedding.shape[1], \n            'use_rep': 'X_pca'\n        } \n    }\n}\nadata = ad.AnnData(\n    X=layers_dict['RNA'], \n    obs=cell_metadata, \n    var=gene_mapping_table, \n    layers=layers_dict, \n    obsm=dimred_dict, \n    obsp=graph_dict, \n    uns=uns_dict\n)\nadata.raw = adata\nadata\n\n\nAnnData object with n_obs × n_vars = 1977 × 19527\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'cell', 'Cell_type', 'Timepoint', 'percent_ribo', 'percent_mito', 'S.Score', 'G2M.Score', 'Phase', 'CC_difference', 'RNA_snn_res.0.25', 'seurat_clusters', 'age', 'broad_celltype'\n    var: 'hgnc_symbol', 'ensembl_gene_id', 'gene_biotype'\n    uns: 'broad_celltype_colors', 'seurat_clusters_colors', 'age_colors', 'Phase_colors', 'neighbors'\n    obsm: 'X_pca', 'X_umap'\n    layers: 'RNA'\n    obsp: 'distances', 'connectivities'\n\n\nWhen plotting the UMAP embedding, we can see that the coordinates & colors have been preserved.\n\n\nCode\nax = sc.pl.scatter(\n  adata, \n  basis='umap',\n  color='broad_celltype', \n  title='', \n  frameon=True, \n  show=False, \n  legend_fontsize=10, \n  right_margin=0.7\n)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['bottom'].set_linewidth(1.5)\nax.spines['left'].set_linewidth(1.5)\nax.set_xlabel('UMAP 1')\nax.set_ylabel('UMAP 2')\nax.set_title(label='UMAP Embedding from Seurat', loc='left')\nplt.gcf().set_dpi(320)\nplt.show()\n\n\n\n\n\nNow we can proceed with a typical downstream analysis using the scanpy library. After processing the cells, we estimate a force-directed graph embedding and then a diffusion map embedding, which we’ll use to estimate pseudotime.\n\n\nCode\nsc.pp.filter_genes_dispersion(adata, flavor='seurat', n_top_genes=3000)\nsc.pp.normalize_per_cell(adata)\nsc.pp.log1p(adata)\nsc.pp.scale(adata)\nsc.tl.draw_graph(adata, layout='fr', random_state=312)\nsc.tl.diffmap(adata, random_state=312)\nax = sc.pl.scatter(\n  adata,\n  basis='diffmap',\n  color='broad_celltype', \n  title='', \n  frameon=True, \n  show=False, \n  legend_fontsize=10, \n  right_margin=0.7\n)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['bottom'].set_linewidth(1.5)\nax.spines['left'].set_linewidth(1.5)\nax.set_xlabel('DC 1')\nax.set_ylabel('DC 2')\nax.set_title(label='Diffusion Map Embedding of Fine Celltypes', loc='left')\nplt.gcf().set_dpi(320)\nplt.show()\n\n\n\n\n\nWe assign a root cell belonging to the progenitor population, then estimate diffusion pseudotime for each cell, and finally plot the results with our diffusion map embedding.\n\n\nCode\nadata.uns['iroot'] = np.flatnonzero(adata.obs['broad_celltype']  == 'Progenitor')[0]\nsc.tl.dpt(adata)\nax = sc.pl.scatter(\n  adata, \n  color='dpt_pseudotime', \n  basis='diffmap', \n  title='', \n  color_map='gnuplot', \n  legend_fontsize=10, \n  show=False\n)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['bottom'].set_linewidth(1.5)\nax.spines['left'].set_linewidth(1.5)\nax.set_xlabel('DC 1')\nax.set_ylabel('DC 2')\nax.set_title(label='Diffusion Pseudotime', loc='left')\nplt.gcf().set_dpi(320)\nplt.show()\n\n\n\n\n\nWhen plotting the distribution of diffusion pseudotime for each coarse celltype, we see that more immature celltypes such as progenitors have lower values, whereas more mature celltypes like endothelial cells & microglia have larger values. This indicates that our DPT estimate is a decent proxy for progression through the underlying biological process.\n\n\nCode\nviolin_order = pd.DataFrame(adata.obs[['broad_celltype', 'dpt_pseudotime']]) \\\n                 .groupby('broad_celltype')['dpt_pseudotime'] \\\n                 .mean().sort_values(ascending=True) \\\n                 .index.tolist()\nax = sc.pl.violin(\n  adata, \n  keys='dpt_pseudotime', \n  groupby='broad_celltype', \n  frameon=True, \n  order=violin_order, \n  show=False, \n  inner='box',\n  scale='width', \n  stripplot=False\n)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['bottom'].set_linewidth(1.5)\nax.spines['left'].set_linewidth(1.5)\nax.set_ylabel('Diffusion Pseudotime')\nax.set_xlabel(None)\nax.set_xticklabels(violin_order, rotation=40, ha='right')\nax.set_position([0.1, 0.375, 0.85, 0.575]) \nplt.gcf().set_dpi(320)\nplt.show()"
  },
  {
    "objectID": "tutorials/Seurat_AnnData_Conversion.html#file-cleanup",
    "href": "tutorials/Seurat_AnnData_Conversion.html#file-cleanup",
    "title": "Converting scRNA-seq Datasets from Seurat to AnnData",
    "section": "File Cleanup",
    "text": "File Cleanup\nLastly, we’ll remove the temporary directory we used to store our data while converting it all to AnnData. Note: always be super careful when using rm -rf!\n\n\nCode\nif (dir.exists(\"./conversion_files\")) {\n  system(\"rm -rf ./conversion_files\")\n}"
  },
  {
    "objectID": "tutorials/Seurat_AnnData_Conversion.html#returning-results-to-r",
    "href": "tutorials/Seurat_AnnData_Conversion.html#returning-results-to-r",
    "title": "Converting scRNA-seq Datasets from Seurat to AnnData",
    "section": "Returning Results to R",
    "text": "Returning Results to R\nWe’ll quickly pull the diffusion pseudotime estimate for each cell back into R using {reticulate}, and add it to our Seurat object. We also add the diffusion map embedding to the reductions slot in the object.\n\n\nCode\ndpt_est &lt;- py$adata$obs$dpt_pseudotime\nnames(dpt_est) &lt;- py$adata$obs$cell\nbrain &lt;- AddMetaData(brain, metadata = dpt_est, col.name = \"scanpy_dpt\")\ndiffmap_embed &lt;- py$adata$obsm[\"X_diffmap\"]\nrownames(diffmap_embed) &lt;- colnames(brain)\ncolnames(diffmap_embed) &lt;- paste0(\"DC_\", c(1:ncol(diffmap_embed)))\nbrain@reductions$diffmap &lt;- CreateDimReducObject(embeddings = diffmap_embed, \n                                                 assay = \"RNA\", \n                                                 key = \"DC_\", \n                                                 global = TRUE)\n\n\nWe can plot the DPT estimates on our UMAP embedding:\n\n\nCode\nFeaturePlot(brain, \n            features = \"scanpy_dpt\", \n            reduction = \"umap\", \n            pt.size = 1) + \n  scale_color_gradientn(colours = viridisLite::inferno(n = 20), \n                        labels = scales::label_number(accuracy = .1)) + \n  labs(x = \"UMAP 1\",\n       y = \"UMAP 2\",\n       title = \"Diffusion Pseudotime\", \n       subtitle = \"Estimated using Scanpy\") + \n  theme_umap()\n\n\n\n\n\nWe can also visualize gene dynamics over pseudotime for a few genes of interest. For example, we see that fibronectin 1 (FN1) is highly expressed towards the end of the biological process, specifically in pericyte & endothelial cells. These two celltypes form part of the blood-brain barrier, & are closely related to one another (source).\n\n\nCode\ndata.frame(cell = colnames(brain), \n           celltype = brain$broad_celltype, \n           dpt = brain$scanpy_dpt, \n           LGALS1 = GetAssayData(brain, \"data\")[\"LGALS1\", ], \n           COL4A1 = GetAssayData(brain, \"data\")[\"COL4A1\", ], \n           RGS5 = GetAssayData(brain, \"data\")[\"RGS5\", ], \n           FN1 = GetAssayData(brain, \"data\")[\"FN1\", ]) %&gt;% \n  tidyr::pivot_longer(cols = !c(cell, celltype, dpt), \n                      names_to = \"gene\", \n                      values_to = \"expression\") %&gt;% \n  ggplot(aes(x = dpt, y = expression)) + \n  facet_wrap(~gene, ncol = 2, nrow = 2) + \n  geom_point(aes(color = celltype), \n             size = 1, \n             alpha = 0.75) + \n  geom_smooth(method = \"gam\", \n              se = FALSE, \n              linewidth = 1.25, \n              color = \"black\") + \n  scale_x_continuous(labels = scales::label_number(accuracy = .1)) + \n  scale_y_continuous(limits = c(0, NA), labels = scales::label_number(accuracy = 1)) + \n  scale_color_manual(values = palette_celltype) + \n  labs(x = \"Diffusion Pseudotime\", \n       y = \"Expression\", \n       title = \"Pseudotemporal Gene Dynamics During Human Embryonic Neurogenisis\", \n       caption = \"Pseudotime estimated using Scanpy\") + \n  theme_classic(base_size = 14) + \n  theme(plot.caption = element_text(size = 11, face = \"italic\"), \n        legend.title = element_blank(), \n        strip.text.x = element_text(face = \"bold\")) + \n  guides(color = guide_legend(override.aes = list(alpha = 1, size = 4)))"
  },
  {
    "objectID": "tutorials/scLANE_Trajectory_DE.html",
    "href": "tutorials/scLANE_Trajectory_DE.html",
    "title": "Interpretable scRNA-seq Trajectory DE with {scLANE}",
    "section": "",
    "text": "In this tutorial we’ll walk through a basic trajectory differential expression analysis. We’ll use the {scLANE} package, which we developed with the goal of providing accurate and biologically interpretable models of expression over the course of a biological process. At the end are a list of references we used in developing the method & writing the accompanying manuscript, as well as the poster I presented at ENAR 2023 in Nashville."
  },
  {
    "objectID": "tutorials/scLANE_Trajectory_DE.html#pseudotime-estimation",
    "href": "tutorials/scLANE_Trajectory_DE.html#pseudotime-estimation",
    "title": "Interpretable scRNA-seq Trajectory DE with {scLANE}",
    "section": "Pseudotime Estimation",
    "text": "Pseudotime Estimation\nWe’ll start by fitting a trajectory using the {slingshot} R package. We define cluster 4 as the starting cluster, since in this case we’re already aware of the dataset’s underlying biology. After generating the estimates for each cell, we rescale the ordering to be defined on \\([0, 1]\\). This has no effect on the trajectory DE results however, and is mostly an aesthetic choice.\n\n\nCode\nsling_res &lt;- slingshot(Embeddings(seu, \"umap\"), \n                       clusterLabels = seu$seurat_clusters, \n                       start.clus = \"4\", \n                       approx_points = 1000)\nsling_pt &lt;- slingPseudotime(sling_res) %&gt;% \n            as.data.frame() %&gt;% \n            magrittr::set_colnames(c(\"PT\")) %&gt;% \n            mutate(PT = (PT - min(PT)) / (max(PT) - min(PT)))\nseu &lt;- AddMetaData(seu, \n                   metadata = sling_pt, \n                   col.name = \"sling_pt\")\n\n\nLet’s visualize the results on our UMAP embedding. They match what we would expect (knowing the biological background of the data), with ductal cells at the start of the process and endocrine celltypes such as alpha, beta, & delta cells at the end of it.\n\n\nCode\np3 &lt;- Embeddings(seu, \"umap\") %&gt;% \n      as.data.frame() %&gt;% \n      magrittr::set_colnames(c(\"UMAP_1\", \"UMAP_2\")) %&gt;% \n      mutate(PT = sling_pt$PT) %&gt;% \n      ggplot(aes(x = UMAP_1, y = UMAP_2, color = PT)) + \n      geom_point(size = 1, alpha = 0.75) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           color = \"Pseudotime\") + \n      scale_color_gradientn(colors = palette_heatmap, \n                            labels = scales::label_number(accuracy = 0.1)) + \n      theme_umap()\np4 &lt;- (p3 / p1) + \n      plot_annotation(title = \"Estimated Cell Ordering from Slingshot\", \n                      theme = theme_classic(base_size = 14))\np4"
  },
  {
    "objectID": "tutorials/scLANE_Trajectory_DE.html#trajectory-differential-expression",
    "href": "tutorials/scLANE_Trajectory_DE.html#trajectory-differential-expression",
    "title": "Interpretable scRNA-seq Trajectory DE with {scLANE}",
    "section": "Trajectory Differential Expression",
    "text": "Trajectory Differential Expression\nNext, we prepare the primary inputs to {scLANE}: a dense counts matrix (with cells as rows and genes as columns - this is important), a dataframe containing our estimated pseudotime ordering, and a character vector of the genes that we’re interested in modeling. We parallelize over genes in order to speed up the computation at the expense of using a little more memory. The models are fit using NB GLMs with optimal spline knots identified empirically, and differential expression is quantified using a likelihood ratio test of the fitted model vs. the null (intercept-only) model. In practice, genes designated as HVGs are usually the best candidates for modeling, so we choose the top 3,000 HVGs as our input. Note: the testing of the HVG set on its own is also justified by the reality that almost all trajectories are inferred using some sort of dimension-reduced space, and those embeddings are nearly universally generated using a set of HVGs. As such, genes not included in the HVG set actually have no direct relationship with the estimated trajectory, & it’s generally safe to exclude them from trajectory analyses.\n\n\nCode\ntop3k_hvg &lt;- HVFInfo(seu) %&gt;% \n             arrange(desc(variance.standardized)) %&gt;% \n             slice_head(n = 3000) %&gt;% \n             rownames(.)\nraw_counts &lt;- t(as.matrix(seu@assays$spliced@counts[top3k_hvg, ]))\nscLANE_res &lt;- testDynamic(expr.mat = raw_counts, \n                          pt = sling_pt, \n                          n.potential.basis.fns = 4, \n                          parallel.exec = TRUE, \n                          n.cores = 5, \n                          track.time = TRUE)\n\n\n[1] \"testDynamic evaluated 3000 genes with 1 lineage apiece in 12.507 mins\"\n\n\nWe pull a sample of 10 genes from the results (which we clean up using getResultsDE()) & display their test statistics. By default, any gene with an adjusted p-value less than 0.01 is predicted to be dynamic, though this threshold can be easily adjusted.\n\n\nCode\nscLANE_res_tidy &lt;- getResultsDE(test.dyn.results = scLANE_res)\nset.seed(629)\nselect(scLANE_res_tidy, \n       Gene, \n       Test_Stat, \n       P_Val, \n       P_Val_Adj,\n       Gene_Dynamic_Overall) %&gt;% \n  mutate(Gene_Dynamic_Overall = if_else(Gene_Dynamic_Overall == 1, \"Dynamic\", \"Static\")) %&gt;% \n  slice_sample(n = 10) %&gt;% \n  kableExtra::kbl(digits = 5, \n                  booktabs = TRUE, \n                  col.names = c(\"Gene\", \"LRT Statistic\", \"P-value\", \"Adj. P-value\", \"Predicted Gene Status\")) %&gt;% \n  kableExtra::kable_classic(full_width = FALSE, \"hover\")\n\n\n\n\n\nGene\nLRT Statistic\nP-value\nAdj. P-value\nPredicted Gene Status\n\n\n\n\nCdt1\n683.50332\n0.00000\n0.00000\nDynamic\n\n\nPlet1\n51.35960\n0.00000\n0.00000\nDynamic\n\n\nRnf130\n687.54249\n0.00000\n0.00000\nDynamic\n\n\nCib2\n325.64929\n0.00000\n0.00000\nDynamic\n\n\nGpx1\n1754.86938\n0.00000\n0.00000\nDynamic\n\n\nGm15440\n7.48582\n0.00622\n1.00000\nStatic\n\n\nSuclg2\n797.59131\n0.00000\n0.00000\nDynamic\n\n\nSox5\n239.85120\n0.00000\n0.00000\nDynamic\n\n\nCtsk\n14.86037\n0.00059\n0.23782\nStatic\n\n\nMpp2\n130.12658\n0.00000\n0.00000\nDynamic\n\n\n\n\n\n\n\nNext, we can use the plotModels() function to visualize the fitted models from {scLANE} and compare them to other modeling methods. The gene Neurog3 is strongly associated with epithelial cell differentiation, and indeed we see a very clear, nonlinear transcriptional dynamic across pseudotime for that gene. A traditional GLM fails to capture that nonlinearity, and a GAM over-smooths the trend and does not accurately model the sharpness of the transcriptional switch that occurs halfway through the trajectory. Only the scLANE model accurately models the rapid upregulation and equally swift downregulation of Neurog3 over pseudotime thanks to its adaptive choice of knots & piecewise linear nature.\n\n\nCode\np5 &lt;- plotModels(scLANE_res, \n                 gene = \"Neurog3\", \n                 pt = sling_pt, \n                 plot.null = FALSE, \n                 gene.counts = raw_counts) + \n        scale_color_manual(values = c(\"forestgreen\"))\np5\n\n\n\n\n\nWe can check out the actual regression output for our gene of interest as well. The estimated knot is placed at 0.4386.\n\n\nCode\nscLANE_res$Neurog3$Lineage_A$MARGE_Summary %&gt;% \n  mutate(term = gsub(\"B_final\", \"\", term), \n         term = if_else(term == \"Intercept\", term, paste0(\"h\", term))) %&gt;% \n  kableExtra::kbl(digits = 3, \n                  booktabs = TRUE, \n                  caption = \"scLANE Model Output for &lt;i&gt;Neurog3&lt;\\\\i&gt;\", \n                  col.names = c(\"Hinge Function\", \"Coefficient\", \"Std. Error\", \"T-statistic\", \"P-value\")) %&gt;% \n  kableExtra::kable_classic(full_width = FALSE, \"hover\")\n\n\n\nscLANE Model Output for Neurog3\n\n\nHinge Function\nCoefficient\nStd. Error\nT-statistic\nP-value\n\n\n\n\nIntercept\n3.359\n0.073\n46.046\n0\n\n\nh(Lineage_A-0.4386)\n-8.473\n0.221\n-38.422\n0\n\n\nh(0.4386-Lineage_A)\n-8.272\n0.291\n-28.418\n0\n\n\n\n\n\n\n\nUsing the getFittedValues() function allows us to generate predictions from the models we fit, which we then use to visualize the dynamics of a few genes that are known to be strongly associated with the differentiation of immature cells into mature endocrine phenotypes. For all four genes, the fitted models show knots chosen in the area of pseudotime around the pre-endocrine cells. This tells us that these driver genes are being upregulated in precursor celltypes & are driving differentiation into the mature celltypes such as alpha & beta cells, after which the genes are downregulated.\n\n\nCode\np6 &lt;- getFittedValues(test.dyn.res = scLANE_res, \n                      genes = c(\"Chga\", \"Chgb\", \"Fev\", \"Cck\"), \n                      pt = sling_pt, \n                      expr.mat = raw_counts, \n                      cell.meta.data = select(seu@meta.data, celltype, celltype_coarse)) %&gt;% \n      ggplot(aes(x = pt, y = expression)) + \n      facet_wrap(~gene, \n                 ncol = 2, \n                 scales = \"free_y\") + \n      geom_point(aes(color = celltype), size = 1, alpha = 0.75) + \n      geom_vline(data = data.frame(gene = \"Chga\", knot = unique(scLANE_res$Chga$Lineage_A$MARGE_Slope_Data$Breakpoint)), \n                 mapping = aes(xintercept = knot), \n                 linetype = \"dashed\", \n                 color = \"grey20\") + \n      geom_vline(data = data.frame(gene = \"Chgb\", knot = unique(scLANE_res$Chgb$Lineage_A$MARGE_Slope_Data$Breakpoint)), \n                 mapping = aes(xintercept = knot), \n                 linetype = \"dashed\", \n                 color = \"grey20\") + \n      geom_vline(data = data.frame(gene = \"Cck\", knot = unique(scLANE_res$Cck$Lineage_A$MARGE_Slope_Data$Breakpoint)), \n                 mapping = aes(xintercept = knot), \n                 linetype = \"dashed\", \n                 color = \"grey20\") + \n      geom_vline(data = data.frame(gene = \"Fev\", knot = unique(scLANE_res$Fev$Lineage_A$MARGE_Slope_Data$Breakpoint)), \n                 mapping = aes(xintercept = knot), \n                 linetype = \"dashed\", \n                 color = \"grey20\") + \n      geom_ribbon(aes(ymin = scLANE_ci_ll, ymax = scLANE_ci_ul), \n                  size = 0, \n                  fill = \"grey\", \n                  alpha = 1) + \n      geom_line(aes(y = scLANE_fitted), \n                color = \"black\", \n                size = 0.75) + \n      scale_x_continuous(labels = scales::label_number(accuracy = 0.1)) + \n      scale_color_manual(values = palette_celltype) + \n      labs(x = \"Pseudotime\", \n           y = \"Expression\", \n           title = \"Endrocrinogenesis Driver Genes Across Pseudotime\", \n           subtitle = \"scLANE piecewise negative binomial GLMs\") + \n      theme_classic(base_size = 14) + \n      theme(legend.title = element_blank(), \n            strip.text.x = element_text(face = \"bold\"), \n            plot.subtitle = element_text(face = \"italic\", size = 11)) + \n      guide_umap()\np6\n\n\n\n\n\nOn the other hand, if we use additive models the “peak” of expression is placed among the mature endocrine celltypes - which doesn’t make biological sense if we know that these genes are driving that process of differentiation. This can of course be tweaked by changing the degree or degrees of freedom of the underlying basis spline, but choosing a “best” value for those hyperparameters can be difficult, whereas scLANE identifies optimal parameters internally by default.\n\n\nCode\np7 &lt;- getFittedValues(test.dyn.res = scLANE_res, \n                      genes = c(\"Chga\", \"Chgb\", \"Fev\", \"Cck\"), \n                      pt = sling_pt, \n                      expr.mat = raw_counts, \n                      cell.meta.data = select(seu@meta.data, celltype, celltype_coarse)) %&gt;% \n        with_groups(gene, \n                    mutate, \n                    GAM_fitted_link = predict(gamlss::gamlss(expression ~ splines::bs(pt, degree = 3), \n                                                             family = \"NBI\", \n                                                             control = gamlss::gamlss.control(trace = FALSE))), \n                    GAM_se_link = predict(gamlss::gamlss(expression ~ splines::bs(pt, degree = 3), \n                                                         family = \"NBI\", \n                                                         control = gamlss::gamlss.control(trace = FALSE)), \n                                          se.fit = TRUE)[[2]]) %&gt;% \n        mutate(GAM_fitted = exp(GAM_fitted_link), \n               GAM_ci_ll = exp(GAM_fitted_link - qnorm(0.975, lower.tail = FALSE) * GAM_se_link), \n               GAM_ci_ul = exp(GAM_fitted_link + qnorm(0.975, lower.tail = FALSE) * GAM_se_link)) %&gt;% \n        ggplot(aes(x = pt, y = expression)) + \n        facet_wrap(~gene, \n                   ncol = 2, \n                   scales = \"free_y\") + \n        geom_point(aes(color = celltype), size = 1, alpha = 0.75) + \n        geom_ribbon(aes(ymin = GAM_ci_ll, ymax = GAM_ci_ul), \n                    size = 0, \n                    fill = \"grey\", \n                    alpha = 1) + \n        geom_line(aes(y = GAM_fitted), \n                  color = \"black\", \n                  size = 0.75) + \n        scale_x_continuous(labels = scales::label_number(accuracy = 0.1)) + \n        scale_color_manual(values = palette_celltype) + \n        labs(x = \"Pseudotime\", \n             y = \"Expression\", \n             title = \"Endrocrinogenesis Driver Genes Across Pseudotime\", \n             subtitle = \"Cubic basis spline negative binomial GAMs\") + \n        theme_classic(base_size = 14) + \n        theme(legend.title = element_blank(), \n              strip.text.x = element_text(face = \"bold\"), \n              plot.subtitle = element_text(face = \"italic\", size = 11)) + \n        guide_umap()\np7\n\n\n\n\n\nLet’s take a broader view of the dataset by examining the distribution of adaptively chosen knots from our models. We limit the analysis to the set of genes determined to be dynamic.\n\n\nCode\ndyn_genes &lt;- filter(scLANE_res_tidy, Gene_Dynamic_Overall == 1) %&gt;% \n             pull(Gene)\nknot_df &lt;- purrr::imap(scLANE_res[dyn_genes], \n                       \\(x, y) {\n                         data.frame(\n                           gene = y, \n                           knot = x$Lineage_A$MARGE_Slope_Data$Breakpoint\n                         )\n                       }) %&gt;% \n           purrr::reduce(rbind)\n\n\nWe’ll plot a histogram of the knot values along with a ridgeplot of the pseudotime distribution for each celltype. We see that the majority of the selected knots are placed at the beginning of the trajectory, around where the ductal cells transition into endocrine progenitors. A smaller set of knots is placed about halfway through the trajectory, which we’ve annotated as the point at which pre-endocrine cells begin differentiating into mature endocrine phenotypes.\n\n\nCode\np8 &lt;- ggplot(knot_df, aes(x = knot)) + \n      geom_density(fill = \"deepskyblue3\", \n                   alpha = 0.75, \n                   color = \"deepskyblue4\", \n                   size = 1) + \n      scale_x_continuous(limits = c(0, 1), labels = scales::label_number(accuracy = 0.1)) + \n      labs(x = \"Knot Location\") + \n      theme_classic(base_size = 14) + \n      theme(axis.title.y = element_blank(), \n            axis.text.y = element_blank(), \n            axis.ticks.y = element_blank())\np9 &lt;- data.frame(celltype = seu$celltype, \n                 pt = seu$sling_pt) %&gt;% \n      ggplot(aes(x = pt, y = celltype, fill = celltype, color = celltype)) + \n      ggridges::geom_density_ridges(alpha = 0.75, size = 1) + \n      scale_x_continuous(labels = scales::label_number(accuracy = 0.1)) + \n      scale_fill_manual(values = palette_celltype) + \n      scale_color_manual(values = palette_celltype) + \n      labs(x = \"Pseudotime\") + \n      theme_classic(base_size = 14) + \n      theme(axis.title.y = element_blank(), \n            legend.title = element_blank()) + \n      guide_umap()\np10 &lt;- (p8 / p9) + \n       plot_layout(heights = c(1, 1.75)) + \n       plot_annotation(title = \"Distribution of Adaptively-chosen Knots from scLANE\", \n                       theme = theme_classic(base_size = 14))\np10\n\n\nPicking joint bandwidth of 0.0184\n\n\n\n\n\nWe can extract a matrix of fitted values using smoothedCountsMatrix(); here we focus on the top 1,000 most dynamic genes, with the goal of identifying clusters of similarly-expressed genes. After reducing dimensionality with PCA, we cluster the genes using the Leiden algorithm & embed the genes in two dimensions with UMAP.\n\n\nCode\nsmoothed_counts &lt;- smoothedCountsMatrix(scLANE_res, \n                                        genes = dyn_genes[1:2000], \n                                        parallel.exec = TRUE, \n                                        n.cores = 2)\nset.seed(312)\nsmoothed_counts_pca &lt;- irlba::prcomp_irlba(t(smoothed_counts$Lineage_A), \n                                           n = 30, \n                                           center = TRUE, \n                                           scale. = TRUE)\nsmoothed_counts_umap &lt;- uwot::umap(smoothed_counts_pca$x, \n                                   n_components = 2, \n                                   metric = \"cosine\", \n                                   n_neighbors = 20, \n                                   init = \"spectral\")\nsmoothed_counts_snn &lt;- bluster::makeSNNGraph(smoothed_counts_pca$x, \n                                             k = 20, \n                                             type = \"jaccard\", \n                                             BNPARAM = BiocNeighbors::AnnoyParam(distance = \"Cosine\"))\nsmoothed_counts_clust &lt;- igraph::cluster_leiden(smoothed_counts_snn, \n                                                objective_function = \"modularity\", \n                                                resolution_parameter = 0.3)\ngene_clust_df &lt;- data.frame(gene = colnames(smoothed_counts$Lineage_A), \n                            umap1 = smoothed_counts_umap[, 1], \n                            umap2 = smoothed_counts_umap[, 2], \n                            leiden = as.factor(smoothed_counts_clust$membership - 1L))\n\n\nThe embedding & clustering show that even with the relatively small number of genes, clear patterns are visible.\n\n\nCode\np11 &lt;- ggplot(gene_clust_df, aes(x = umap1, y = umap2, color = leiden)) + \n       geom_point(size = 1, alpha = 0.75) + \n       labs(x = \"UMAP 1\", \n            y = \"UMAP 2\", \n            color = \"Leiden Cluster\", \n            title = \"Unsupervised Clustering of Dynamic Genes\", \n            subtitle = \"Top 2,000 genes after PCA\") +\n       paletteer::scale_color_paletteer_d(\"ggsci::default_igv\") + \n       theme_umap() + \n       guide_umap()\np11\n\n\n\n\n\nWe can also plot a heatmap of the dynamic genes; this requires a bit of setup, for which we’ll use the {ComplexHeatmap} package. We scale each gene, and clip values to be on \\([-6, 6]\\). The columns of the heatmap are ordered by estimated pseudotime.\n\n\nCode\ncol_anno_df &lt;- select(seu@meta.data, \n                      cell_name, \n                      celltype, \n                      sling_pt) %&gt;% \n               mutate(celltype = as.factor(celltype)) %&gt;% \n               arrange(sling_pt)\nheatmap_mat &lt;- t(scale(smoothed_counts$Lineage_A))\nheatmap_mat[heatmap_mat &gt; 6] &lt;- 6\nheatmap_mat[heatmap_mat &lt; -6] &lt;- -6\ncolnames(heatmap_mat) &lt;- seu$cell_name\nheatmap_mat &lt;- heatmap_mat[, col_anno_df$cell_name]\npalette_celltype_hm &lt;- as.character(palette_celltype[1:length(unique(seu$celltype))])\nnames(palette_celltype_hm) &lt;- levels(col_anno_df$celltype)\ncol_anno &lt;- HeatmapAnnotation(Celltype = col_anno_df$celltype, \n                              Pseudotime = col_anno_df$sling_pt, \n                              col = list(Celltype = palette_celltype_hm, \n                                         Pseudotime = circlize::colorRamp2(seq(0, 1, by = 0.25), palette_heatmap)),\n                              show_legend = TRUE, \n                              show_annotation_name = FALSE, \n                              gap = unit(1, \"mm\"), \n                              border = TRUE)\npalette_cluster_hm &lt;- as.character(paletteer::paletteer_d(\"ggsci::default_igv\")[1:length(unique(gene_clust_df$leiden))])\nnames(palette_cluster_hm) &lt;- as.character(unique(gene_clust_df$leiden))\nrow_anno &lt;- HeatmapAnnotation(Cluster = as.factor(gene_clust_df$leiden), \n                              col = list(Cluster = palette_cluster_hm), \n                              show_legend = TRUE, \n                              show_annotation_name = FALSE, \n                              annotation_legend_param = list(title = \"Gene\\nCluster\"), \n                              gap = unit(1, \"mm\"), \n                              border = TRUE, \n                              which = \"row\")\n\n\nThe heatmap shows clear dynamic patterns across pseudotime, and the hierarchical clustering agrees fairly well with our graph-based clustering from earlier.\n\n\nCode\nHeatmap(matrix = heatmap_mat, \n        name = \"Spliced\\nmRNA\", \n        col = circlize::colorRamp2(colors = viridis::inferno(50), \n                                   breaks = seq(min(heatmap_mat), max(heatmap_mat), length.out = 50)), \n        cluster_columns = FALSE,\n        show_column_dend = FALSE,\n        cluster_column_slices = FALSE,\n        width = 12, \n        height = 6, \n        column_title = \"Dynamic Genes Across Pseudotime in Murine Pancreatic Endocrinogenesis\",\n        column_title_gp = gpar(fontface = \"bold\"), \n        show_row_dend = TRUE,\n        top_annotation = col_anno, \n        left_annotation = row_anno, \n        show_column_names = FALSE, \n        show_row_names = FALSE, \n        use_raster = TRUE,\n        raster_by_magick = TRUE, \n        raster_quality = 5)\n\n\nLoading required namespace: magick\n\n\n\n\n\nUsing our gene clusters & the {gprofiler2} package, we run an enrichment analysis against the biological process (BP) set of gene ontologies.\n\n\nCode\ngene_clust_list &lt;- purrr::map(unique(gene_clust_df$leiden), \\(x) filter(gene_clust_df, leiden == x) %&gt;% pull(gene)) \nnames(gene_clust_list) &lt;- paste0(\"Leiden_\", unique(gene_clust_df$leiden))\nenrich_res &lt;- gprofiler2::gost(gene_clust_list, \n                               organism = \"mmusculus\", \n                               ordered_query = FALSE, \n                               multi_query = FALSE, \n                               sources = \"GO:BP\", \n                               significant = TRUE)\n\n\nA look at the top 3 most-significant GO terms for each gene cluster reveals heterogeneous functionalities across groups of genes:\n\n\nCode\nmutate(enrich_res$result, \n       query = gsub(\"Leiden_\", \"\", query)) %&gt;% \n  rename(cluster = query) %&gt;% \n  with_groups(cluster, \n              slice_head,\n              n = 3) %&gt;% \n  select(cluster, term_name, p_value, term_size, query_size, intersection_size, term_id) %&gt;% \n  kableExtra::kbl(digits = 5, \n                  booktabs = TRUE, \n                  caption = \"&lt;i&gt;Top 3 Biological Process GO Terms per Cluster&lt;\\\\i&gt;\", \n                  col.names = c(\"Gene Cluster\", \"Term Name\", \"Adj. P-value\", \"Term Size\", \n                                \"Query Size\", \"Intersection Size\", \"Term ID\")) %&gt;% \n  kableExtra::kable_classic(c(\"hover\"), full_width = FALSE)\n\n\n\nTop 3 Biological Process GO Terms per Cluster\n\n\nGene Cluster\nTerm Name\nAdj. P-value\nTerm Size\nQuery Size\nIntersection Size\nTerm ID\n\n\n\n\n0\nnervous system development\n0.00000\n2555\n271\n80\nGO:0007399\n\n\n0\nregulation of secretion by cell\n0.00000\n673\n271\n41\nGO:1903530\n\n\n0\namide transport\n0.00000\n423\n271\n33\nGO:0042886\n\n\n1\nregulation of apoptotic process\n0.00000\n1633\n252\n58\nGO:0042981\n\n\n1\nregulation of programmed cell death\n0.00000\n1665\n252\n58\nGO:0043067\n\n\n1\nregulation of cell death\n0.00000\n1836\n252\n61\nGO:0010941\n\n\n2\ncell-cell signaling\n0.00000\n1748\n308\n64\nGO:0007267\n\n\n2\nregulation of biological quality\n0.00000\n3244\n308\n91\nGO:0065008\n\n\n2\nsecretion\n0.00000\n1084\n308\n48\nGO:0046903\n\n\n3\ncell cycle\n0.00000\n1817\n285\n174\nGO:0007049\n\n\n3\ncell cycle process\n0.00000\n1242\n285\n152\nGO:0022402\n\n\n3\nmitotic cell cycle\n0.00000\n881\n285\n121\nGO:0000278\n\n\n4\nanimal organ development\n0.00000\n3326\n307\n106\nGO:0048513\n\n\n4\nsystem development\n0.00000\n4115\n307\n119\nGO:0048731\n\n\n4\ndevelopmental process\n0.00000\n6865\n307\n158\nGO:0032502\n\n\n5\nmulticellular organism development\n0.00002\n4873\n145\n55\nGO:0007275\n\n\n5\nsystem development\n0.00003\n4115\n145\n49\nGO:0048731\n\n\n5\nanatomical structure development\n0.00014\n6228\n145\n62\nGO:0048856\n\n\n6\nanatomical structure development\n0.00000\n6228\n238\n111\nGO:0048856\n\n\n6\nmulticellular organism development\n0.00000\n4873\n238\n95\nGO:0007275\n\n\n6\ntube development\n0.00000\n1173\n238\n43\nGO:0035295"
  }
]