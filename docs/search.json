[
  {
    "objectID": "derivations/Intercept_Interpretation.html",
    "href": "derivations/Intercept_Interpretation.html",
    "title": "IN PROGRESS - Interpreting Intercepts in Linear Regression",
    "section": "",
    "text": "One concept I struggled with a lot in early statistics courses was what the intercept meant in linear regression models. I tended to just ignore it unless questions specifically pertained to it, and the vast majority of homework questions focused on interpreting the effects of covariates instead. I saw many of my master’s-level students struggle with in the SAS computing course I taught during Fall 2022 as well, with confusion about the effect of centering, the difference between centering and standardizing, and intercept interpretation in mixed models being common pain points on homeworks. As such, I thought it might be useful - for myself and others - to jot down some notes on how the intercept is estimated and what it means under a variety of regression modelling frameworks."
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#multiplication",
    "href": "derivations/Intercept_Interpretation.html#multiplication",
    "title": "IN PROGRESS - Interpreting Intercepts in Linear Regression",
    "section": "Multiplication",
    "text": "Multiplication\n\nTheory\nFirst define two matrices \\(\\mathbf{A}\\) and \\(\\mathbf{B}\\), each with 2 rows and 2 columns:\n$$\n\\[\\begin{aligned}\n\n\\mathbf{A} &=\n  \\begin{bmatrix}\n    a_{11} & a_{21} \\\\\n    a_{12} & a_{22} \\\\\n  \\end{bmatrix} \\\\\n  \n& \\\\\n  \n\\mathbf{B} &=\n  \\begin{bmatrix}\n    b_{11} & b_{21} \\\\\n    b_{12} & b_{22} \\\\\n  \\end{bmatrix}\n\n\\end{aligned}\\]\n$$\nTheir product, another matrix \\(C\\), also has 2 rows and 2 columns, and its elements are defined like so, with \\(i\\) specifying the row and \\(j\\) the column of each element. What we’re doing is finding the dot product of the \\(i^{\\text{th}}\\) row of \\(\\mathbf{A}\\) and the \\(i^{\\text{th}}\\) column of \\(\\mathbf{B}\\), the expanded definition of which is below.\n$$\n\\[\\begin{aligned}\n\nc_{i,j} &= \\mathbf{A}_{i*} \\cdot \\mathbf{B}_{*j} \\\\\nc_{i,j} &= \\sum_{k=1}^n a_{ik}b_{kj} \\\\\nc_{i,j} &= a_{i1}b_{1j} + \\dots + a_{n1}b_{nj} \\\\\n\n\\end{aligned}\\]\n$$\nAs such, we can define the product of \\(\\mathbf{A}\\) and \\(\\mathbf{B}\\) like so:\n$$\n\\[\\begin{aligned}\n\n\\mathbf{C} &=  \\mathbf{A} \\mathbf{B} \\\\\n\n& \\\\\n\n\\mathbf{C} &=\n  \\begin{bmatrix}\n    \\mathbf{A}_{1*} \\cdot \\mathbf{B}_{*1} & \\mathbf{A}_{2*} \\cdot \\mathbf{B}_{*1} \\\\\n    \\mathbf{A}_{2*} \\cdot \\mathbf{B}_{*1} & \\mathbf{A}_{2*} \\cdot \\mathbf{B}_{*2} \\\\\n  \\end{bmatrix} \\\\\n\n& \\\\\n\n\\mathbf{C} &=\n  \\begin{bmatrix}\n    a_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\\\\n    a_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22} \\\\\n  \\end{bmatrix} \\\\\n\n\\end{aligned}\\]\n$$\nImportant Note: To multiply two matrices \\(\\mathbf{A}\\) and \\(\\mathbf{B}\\) together, the number of rows of \\(\\mathbf{B}\\) must be equal to the number of columns in \\(\\mathbf{A}\\). To generalize:\n\\[\n\\mathbf{A}_{mn} \\cdot \\mathbf{B}_{np} = \\mathbf{C}_{mp}\n\\]\n\n\nExample\nLet’s define two matrices:\n$$\n\\[\\begin{aligned}\n\n\\mathbf{A} &=\n  \\begin{bmatrix}\n    3 & 2 \\\\\n    0 & 7 \\\\\n  \\end{bmatrix} \\\\\n  \n& \\\\\n  \n\\mathbf{B} &=\n  \\begin{bmatrix}\n    1 & 4 \\\\\n    1 & 2 \\\\\n  \\end{bmatrix}\n\n\\end{aligned}\\]\n$$\nTheir product \\(\\mathbf{C}\\) is defined as:\n$$\n\\[\\begin{aligned}\n\n\\mathbf{C} &=\n  \\begin{bmatrix}\n    3 \\times 1 + 2 \\times 1 & 3 \\times 4 + 2 \\times 2 \\\\\n    0 \\times 1 + 7 \\times 1 & 0 \\times 4 + 7 \\times 2 \\\\\n  \\end{bmatrix} \\\\\n\n& \\\\\n\n\\mathbf{C} &=\n  \\begin{bmatrix}\n    5 & 16 \\\\\n    7 & 14 \\\\\n  \\end{bmatrix} \\\\\n\n\\end{aligned}\\]\n$$\nWe can check this using R:\n\n\nCode\nA_mat <- matrix(c(3, 2, 0, 7), \n                nrow = 2, \n                ncol = 2, \n                byrow = TRUE)\nB_mat <- matrix(c(1, 4, 1, 2), \n                nrow = 2, \n                ncol = 2, \n                byrow = TRUE)\nC_mat <- A_mat %*% B_mat\nC_mat\n\n\n     [,1] [,2]\n[1,]    5   16\n[2,]    7   14"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#transposition",
    "href": "derivations/Intercept_Interpretation.html#transposition",
    "title": "IN PROGRESS - Interpreting Intercepts in Linear Regression",
    "section": "Transposition",
    "text": "Transposition\n\nTheory\n\n\nExample"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#inversion",
    "href": "derivations/Intercept_Interpretation.html#inversion",
    "title": "IN PROGRESS - Interpreting Intercepts in Linear Regression",
    "section": "Inversion",
    "text": "Inversion\n\nTheory\n\n\nExample"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#the-identity-matrix",
    "href": "derivations/Intercept_Interpretation.html#the-identity-matrix",
    "title": "IN PROGRESS - Interpreting Intercepts in Linear Regression",
    "section": "The Identity Matrix",
    "text": "The Identity Matrix\n\nTheory\nThe identity matrix \\(\\mathbf{I}_{n}\\) is a square matrix composed entirely of zeroes except along the diagonal, which is composed of ones. This matrix carries some unique properties (which are listed below) that will be helpful to us later on.\n$$\n\\[\\begin{aligned}\n\n\\mathbf{I}_{n} &=\n  \\begin{bmatrix}\n    1 & 0 & \\cdots & 0 \\\\\n    0 & 1 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\ddots & 0 \\\\\n    0 & 0 & 0 & 1 \\\\\n  \\end{bmatrix}\n  \n& \\\\\n\n\\mathbf{I}_{n}^\\prime &= \\mathbf{I}_{n} \\\\\n\n& \\\\\n\n\\mathbf{I}_{n}^{-1} &= \\mathbf{I}_{n} \\\\\n\n\\end{aligned}\\]\n$$\n\n\nExample\nWe can set up a \\(3 \\times 3\\) identity matrix \\(\\mathbf{I}_{3}\\) in R using the diag() function:\n\n\nCode\nident_mat <- diag(nrow = 3)\nident_mat\n\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\nThe transpose is also equal to \\(\\mathbf{I}_{3}\\):\n\n\nCode\nt(ident_mat)\n\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\nAs is the inverse:\n\n\nCode\nsolve(ident_mat)\n\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#setup",
    "href": "derivations/Intercept_Interpretation.html#setup",
    "title": "IN PROGRESS - Interpreting Intercepts in Linear Regression",
    "section": "Setup",
    "text": "Setup\nFor now, we’ll take it for granted that the solution to a linear regression problem is defined as follows:\n\\[\n\\widehat{\\boldsymbol{\\beta}} = \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime \\mathbf{y}\n\\]"
  },
  {
    "objectID": "derivations/Intercept_Interpretation.html#the-intercept-only-model",
    "href": "derivations/Intercept_Interpretation.html#the-intercept-only-model",
    "title": "IN PROGRESS - Interpreting Intercepts in Linear Regression",
    "section": "The Intercept-only Model",
    "text": "The Intercept-only Model\nThe intercept-only model (also sometimes called the null model) is defined as linear regression when \\(\\mathbf{X}\\) is simply a column vector of ones:\n\\[\n\\mathbf{X} =\n  \\begin{bmatrix}\n    1 \\\\\n    \\vdots \\\\\n    1 \\\\\n  \\end{bmatrix}\n\\]\nWe know the intercept-only model produces the mean as the one predicted value, as the mean minimizes the sum of squared errors in the absence of any other covariates. We can check this using R - we’ll first generate a vector \\(\\mathbf{y}\\) consisting of 5 realizations of a random variable, such that \\(\\mathbf{Y} \\sim \\mathcal{N}(\\mu = 0, \\sigma^2 = 3)\\).\n\n\nCode\ny <- rnorm(5, mean = 0, sd = 3)\ny <- matrix(y, ncol = 1)\ny\n\n\n           [,1]\n[1,]  0.7142100\n[2,] -0.4898113\n[3,]  2.6509190\n[4,]  0.1575862\n[5,]  1.9798764\n\n\nThe mean of \\(\\mathbf{y}\\) is:\n\n\nCode\nmean(y)\n\n\n[1] 1.002556\n\n\nWe can use R to fit an intercept-only model. We can see that the intercept coefficient \\(\\beta_0\\) is equal to the mean of \\(\\mathbf{y}\\).\n\n\nCode\nnull_mod <- lm(y ~ 1)\ncoef(null_mod)\n\n\n(Intercept) \n   1.002556 \n\n\nLastly, let’s use linear algebra to figure out why this is true. Once again, we know that the linear regression closed-form solution is given by the following:\n\\[\n\\widehat{\\boldsymbol{\\beta}} = \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime \\mathbf{y}\n\\]\nLet’s first define \\(\\mathbf{X}\\):\n\n\nCode\nX <- c(1, 1, 1, 1, 1)\nX <- matrix(X, ncol = 1)\nX\n\n\n     [,1]\n[1,]    1\n[2,]    1\n[3,]    1\n[4,]    1\n[5,]    1\n\n\nThe value of \\(\\mathbf{X}^\\prime \\mathbf{X}\\) is given by the following - note that this is equal to our sample size \\(n = 5\\).\n\n\nCode\nt(X) %*% X\n\n\n     [,1]\n[1,]    5\n\n\nThe inverse of which, \\(\\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1}\\), is of course \\(n^{-1}\\):\n\n\nCode\nsolve(t(X) %*% X)\n\n\n     [,1]\n[1,]  0.2\n\n\nWe multiply the above by \\(\\mathbf{X}^\\prime\\) again to obtain \\(\\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime\\), which gives us a constant vector of length \\(n\\) with all values being equal to \\(n^{-1}\\):\n\n\nCode\nsolve(t(X) %*% X) %*% t(X)\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]  0.2  0.2  0.2  0.2  0.2\n\n\nLastly, we multiply the above by \\(\\mathbf{y}\\). Remember how multiplying vectors works - in this case we are multiplying each element of the above vector \\(\\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime\\) with each element of \\(\\mathbf{y}\\) and adding them together. We’ll define \\(\\mathbf{Z} = \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime\\) for convenience of notation:\n\\[\n\\mathbf{Z} \\mathbf{y} = \\sum_{i=1}^n \\mathbf{Z}_i \\mathbf{y}_i\n\\]\nSince each element of \\(\\mathbf{Z}\\) is the same, \\(n^{-1}\\), the above quantity is equivalent to:\n\\[\n\\begin{aligned}\n  \\mathbf{Z} \\mathbf{y} &= \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime \\mathbf{y} \\\\\n  \\mathbf{Z} \\mathbf{y} &= \\sum_{i=1}^n \\mathbf{Z}_i \\mathbf{y}_i \\\\\n  \\mathbf{Z} \\mathbf{y} &= n^{-1} \\sum_{i=1}^n \\mathbf{y}_i \\\\\n\\end{aligned}\n\\]\nThis is simply the sum of all the element of \\(\\mathbf{y}\\) divided by \\(n\\) - the mean! We can verify this with R by using linear algebra to compute the OLS solution:\n\n\nCode\nsolve(t(X) %*% X) %*% t(X) %*% y\n\n\n         [,1]\n[1,] 1.002556\n\n\nThis is equal to simply taking the mean of \\(\\mathbf{y}\\):\n\n\nCode\nmean(y)\n\n\n[1] 1.002556"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "I am a first-year PhD student at the University of Florida under Dr. Rhonda Bacher. My primary research interest is single cell RNA-seq computational method development, specifically with respect to clustering, trajectory inference, and differential expression. I’m passionate about scientific reproducibility, computational scalability, and interpretable inference."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\nUniversity of Florida | PhD Biostatistics\nAug 2022 - Current\nUniversity of Florida | MS Biostatistics\nAug 2020 - May 2022\nUniversity of North Carolina | BS Statistics\nAug 2016 - May 2020"
  },
  {
    "objectID": "index.html#work-experience",
    "href": "index.html#work-experience",
    "title": "About",
    "section": "Work Experience",
    "text": "Work Experience\nUniversity of Florida | Graduate Research & Teaching Assistant\nMay 2021 - present\nBlue Cross Blue Shield of Florida | Data Analyst\nJuly 2020 - July 2022\nUniversity of North Carolina | Undergraduate Research Assistant\nJune 2019 - July 2020"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Background",
    "section": "",
    "text": "My undergrad degree is in statistics, which I did at the University of North Carolina at Chapel Hill (Go Heels!). After graduating in 2020, I spent some of the next two years earning a master’s degree in biostatistics from the University of Florida. During my second year in that program, I applied to PhD programs and ended up deciding to continue at UF and do a PhD in the same department. I’m currently entering the second semester of my first year. My most relevant studies include courses on generalized linear models, statistical learning theory, convex optimization, probability theory, mathematical statistics, and statistical computing at the undergraduate and graduate levels."
  },
  {
    "objectID": "about.html#work-experience",
    "href": "about.html#work-experience",
    "title": "Background",
    "section": "Work Experience",
    "text": "Work Experience\nIn the summer after my junior year at UNC, I joined Dr. Jen Jen Yeh’s lab at Lineberger Comprehensive Cancer Center. There I learned how to process and analyze genomic and transcriptomic data, and in Fall 2019 started focusing on developing methods for scRNA-seq analysis. My primary contribution there was the development of reproducible bioinformatics pipelines for bulk & single cell RNA-seq, ChIP-seq, and whole genome & exome sample processing. In addition, I developed a robust, evidence-based downstream analysis workflow for the lab’s scRNA-seq samples.\nAfter leaving the Yeh Lab in July 2020, I moved to Jacksonville and started working full-time as a junior data analyst at Blue Cross Blue Shield of Florida. While there, I completed a year-long rotational program during which I applied regression and clustering methods to several complex business problems. A highlight was my usage of graph-based clustering and dimension reduction algorithms (concepts lifted directly from my experience with scRNA-seq data) to identify well-performing subsets of specialist doctors. After my rotations ended, I became a full analyst and spent the next year working in care analytics, where I tested and deployed machine learning algorithms used to identify people to be targeted for various preventive healthcare programs. During this time, I also completed a manuscript started while I was at the Yeh Lab detailing a method for improved clustering of single cell data containing rare cell types.\nWhile all this was going on, I also started doing research work (once again focused on scRNA-seq method development) in Dr. Rhonda Bacher’s group at UF. Our original focus was in profiling, testing, and improving existing methods for RNA velocity and trajectory inference through simulations and analysis of publicly available single cell datasets.\nAfter two years at Blue Cross, and graduating with my master’s in May of 2022, I decided to join Dr. Bacher as a PhD student in Fall 2022. My first semester was spent pursuing scRNA-seq research, with a focus on improving the interpretability of trajectory differential expression methods. I also provided downstream analysis of single cell data generated by Dr. Phillip Efron’s lab containing different types of peripheral blood mononuclear cells. In addition, I was the instructor for the online section of PHC 6790 (Biostatistical Computing with SAS), a master’s-level course developed by fellow Tar Heel Dr. John Kairalla."
  },
  {
    "objectID": "about.html#personal-interests",
    "href": "about.html#personal-interests",
    "title": "Background",
    "section": "Personal Interests",
    "text": "Personal Interests\nOutside of research, I enjoy reading (my favorite genres are nautical adventure, weird history, and narrative science), riding my bike, cooking for my friends, and rock climbing."
  },
  {
    "objectID": "about.html#publications",
    "href": "about.html#publications",
    "title": "Background",
    "section": "Publications",
    "text": "Publications\n\nJack R. Leary, Yi Xu, Ashley Morrison, Chong Jin, Emily C. Shen, Ye Su, Naim U. Rashid, Jen Jen Yeh, Xianlu Laura Peng. Sub-cluster identification through semi-supervised optimization of rare-cell silhouettes (SCISSORS) in single-cell sequencing. BioRxiv. 466448, (2021).\nMatthew E. Berginski, Madison R. Jenner, Chinmaya U. Joisa, Silvia G.Herrera Loeza, Brian T. Golitz, Matthew B. Lipner, Jack R. Leary, Naim U. Rashid, Gary L. Johnson, Jen Jen Yeh, Shawn M. Gomez. Kinome state is predictive of cell viability in pancreatic cancer tumor and stroma cell lines. BioRxiv. 451515, (2021)."
  },
  {
    "objectID": "tutorials/SCISSORS_Reclustering.html",
    "href": "tutorials/SCISSORS_Reclustering.html",
    "title": "scRNA-seq Reclustering with SCISSORS",
    "section": "",
    "text": "In this tutorial we’ll walk through a basic single cell analysis, with a focus on fine-tuning clustering results using the {SCISSORS} package, which I wrote during my time at UNC Chapel Hill."
  },
  {
    "objectID": "tutorials/SCISSORS_Reclustering.html#preprocessing",
    "href": "tutorials/SCISSORS_Reclustering.html#preprocessing",
    "title": "scRNA-seq Reclustering with SCISSORS",
    "section": "Preprocessing",
    "text": "Preprocessing\nWe’ll do some minor quality-control checking first by filtering out cells with a high percentage of mitochondrial reads or very low or high numbers of detected genes.\n\n\nCode\npbmc <- PercentageFeatureSet(pbmc, \n                             pattern = \"^MT-\", \n                             col.name = \"percent_MT\")\npbmc <- pbmc[, pbmc$nFeature_RNA >= 200 & pbmc$nFeature_RNA <= 2500 & pbmc$percent_MT <= 10]\n\n\nWe’ll process the raw counts in the usual fashion: QC, normalization, identification of highly variable genes (HVGs), linear & non-linear dimension reduction, and a broad clustering that will (hopefully) capture our major celltypes. When computing the shared nearest-neighbor (SNN) graph, we use the heuristic \\(k = \\sqrt{n}\\) for the number of nearest-neighbors to consider for each cell. This ensures that the clustering will be broad i.e., a smaller number of large clusters will be returned instead of a larger number of small clusters.\n\n\nCode\npbmc <- NormalizeData(pbmc, \n                      normalization.method = \"LogNormalize\", \n                      verbose = FALSE) %>% \n        FindVariableFeatures(selection.method = \"vst\", \n                             nfeatures = 3000, \n                             verbose = FALSE) %>% \n        CellCycleScoring(s.features = cc.genes.updated.2019$s.genes, \n                         g2m.features = cc.genes.updated.2019$g2m.genes, \n                         set.ident = FALSE) %>% \n        AddMetaData(metadata = c(.$S.Score - .$G2M.Score), col.name = \"CC_difference\") %>% \n        ScaleData(vars.to.regress = \"CC_difference\", verbose = FALSE) %>% \n        RunPCA(features = VariableFeatures(.), \n               npcs = 50, \n               verbose = FALSE, \n               seed.use = 312) %>% \n        RunUMAP(reduction = \"pca\",\n                dims = 1:20, \n                n.components = 2, \n                metric = \"cosine\", \n                seed.use = 312, \n                verbose = FALSE) %>% \n        FindNeighbors(reduction = \"pca\", \n                      dims = 1:20, \n                      k.param = sqrt(ncol(.)), \n                      nn.method = \"annoy\", \n                      annoy.metric = \"cosine\", \n                      verbose = FALSE) %>% \n        FindClusters(resolution = 0.3, \n                     random.seed = 312, \n                     verbose = FALSE)\n\n\nLet’s visualize the principal components. Notable genes in PC 1 include MALAT1, high abundance of which is a common artifact of 10X-sequenced data. PC 2 seems to separate NK cells (NKG7, GZMB) and myeloid cells (HLA-DRA, CD79A). PC 3 is composed of variation that could originate from platelets (PPBP). PCs 4-6 look like they separate several types of monocytic, T, NK, and dendritic cells.\n\n\nCode\nDimHeatmap(pbmc, \n           reduction = \"pca\", \n           dims = 1:6, \n           nfeatures = 15, \n           combine = TRUE)\n\n\n\n\n\nWe visualize the Louvain clustering via a UMAP plot. We see 5 major clusters, which we’ll annotate next.\n\n\nCode\nDimPlot(pbmc, pt.size = 1) + \n  scale_color_paletteer_d(\"ggsci::nrc_npg\") + \n  labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank())"
  },
  {
    "objectID": "tutorials/SCISSORS_Reclustering.html#broad-annotations",
    "href": "tutorials/SCISSORS_Reclustering.html#broad-annotations",
    "title": "scRNA-seq Reclustering with SCISSORS",
    "section": "Broad Annotations",
    "text": "Broad Annotations\nFirst we identify CD8+ T-cells via CD8A, and CD4+ T-cells with IL7R. Lastly, FCGR3A (aka CD16) is specific to CD16+ monocytes. We can combine the plots using the {patchwork} package.\n\n\nCode\np1 <- FeaturePlot(pbmc, features = \"CD8A\", pt.size = 1) + \n      scale_color_gradientn(colours = paletteer_d(\"wesanderson::Zissou1\")) + \n      labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n      theme(axis.ticks = element_blank(), \n            axis.text = element_blank())\np2 <- FeaturePlot(pbmc, features = \"IL7R\", pt.size = 1) + \n      scale_color_gradientn(colours = paletteer_d(\"wesanderson::Zissou1\")) + \n      labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n      theme(axis.ticks = element_blank(), \n            axis.text = element_blank())\np1 / p2\n\n\n\n\n\nNext, we use HLA-DRA to broadly identify monocytic cells, and FCGR3A (aka CD16) to single out the CD16+ monocytes.\n\n\nCode\np1 <- FeaturePlot(pbmc, features = \"HLA-DRA\", pt.size = 1) + \n      scale_color_gradientn(colours = paletteer_d(\"wesanderson::Zissou1\")) + \n      labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n      theme(axis.ticks = element_blank(), \n            axis.text = element_blank())\np2 <- FeaturePlot(pbmc, features = \"FCGR3A\", pt.size = 1) + \n      scale_color_gradientn(colours = paletteer_d(\"wesanderson::Zissou1\")) + \n      labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n      theme(axis.ticks = element_blank(), \n            axis.text = element_blank())\np1 / p2\n\n\n\n\n\nLastly, abundance of MS4A1 points out a cluster of B cells.\n\n\nCode\nFeaturePlot(pbmc, features = \"MS4A1\", pt.size = 1) + \n  scale_color_gradientn(colours = paletteer_d(\"wesanderson::Zissou1\")) + \n  labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank())\n\n\n\n\n\nWe’ll add broad celltype labels to our object’s metadata.\n\n\nCode\npbmc@meta.data <- mutate(pbmc@meta.data, \n                         broad_celltype = case_when(seurat_clusters == 0 ~ \"CD4+ T\", \n                                                    seurat_clusters == 1 ~ \"Monocyte\", \n                                                    seurat_clusters == 2 ~ \"CD8+ T\", \n                                                    seurat_clusters == 3 ~ \"B\", \n                                                    seurat_clusters == 4 ~ \"CD16+ Monocyte\", \n                                                    TRUE ~ NA_character_), \n                         broad_celltype = factor(broad_celltype, levels = c(\"CD4+ T\", \n                                                                            \"Monocyte\", \n                                                                            \"CD8+ T\", \n                                                                            \"B\", \n                                                                            \"CD16+ Monocyte\")))\n\n\nAnd visualize the results.\n\n\nCode\nDimPlot(pbmc, pt.size = 1, group.by = \"broad_celltype\") + \n  scale_color_paletteer_d(\"ggsci::nrc_npg\") + \n  labs(x = \"UMAP 1\", \n       y = \"UMAP 2\", \n       color = \"Broad Celltype\") + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank(), \n        plot.title = element_blank())"
  },
  {
    "objectID": "tutorials/SCISSORS_Reclustering.html#reclustering",
    "href": "tutorials/SCISSORS_Reclustering.html#reclustering",
    "title": "scRNA-seq Reclustering with SCISSORS",
    "section": "Reclustering",
    "text": "Reclustering\nFrom the plot above, there appears to be some visible subgroups in the monocyte cluster. With that being said - I would generally be very cautious about using UMAPs alone to define heterogeneous groups. In general, I would suggest using something like silhouette score distributions, other clustering statistics, or biological knowledge to determine subclustering targets. We can do this below using SCISSORS::ComputSilhouetteScores(), which returns a silhouette score for each individual cell. Visualizing the results can help us identify which clusters are “poor” fits. For more information, check out the Wikipedia article on clustering scores.\n\n\nCode\nsil_scores <- ComputeSilhouetteScores(pbmc, avg = FALSE)\n\n\nWe can see that the B cell and CD16+ monocyte clusters seem to be well-fit, but the other clusters are less so. We’ll focus on the other monocyte cluster, as it seems to have the highest variance.\n\n\nCode\nsil_scores %>% \n  left_join(distinct(pbmc@meta.data, seurat_clusters, broad_celltype), \n            by = c(\"Cluster\" = \"seurat_clusters\")) %>% \n  ggplot(aes(x = broad_celltype, y = Score, fill = broad_celltype)) + \n  geom_violin(scale = \"width\", \n              color = \"black\", \n              draw_quantiles = 0.5, \n              size = 0.75) + \n  scale_fill_paletteer_d(\"ggsci::nrc_npg\") + \n  labs(y = \"Silhouette Score\", fill = \"Broad Celltype\") + \n  theme_classic(base_size = 14) + \n  theme(panel.grid.major.y = element_line(), \n        axis.title.x = element_blank())\n\n\n\n\n\n\nMonocytes\n\n\nCode\nmono_reclust <- ReclusterCells(pbmc, \n                               which.clust = 1, \n                               use.parallel = FALSE, \n                               n.HVG = 3000,\n                               n.PC = 15, \n                               k.vals = c(20, 30, 40), \n                               resolution.vals = c(.2, .3, .4), \n                               random.seed = 312)\n\n\n[1] \"Reclustering cells in cluster 1 using k = 20 & resolution = 0.2; S = 0.419\"\n\n\nLet’s check out the UMAP embedding:\n\n\nCode\nDimPlot(mono_reclust) + \n  scale_color_paletteer_d(\"MetBrewer::Egypt\") + \n  labs(x = \"UMAP 1\", \n       y = \"UMAP 2\", \n       color = \"Subcluster\") + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank(), \n        plot.title = element_blank())\n\n\n\n\n\nHighly-specific abundance of FCER1A allows us to identify the dendritic cells in cluster 2.\n\n\nCode\ndata.frame(exp = mono_reclust@assays$RNA@data[\"FCER1A\", ], \n           label = mono_reclust$seurat_clusters) %>% \n  ggplot(aes(x = label, y = exp, fill = label)) + \n  geom_violin(scale = \"width\",\n              color = \"black\", \n              draw_quantiles = 0.5, \n              size = 0.75) + \n  scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n  labs(y = \"FCER1A\", fill = \"Subcluster\") + \n  theme_classic(base_size = 14) + \n  theme(panel.grid.major.y = element_line(), \n        axis.title.x = element_blank())\n\n\n\n\n\nBoth cluster 0 & cluster 1 seem to be CD14+, and cluster 1 appears to have slightly higher (but still low) abundance of FCGR3A.\n\n\nCode\np1 <- data.frame(exp = mono_reclust@assays$RNA@data[\"CD14\", ], \n                 label = mono_reclust$seurat_clusters) %>% \n      filter(label %in% c(0, 1)) %>% \n      ggplot(aes(x = label, y = exp, fill = label)) + \n      geom_violin(scale = \"width\",\n                  color = \"black\", \n                  draw_quantiles = 0.5, \n                  size = 0.75) + \n      scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n      labs(y = \"CD14\", fill = \"Subcluster\") + \n      theme_classic(base_size = 14) + \n      theme(panel.grid.major.y = element_line(), \n            axis.title.x = element_blank())\np2 <- data.frame(exp = mono_reclust@assays$RNA@data[\"FCGR3A\", ], \n                 label = mono_reclust$seurat_clusters) %>% \n      filter(label %in% c(0, 1)) %>% \n      ggplot(aes(x = label, y = exp, fill = label)) + \n      geom_violin(scale = \"width\",\n                  color = \"black\", \n                  draw_quantiles = 0.5, \n                  size = 0.75) + \n      scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n      labs(y = \"FCGR3A\", fill = \"Subcluster\") + \n      theme_classic(base_size = 14) + \n      theme(panel.grid.major.y = element_line(), \n            axis.title.x = element_blank())\np1 / p2\n\n\n\n\n\nFrom Kapellos et al (2019), we know that intermediate monocytes have high abundance of CD14, low but non-zero abundance of CD16 (which again is denoted FCGR3A in this dataset), and can be identified through higher abundance of other markers like HLA-DPB1 and CD74 in comparison to CD14+ monocytes. With all this information, we’ll conclude that cluster 0 is likely composed of CD14+ monocytes and cluster 1 of intermediate monocytes.\n\n\nCode\np1 <- data.frame(exp = mono_reclust@assays$RNA@data[\"HLA-DQB1\", ], \n                 label = mono_reclust$seurat_clusters) %>% \n      filter(label %in% c(0, 1)) %>% \n      ggplot(aes(x = label, y = exp, fill = label)) + \n      geom_violin(scale = \"width\",\n                  color = \"black\", \n                  draw_quantiles = 0.5, \n                  size = 0.75) + \n      scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n      labs(y = \"HLA-DQB1\", fill = \"Subcluster\") + \n      theme_classic(base_size = 14) + \n      theme(panel.grid.major.y = element_line(), \n            axis.title.x = element_blank())\np2 <- data.frame(exp = mono_reclust@assays$RNA@data[\"CD74\", ], \n                 label = mono_reclust$seurat_clusters) %>% \n      filter(label %in% c(0, 1)) %>% \n      ggplot(aes(x = label, y = exp, fill = label)) + \n      geom_violin(scale = \"width\",\n                  color = \"black\", \n                  draw_quantiles = 0.5, \n                  size = 0.75) + \n      scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n      labs(y = \"CD74\", fill = \"Subcluster\") + \n      theme_classic(base_size = 14) + \n      theme(panel.grid.major.y = element_line(), \n            axis.title.x = element_blank())\np1 / p2\n\n\n\n\n\nLastly, we can tell that cluster 3 is composed of platelets thanks to high abundance of PPBP.\n\n\nCode\ndata.frame(exp = mono_reclust@assays$RNA@data[\"PPBP\", ], \n           label = mono_reclust$seurat_clusters) %>% \n  ggplot(aes(x = label, y = exp, fill = label)) + \n  geom_violin(scale = \"width\",\n              color = \"black\", \n              draw_quantiles = 0.5, \n              size = 0.75) + \n  scale_fill_paletteer_d(\"MetBrewer::Egypt\") + \n  labs(y = \"PPBP\", fill = \"Subcluster\") + \n  theme_classic(base_size = 14) + \n  theme(panel.grid.major.y = element_line(), \n        axis.title.x = element_blank())\n\n\n\n\n\nWe can add the new subcluster labels back in to our original object using SCISSORS::IntegrateSubclusters(). We also add labels to the original object reflecting the subcluster annotations.\n\n\nCode\npbmc <- IntegrateSubclusters(pbmc, reclust.results = mono_reclust)\npbmc@meta.data <- mutate(pbmc@meta.data, \n                         celltype = case_when(seurat_clusters == 0 ~ \"CD4+ T\", \n                                              seurat_clusters == 1 ~ \"Platelet\", \n                                              seurat_clusters == 2 ~ \"CD8+ T\", \n                                              seurat_clusters == 3 ~ \"B\", \n                                              seurat_clusters == 4 ~ \"CD16+ Monocyte\", \n                                              seurat_clusters == 5 ~ \"CD14+ Monocyte\", \n                                              seurat_clusters == 6 ~ \"Intermediate Monocyte\", \n                                              seurat_clusters == 7 ~ \"Dendritic Cell\", \n                                              TRUE ~ NA_character_))\n\n\nHere’s the final celltype annotations on our original UMAP embedding.\n\n\nCode\nDimPlot(pbmc, group.by = \"celltype\", pt.size = 1) + \n  scale_color_paletteer_d(\"ggsci::default_nejm\") + \n  labs(x = \"UMAP 1\", \n       y = \"UMAP 2\", \n       color = \"Celltype\") + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank(), \n        plot.title = element_blank())"
  }
]