{
  "hash": "fe0b820567e8a1aea8573ba34c79901f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Building a Trajectory Regulatory Network with scRNA-seq Data\"\nauthor:\n  name: Jack Leary\n  email: j.leary@ufl.edu\n  orcid: 0009-0004-8821-3269\n  affiliations:\n    - name: University of Florida\n      department: Biostatistics \n      city: Gainesville\n      state: FL\ndate: today\ndate-format: long\nformat:\n  html:\n    code-fold: show\n    code-copy: true\n    code-tools: true\n    toc: true\n    toc-depth: 2\n    embed-resources: true\n    fig-format: retina\n    fig-width: 9\n    fig-height: 6\n    df-print: kable\n    link-external-newwindow: true\n    tbl-cap-location: bottom\n    number-sections: true\nexecute:\n  cache: false\n  freeze: auto\n---\n\n\n\n\n# Introduction {#sec-intro}\n\nIn this analysis we'll be looking at cells undergoing neurogenesis in the developing human frontal cortex. The data are taken from [Nowakowski *et al* (2017)](https://doi.org/10.1126/science.aap8809). Our goal is to build a simple method for fitting single cell gene regulatory networks (GRNs) and compare the results across pseudotime lineages, keeping in mind the trajectory structure of the data. If you want to skip straight to the analysis, head to @sec-analysis. \n\n# Libraries {#sec-libs}\n\nWe start by loading in a few necessary packages & resolving a few function conflicts. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)                 # data manipulation\nlibrary(Seurat)                # scRNA-seq tools\nlibrary(scLANE)                # trajectory DE\nlibrary(igraph)                # graph utilities\nlibrary(ggplot2)               # pretty plots\nlibrary(biomaRt)               # gene annotation\nlibrary(foreach)               # parallel loops\nlibrary(ggnetwork)             # plotting graphs\nlibrary(slingshot)             # pseudotime estimation\nlibrary(patchwork)             # plot alignment\nlibrary(SingleCellExperiment)  # scRNA-seq data structures\nrename <- dplyr::rename\nselect <- dplyr::select\n```\n:::\n\n\n# Helper functions {#sec-fns}\n\nWe define a helper function to make our legends look prettier. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nguide_umap <- function(key.size = 4) {\n  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = key.size, \n                                                                    alpha = 1, \n                                                                    stroke = 0.25)))\n}\n```\n:::\n\n\nNext, we assign a few consistent color palettes that we'll use throughout. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npalette_heatmap <- paletteer::paletteer_d(\"MetBrewer::Hiroshige\", direction = -1)\npalette_celltype <- paletteer::paletteer_d(\"ggsci::category10_d3\")\npalette_cluster <- paletteer::paletteer_d(\"ggsci::default_locuszoom\")\npalette_timepoint <- paletteer::paletteer_d(\"ggsci::default_igv\")\n```\n:::\n\n\n# Data {#sec-data}\n\nUnfortunately the data that are made available as part of the `scRNAseq` package come in a transcripts-per-million (TPM) normalized matrix - not raw counts. A rough conversion back to the raw integer counts is to multiply each cell's normalized expression vector by the TPM size factor. This gets us most of the way there but the results are still estimates, so we round them to the nearest integer. \n\n::: {.callout-note}\nThis conversion ignores gene length, which is why the results are estimates & require rounding. For a more detailed discussion on how to un-normalize TPM counts see [this StackOverflow post](https://stackoverflow.com/questions/60614972/converting-tpm-data-to-read-counts-for-seurat). While the original authors used a plate-based protocol (Fluidigm C1) they do not mention whether they used unique molecular identifiers (UMIs); if UMIs were used then gene length normalization isn't necessary. Since simply reversing the TPM transformation doesn't result in integer values I would guess that UMIs were not used, though [their Supplementary Methods](https://www.science.org/doi/10.1126/science.aap8809#supplementary-materials) don't mention gene length normalization. \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce_cortex <- scRNAseq::NowakowskiCortexData()\ncounts_matrix <- Matrix::t(sce_cortex@assays@data$tpm)\nscale_factors <- Matrix::rowSums(counts_matrix) / 1e6\ncounts_matrix <- round(Matrix::t(counts_matrix) * scale_factors)\nseu_cortex <- CreateSeuratObject(counts_matrix, \n                                 assay = \"RNA\", \n                                 meta.data = as.data.frame(colData(sce_cortex)), \n                                 project = \"cortex\", \n                                 min.cells = 5,\n                                 min.features = 0)\nexcitatory_neuron_celltypes <- c(\"nEN-late\", \"nEN-early1\", \"nEN-early2\",\n                                 \"EN-V1-1\", \"EN-V1-2\", \"EN-V1-3\", \n                                 \"EN-PFC1\", \"EN-PFC2\", \"EN-PFC3\")\nseu_cortex <- seu_cortex[, seu_cortex$WGCNAcluster %in% excitatory_neuron_celltypes]\nseu_cortex@meta.data <- mutate(seu_cortex@meta.data, \n                               celltype_original = case_when(WGCNAcluster == \"nEN-early1\" ~ \"Early Exc. Neuron 1\", \n                                                             WGCNAcluster == \"nEN-early2\" ~ \"Early Exc. Neuron 2\", \n                                                             WGCNAcluster == \"nEN-late\" ~ \"Late Exc. Neuron\", \n                                                             WGCNAcluster == \"EN-V1-1\" ~ \"Exc. Neuron 1\", \n                                                             WGCNAcluster == \"EN-V1-2\" ~ \"Exc. Neuron 2\", \n                                                             WGCNAcluster == \"EN-V1-3\" ~ \"Exc. Neuron 3\", \n                                                             WGCNAcluster == \"EN-PFC1\" ~ \"PFC Exc. Neuron 1\", \n                                                             WGCNAcluster == \"EN-PFC2\" ~ \"PFC Exc. Neuron 2\", \n                                                             WGCNAcluster == \"EN-PFC3\" ~ \"PFC Exc. Neuron 3\", \n                                                             TRUE ~ NA_character_))\n```\n:::\n\n\n# Preprocessing {#sec-proprocess}\n\nWe run the cells through a basic preprocessing pipeline: QC, normalization, highly variable gene (HVG) identification, PCA, UMAP, and graph-based Leiden clustering. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu_cortex <- seu_cortex %>% \n              PercentageFeatureSet(pattern = \"^MT-\", col.name = \"percent_mito\") %>% \n              PercentageFeatureSet(pattern = \"^RP[SL]\", col.name = \"percent_ribo\") %>% \n              NormalizeData(verbose = FALSE) %>% \n              FindVariableFeatures(nfeatures = 3000, verbose = FALSE) %>% \n              ScaleData(verbose = FALSE) %>% \n              RunPCA(npcs = 30, \n                     approx = TRUE, \n                     seed.use = 312, \n                     verbose = FALSE) %>% \n              CellCycleScoring(s.features = cc.genes.updated.2019$s.genes, \n                               g2m.features = cc.genes.updated.2019$g2m.genes, \n                               set.ident = FALSE) %>% \n              RunUMAP(reduction = \"pca\", \n                      dims = 1:30,\n                      n.neighbors = 20, \n                      n.components = 2, \n                      metric = \"cosine\", \n                      n.epochs = 750,\n                      seed.use = 312, \n                      verbose = FALSE) %>% \n              FindNeighbors(reduction = \"pca\", \n                            k.param = 20,\n                            nn.method = \"annoy\", \n                            annoy.metric = \"cosine\", \n                            verbose = FALSE) %>% \n              FindClusters(algorithm = 4, \n                           method = \"igraph\", \n                           resolution = 0.5, \n                           random.seed = 312, \n                           verbose = FALSE)\n```\n:::\n\n\nHere we examine some of our dataset's attributes - the original celltype annotations, our new clusters, age in post-conception weeks (PCW), and the proportion of each cell's reads aligning to ribosomal genes. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np1 <- DimPlot(seu_cortex, \n              group.by = \"celltype_original\",\n              pt.size = 1.25,  \n              alpha = 0.75) + \n      scale_color_manual(values = palette_celltype) + \n      theme_scLANE(umap = TRUE) + \n      labs(color = \"Celltype\") + \n      theme(axis.title = element_blank(), \n            plot.title = element_blank()) + \n      guide_umap()\np2 <- FeaturePlot(seu_cortex, \n                  features = \"Age_in_Weeks\", \n                  pt.size = 1.25,  \n                  alpha = 0.75) + \n      scale_color_gradientn(colors = palette_heatmap) + \n      labs(color = \"Age (weeks)\") + \n      theme_scLANE(umap = TRUE) + \n      theme(axis.title = element_blank(), \n            plot.title = element_blank())\np3 <- DimPlot(seu_cortex, \n              group.by = \"seurat_clusters\", \n              pt.size = 1.25,  \n              alpha = 0.75) + \n      scale_color_manual(values = palette_cluster) + \n      labs(color = \"Leiden Cluster\") + \n      theme_scLANE(umap = TRUE) + \n      theme(axis.title = element_blank(), \n            plot.title = element_blank()) + \n      guide_umap()\np4 <- FeaturePlot(seu_cortex, \n                  features = \"percent_ribo\", \n                  pt.size = 1.25,  \n                  alpha = 0.75) + \n      scale_color_gradientn(colors = palette_heatmap, labels = scales::label_percent(accuracy = 1, scale = 1)) + \n      labs(color = \"Ribosomal\\nReads\") + \n      theme_scLANE(umap = TRUE) + \n      theme(axis.title = element_blank(), \n            plot.title = element_blank())\np5 <- (p1 / p2) | (p3 / p4)\np5 <- ggpubr::annotate_figure(ggpubr::ggarrange(p5), \n                              bottom = \"UMAP 1\",\n                              left = \"UMAP 2\")\np5\n```\n\n::: {.cell-output-display}\n![Characteristics of the cortical development dataset](Trajectory_GRN_files/figure-html/fig-EDA-1.png){#fig-EDA width=960}\n:::\n:::\n\n\n# Analysis {#sec-analysis}\n\n## Celltype annotation\n\nWe begin by running a basic differential expression (DE) testing routine to identify some potential marker genes for each cluster. This will help us assign a celltype identity to each cluster. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_markers <- FindAllMarkers(seu_cortex, \n                                  assay = \"RNA\", \n                                  logfc.threshold = 0.25, \n                                  test.use = \"wilcox\", \n                                  slot = \"data\", \n                                  min.pct = 0.1, \n                                  only.pos = TRUE, \n                                  verbose = FALSE, \n                                  random.seed = 312)\ntop5_cluster_markers <- arrange(cluster_markers, p_val_adj) %>% \n                        with_groups(cluster, \n                                    slice_head, \n                                    n = 5)\n```\n:::\n\n\nWe visualize the markers for each cluster with a dotplot, which shows clear differences between clusters. For example, the transcription factor (TF) aristaless related homeobox (*ARX*) is specifically expressed in cluster 7; this TF's expression is known to be necessary for healthy neuronal development and helps to regulate differentiation. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np6 <- DotPlot(seu_cortex, \n              features = unique(top5_cluster_markers$gene),\n              assay = \"RNA\", \n              group.by = \"seurat_clusters\", \n              dot.scale = 5,\n              cols = paletteer::paletteer_d(\"wesanderson::Zissou1\")[c(1, 5)], \n              scale.by = \"radius\") + \n      coord_flip() +\n      labs(y = \"Leiden Cluster\") +\n      theme_scLANE() + \n      theme(axis.title.y = element_blank(), \n            axis.text.y = element_text(face = \"italic\"))\np6\n```\n\n::: {.cell-output-display}\n![Putative marker genes for each cluster](Trajectory_GRN_files/figure-html/fig-dotplot_cluster-1.png){#fig-dotplot_cluster width=480}\n:::\n:::\n\n\nNow we identify markers for each celltype:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nIdents(seu_cortex) <- \"celltype_original\"\ncelltype_markers <- FindAllMarkers(seu_cortex, \n                                   assay = \"RNA\", \n                                   logfc.threshold = 0.25, \n                                   test.use = \"wilcox\", \n                                   slot = \"data\", \n                                   min.pct = 0.1, \n                                   only.pos = TRUE, \n                                   verbose = FALSE, \n                                   random.seed = 312)\ntop3_celltype_markers <- arrange(celltype_markers, p_val_adj) %>% \n                         with_groups(cluster, \n                                     slice_head, \n                                     n = 3)\n```\n:::\n\n\nThe markers seem consistent with what we'd expect for excitatory neurons; for more information see e.g., Figure 4 and Suppl. Figures 4 & 11 in [the original publication](https://doi.org/10.1126/science.aap8809). \n\n\n::: {#tbl-celltype_markers .cell tbl-cap='The top 3 markers genes for each identified celltype'}\n\n```{.r .cell-code  code-fold=\"true\"}\nselect(top3_celltype_markers, \n       celltype = cluster, \n       gene, \n       avg_log2FC, \n       p_val_adj) %>% \n  kableExtra::kbl(digits = 3, \n                  booktabs = TRUE, \n                  col.names = c(\"Celltype\", \"Gene\", \"Mean log2FC\", \"Adj. P-value\")) %>% \n  kableExtra::kable_classic(full_width = FALSE, \"hover\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-classic lightable-hover\" style='font-family: \"Arial Narrow\", \"Source Sans Pro\", sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Celltype </th>\n   <th style=\"text-align:left;\"> Gene </th>\n   <th style=\"text-align:right;\"> Mean log2FC </th>\n   <th style=\"text-align:right;\"> Adj. P-value </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Early Exc. Neuron 2 </td>\n   <td style=\"text-align:left;\"> NRP1 </td>\n   <td style=\"text-align:right;\"> 1.124 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Early Exc. Neuron 2 </td>\n   <td style=\"text-align:left;\"> DPY19L1 </td>\n   <td style=\"text-align:right;\"> 1.096 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Early Exc. Neuron 2 </td>\n   <td style=\"text-align:left;\"> SOX11 </td>\n   <td style=\"text-align:right;\"> 0.624 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Late Exc. Neuron </td>\n   <td style=\"text-align:left;\"> ZFHX4 </td>\n   <td style=\"text-align:right;\"> 2.034 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Late Exc. Neuron </td>\n   <td style=\"text-align:left;\"> RP11.436D23.1 </td>\n   <td style=\"text-align:right;\"> 1.751 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Late Exc. Neuron </td>\n   <td style=\"text-align:left;\"> LINC00478 </td>\n   <td style=\"text-align:right;\"> 2.164 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Exc. Neuron 2 </td>\n   <td style=\"text-align:left;\"> DOK5 </td>\n   <td style=\"text-align:right;\"> 2.873 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Exc. Neuron 2 </td>\n   <td style=\"text-align:left;\"> SATB2 </td>\n   <td style=\"text-align:right;\"> 1.677 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Exc. Neuron 2 </td>\n   <td style=\"text-align:left;\"> STMN2 </td>\n   <td style=\"text-align:right;\"> 0.857 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Exc. Neuron 3 </td>\n   <td style=\"text-align:left;\"> ACTN2 </td>\n   <td style=\"text-align:right;\"> 4.731 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Exc. Neuron 3 </td>\n   <td style=\"text-align:left;\"> LPL </td>\n   <td style=\"text-align:right;\"> 3.325 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Exc. Neuron 3 </td>\n   <td style=\"text-align:left;\"> UNC5C </td>\n   <td style=\"text-align:right;\"> 6.760 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PFC Exc. Neuron 3 </td>\n   <td style=\"text-align:left;\"> RP11.98J23.2 </td>\n   <td style=\"text-align:right;\"> 3.008 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PFC Exc. Neuron 3 </td>\n   <td style=\"text-align:left;\"> RP11.589F5.4 </td>\n   <td style=\"text-align:right;\"> 3.111 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PFC Exc. Neuron 3 </td>\n   <td style=\"text-align:left;\"> RP11.1415C14.3 </td>\n   <td style=\"text-align:right;\"> 3.198 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Exc. Neuron 1 </td>\n   <td style=\"text-align:left;\"> CRYM </td>\n   <td style=\"text-align:right;\"> 3.523 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Exc. Neuron 1 </td>\n   <td style=\"text-align:left;\"> GRIK3 </td>\n   <td style=\"text-align:right;\"> 2.968 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Exc. Neuron 1 </td>\n   <td style=\"text-align:left;\"> FEZF2 </td>\n   <td style=\"text-align:right;\"> 3.872 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PFC Exc. Neuron 1 </td>\n   <td style=\"text-align:left;\"> CDH18 </td>\n   <td style=\"text-align:right;\"> 3.441 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PFC Exc. Neuron 1 </td>\n   <td style=\"text-align:left;\"> SORCS1 </td>\n   <td style=\"text-align:right;\"> 4.858 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PFC Exc. Neuron 1 </td>\n   <td style=\"text-align:left;\"> COL19A1 </td>\n   <td style=\"text-align:right;\"> 9.146 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Early Exc. Neuron 1 </td>\n   <td style=\"text-align:left;\"> NDST4 </td>\n   <td style=\"text-align:right;\"> 3.965 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Early Exc. Neuron 1 </td>\n   <td style=\"text-align:left;\"> STK17B </td>\n   <td style=\"text-align:right;\"> 3.639 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Early Exc. Neuron 1 </td>\n   <td style=\"text-align:left;\"> CNTNAP2 </td>\n   <td style=\"text-align:right;\"> 2.501 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PFC Exc. Neuron 2 </td>\n   <td style=\"text-align:left;\"> CPNE8 </td>\n   <td style=\"text-align:right;\"> 5.170 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PFC Exc. Neuron 2 </td>\n   <td style=\"text-align:left;\"> CBLN2 </td>\n   <td style=\"text-align:right;\"> 4.410 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PFC Exc. Neuron 2 </td>\n   <td style=\"text-align:left;\"> SLN </td>\n   <td style=\"text-align:right;\"> 4.456 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Pseudotime estimation\n\nAfter estimating principal curves across our UMAP embedding with `slingshot`, we generate per-lineage pseudotime values for each cell. We use our clustering as a source of structure in the data, and assign start and end clusters based on age in PCW. In addition, we mean-aggregate the pseudotime values for each cell in order to get a total pseudotime which represents overall differentiation regardless of lineage. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsling_res <- slingshot(Embeddings(seu_cortex, \"umap\"), \n                       clusterLabels = seu_cortex$seurat_clusters, \n                       start.clus = c(\"3\"), \n                       end.clus = c(\"5\", \"6\", \"7\"), \n                       approx_points = 1e3)\nsling_curves <- slingCurves(sling_res, as.df = TRUE)\nsling_mst <- slingMST(sling_res, as.df = TRUE)\nsling_pt <- as.data.frame(slingPseudotime(sling_res)) %>% \n            rowwise() %>% \n            mutate(PT_Overall = mean(c_across(starts_with(\"Lineage\")), na.rm = TRUE)) %>% \n            ungroup() %>% \n            mutate(across(c(starts_with(\"Lineage\"), PT_Overall), \n                          \\(x) (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))))\nseu_cortex <- AddMetaData(seu_cortex, \n                          metadata = sling_pt$PT_Overall, \n                          col.name = \"PT_Overall\")\n```\n:::\n\n\nThe graph structure estimate by `slingshot` is called a minimum spanning tree (MST), and describes the relationships between clusters in an undirected manner. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np7 <- data.frame(Embeddings(seu_cortex, \"umap\")) %>% \n      mutate(leiden = seu_cortex$seurat_clusters) %>% \n      ggplot(aes(x = umap_1, y = umap_2, color = leiden)) + \n      geom_point(size = 1.25, alpha = 0.75) + \n      geom_path(data = sling_mst, mapping = aes(x = umap_1, y = umap_2, group = Lineage), \n                linewidth = 1.25, \n                color = \"black\") + \n      geom_point(data = sling_mst, mapping = aes(x = umap_1, y = umap_2, fill = Cluster), \n                color = \"black\", \n                shape = 21, \n                size = 4.5, \n                stroke = 1.25, \n                show.legend = FALSE) + \n      scale_color_manual(values = palette_cluster) + \n      scale_fill_manual(values = palette_cluster) + \n      labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n      theme_scLANE(umap = TRUE) +  \n      theme(legend.title = element_blank()) + \n      guide_umap()\np7\n```\n\n::: {.cell-output-display}\n![UMAP embedding with MST from Slinghot overlaid](Trajectory_GRN_files/figure-html/fig-umap_MST-1.png){#fig-umap_MST width=576}\n:::\n:::\n\n\nSince our data have real-life experimental timepoints, it makes sense to normalize the pseudotime within each lineage to $[0, 1]$.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np8 <- data.frame(Embeddings(seu_cortex, \"umap\")) %>% \n      bind_cols(sling_pt) %>% \n      tidyr::pivot_longer(starts_with(\"Lineage\"), \n                          names_to = \"lineage\", \n                          values_to = \"pseudotime\") %>% \n      ggplot(aes(x = umap_1, y = umap_2, color = pseudotime)) + \n      facet_wrap(~lineage, nrow = 3) + \n      geom_point(size = 1.25, alpha = 0.75) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           color = \"Pseudotime\") + \n      scale_color_gradientn(colors = palette_heatmap, labels = scales::label_number(accuracy = .01)) + \n      theme_scLANE(umap = TRUE)\np8\n```\n\n::: {.cell-output-display}\n![UMAP embedding colored by per-lineage pseudotime](Trajectory_GRN_files/figure-html/fig-umap_lineage_PT-1.png){#fig-umap_lineage_PT width=576}\n:::\n:::\n\n\nThe principal curves show a trifurcating lineage structure. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np9 <- data.frame(Embeddings(seu_cortex, \"umap\")) %>% \n      mutate(leiden = seu_cortex$seurat_clusters) %>% \n      ggplot(aes(x = umap_1, y = umap_2, color = leiden)) + \n      geom_point(size = 1.25, alpha = 0.75) + \n      geom_path(data = sling_curves,\n                mapping = aes(x = umap_1, y = umap_2, group = Lineage), \n                color = \"black\", \n                linewidth = 1.5, \n                alpha = 0.75, \n                lineend = \"round\") + \n      scale_color_manual(values = palette_cluster) + \n      labs(x = \"UMAP 1\", y = \"UMAP 2\") + \n      theme_scLANE(umap = TRUE) + \n      theme(legend.title = element_blank()) + \n      guides(color = guide_legend(override.aes = list(size = 4, alpha = 1, stroke = 0.25)))\np9\n```\n\n::: {.cell-output-display}\n![UMAP embedding with principal curves from Slinghot overlaid in black](Trajectory_GRN_files/figure-html/fig-umap_curves-1.png){#fig-umap_curves width=576}\n:::\n:::\n\n\nLastly, we plot the distribution of mean-aggregated pseudotime per-timepoint and see that later timepoints have, in general, larger values of overall pseudotime. This indicates that our estimated pseudotime is linked to real experimental time in a meaningful (though fairly noisy) way. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np10 <- select(seu_cortex@meta.data, \n              Age_in_Weeks, \n              PT_Overall) %>% \n       mutate(Age_in_Weeks = as.factor(Age_in_Weeks)) %>% \n       ggplot(aes(x = Age_in_Weeks, y = PT_Overall, color = Age_in_Weeks)) + \n       ggbeeswarm::geom_quasirandom(size = 1.25, \n                                    alpha = 0.75, \n                                    show.legend = FALSE) + \n       stat_summary(geom = \"point\", \n                    fun = \"mean\", \n                    color = \"black\",\n                    size = 3) + \n       scale_color_manual(values = palette_timepoint) + \n       labs(x = \"Age (PCW)\", y = \"Mean Psueodtime\") + \n       theme_scLANE()\np10\n```\n\n::: {.cell-output-display}\n![Beeswarm plot displaying the distribution of mean-aggregated pseudotime for each timepoint](Trajectory_GRN_files/figure-html/fig-PCW_PT-1.png){#fig-PCW_PT width=768}\n:::\n:::\n\n\n## Trajectory DE testing\n\nUsing `scLANE` (see [the GitHub repository](https://github.com/jr-leary7/scLANE) or [the preprint](https://doi.org/10.1101/2023.12.19.572477) for details) we perform trajectory DE significance testing for each HVG across each lineage. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop3k_hvg <- HVFInfo(seu_cortex) %>% \n             arrange(desc(variance.standardized)) %>% \n             slice_head(n = 3000) %>% \n             rownames(.)\ncell_offset <- createCellOffset(seu_cortex)\npt_df <- select(sling_pt, -PT_Overall)\nscLANE_models <- testDynamic(seu_cortex, \n                             pt = pt_df, \n                             genes = top3k_hvg,\n                             size.factor.offset = cell_offset, \n                             n.cores = 6L, \n                             verbose = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nscLANE testing completed for 3000 genes across 3 lineages in 13.321 mins\n```\n\n\n:::\n\n```{.r .cell-code}\nscLANE_de_res <- getResultsDE(scLANE_models)\n```\n:::\n\n\nWe now have lineage-specific trajectory DE statistics for each gene: \n\n\n::: {#tbl-scLANE_output .cell tbl-cap='Top-10 most DE genes from scLANE'}\n\n```{.r .cell-code  code-fold=\"true\"}\nselect(scLANE_de_res, \n       Gene, \n       Lineage, \n       Test_Stat, \n       P_Val, \n       P_Val_Adj,\n       Gene_Dynamic_Lineage, \n       Gene_Dynamic_Overall) %>% \n  mutate(Gene_Dynamic_Lineage = if_else(Gene_Dynamic_Lineage == 1, \"Dynamic\", \"Static\"), \n         Gene_Dynamic_Overall = if_else(Gene_Dynamic_Overall == 1, \"Dynamic\", \"Static\")) %>% \n  slice_head(n = 10) %>% \n  kableExtra::kbl(digits = 4, \n                  booktabs = TRUE, \n                  col.names = c(\"Gene\", \"Lineage\", \"LRT stat.\", \"P-value\", \"Adj. p-value\", \"Gene status (lineage)\", \"Gene status (overall)\")) %>% \n  kableExtra::kable_classic(full_width = FALSE, \"hover\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-classic lightable-hover\" style='font-family: \"Arial Narrow\", \"Source Sans Pro\", sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Gene </th>\n   <th style=\"text-align:left;\"> Lineage </th>\n   <th style=\"text-align:right;\"> LRT stat. </th>\n   <th style=\"text-align:right;\"> P-value </th>\n   <th style=\"text-align:right;\"> Adj. p-value </th>\n   <th style=\"text-align:left;\"> Gene status (lineage) </th>\n   <th style=\"text-align:left;\"> Gene status (overall) </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> LMO3 </td>\n   <td style=\"text-align:left;\"> B </td>\n   <td style=\"text-align:right;\"> 4030239 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LMO3 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 3924999 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MEF2C </td>\n   <td style=\"text-align:left;\"> B </td>\n   <td style=\"text-align:right;\"> 3650115 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LMO3 </td>\n   <td style=\"text-align:left;\"> C </td>\n   <td style=\"text-align:right;\"> 3439387 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LIMCH1 </td>\n   <td style=\"text-align:left;\"> B </td>\n   <td style=\"text-align:right;\"> 3100288 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LIMCH1 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 3097931 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LINC01102 </td>\n   <td style=\"text-align:left;\"> B </td>\n   <td style=\"text-align:right;\"> 2857935 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LINC01102 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 2699231 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SHISA2 </td>\n   <td style=\"text-align:left;\"> B </td>\n   <td style=\"text-align:right;\"> 2086787 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SHISA2 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 2046352 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nWe identify a set of dynamic genes - dynamic meaning DE over any of the three lineages - to be used for downstream analysis. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndyn_genes <- filter(scLANE_de_res, Gene_Dynamic_Overall == 1) %>% \n             distinct(Gene) %>% \n             pull(Gene)\n```\n:::\n\n\nLastly, we pull a table of gene dynamics for each lineage. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmoothed_counts <- smoothedCountsMatrix(scLANE_models, \n                                        size.factor.offset = cell_offset, \n                                        pt = pt_df, \n                                        genes = dyn_genes, \n                                        log1p.norm = TRUE, \n                                        n.cores = 4L)\n```\n:::\n\n\n## Constructing a GRN from scratch\n\nBuilding a GRN requires two main inputs - a set of transcription factors, and a set of potential target genes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhs_ensembl <- useMart(\"ensembl\", dataset = \"hsapiens_gene_ensembl\")\nhs_tf_raw <- readr::read_csv(\"http://humantfs.ccbr.utoronto.ca/download/v_1.01/DatabaseExtract_v_1.01.csv\",\n                             col_select = -1,\n                             num_threads = 2L,\n                             show_col_types = FALSE) %>%\n             janitor::clean_names() %>%\n             filter(is_tf == \"Yes\") %>%\n             select(ensembl_id)\nhs_tfs <- getBM(attributes = c(\"ensembl_gene_id\", \"hgnc_symbol\", \"entrezgene_id\", \"description\", \"gene_biotype\"),\n                filters = \"ensembl_gene_id\",\n                values = hs_tf_raw$ensembl_id,\n                mart = hs_ensembl,\n                uniqueRows = TRUE) %>%\n          rename(ensembl_id = ensembl_gene_id,\n                 entrez_id = entrezgene_id) %>%\n          arrange(ensembl_id) %>%\n          mutate(hgnc_symbol = if_else(hgnc_symbol == \"\", NA_character_, hgnc_symbol),\n                 description = gsub(\"\\\\[Source.*\", \"\", description))\n```\n:::\n\n\nAlong with the HGNC symbol, we used `BiomaRt` to retrieve the Ensembl & Entrez IDs and a description for every TF. \n\n\n::: {#tbl-TFs .cell tbl-cap='Human transcription factors'}\n\n```{.r .cell-code  code-fold=\"true\"}\nslice_sample(hs_tfs, n = 10) %>% \n  kableExtra::kbl(booktabs = TRUE, \n                  col.names = c(\"Ensembl ID\", \"HGNC symbol\", \"Entrez ID\", \"Description\", \"Biotype\")) %>% \n  kableExtra::kable_classic(full_width = FALSE, \"hover\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-classic lightable-hover\" style='font-family: \"Arial Narrow\", \"Source Sans Pro\", sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Ensembl ID </th>\n   <th style=\"text-align:left;\"> HGNC symbol </th>\n   <th style=\"text-align:right;\"> Entrez ID </th>\n   <th style=\"text-align:left;\"> Description </th>\n   <th style=\"text-align:left;\"> Biotype </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> ENSG00000173041 </td>\n   <td style=\"text-align:left;\"> ZNF680 </td>\n   <td style=\"text-align:right;\"> 340252 </td>\n   <td style=\"text-align:left;\"> zinc finger protein 680 </td>\n   <td style=\"text-align:left;\"> protein_coding </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ENSG00000149922 </td>\n   <td style=\"text-align:left;\"> TBX6 </td>\n   <td style=\"text-align:right;\"> 6911 </td>\n   <td style=\"text-align:left;\"> T-box transcription factor 6 </td>\n   <td style=\"text-align:left;\"> protein_coding </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ENSG00000085274 </td>\n   <td style=\"text-align:left;\"> MYNN </td>\n   <td style=\"text-align:right;\"> 55892 </td>\n   <td style=\"text-align:left;\"> myoneurin </td>\n   <td style=\"text-align:left;\"> protein_coding </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ENSG00000169740 </td>\n   <td style=\"text-align:left;\"> ZNF32 </td>\n   <td style=\"text-align:right;\"> 7580 </td>\n   <td style=\"text-align:left;\"> zinc finger protein 32 </td>\n   <td style=\"text-align:left;\"> protein_coding </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ENSG00000214534 </td>\n   <td style=\"text-align:left;\"> ZNF705EP </td>\n   <td style=\"text-align:right;\"> NA </td>\n   <td style=\"text-align:left;\"> zinc finger protein 705E, pseudogene </td>\n   <td style=\"text-align:left;\"> transcribed_unprocessed_pseudogene </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ENSG00000129071 </td>\n   <td style=\"text-align:left;\"> MBD4 </td>\n   <td style=\"text-align:right;\"> 8930 </td>\n   <td style=\"text-align:left;\"> methyl-CpG binding domain 4, DNA glycosylase </td>\n   <td style=\"text-align:left;\"> protein_coding </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ENSG00000114853 </td>\n   <td style=\"text-align:left;\"> ZBTB47 </td>\n   <td style=\"text-align:right;\"> 92999 </td>\n   <td style=\"text-align:left;\"> zinc finger and BTB domain containing 47 </td>\n   <td style=\"text-align:left;\"> protein_coding </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ENSG00000111206 </td>\n   <td style=\"text-align:left;\"> FOXM1 </td>\n   <td style=\"text-align:right;\"> 2305 </td>\n   <td style=\"text-align:left;\"> forkhead box M1 </td>\n   <td style=\"text-align:left;\"> protein_coding </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ENSG00000184436 </td>\n   <td style=\"text-align:left;\"> THAP7 </td>\n   <td style=\"text-align:right;\"> 80764 </td>\n   <td style=\"text-align:left;\"> THAP domain containing 7 </td>\n   <td style=\"text-align:left;\"> protein_coding </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ENSG00000196172 </td>\n   <td style=\"text-align:left;\"> ZNF681 </td>\n   <td style=\"text-align:right;\"> 148213 </td>\n   <td style=\"text-align:left;\"> zinc finger protein 681 </td>\n   <td style=\"text-align:left;\"> protein_coding </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nWe split our set of 295 trajectory DE genes into the two categories using the existing set of human TFs I found online. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalid_hs_tfs <- hs_tfs$hgnc_symbol[hs_tfs$hgnc_symbol %in% dyn_genes]\ntarget_genes <- dyn_genes[!dyn_genes %in% valid_hs_tfs]\n```\n:::\n\n\nThe GRN has the following structure - for every target gene, a penalized model is fit with the dynamics of every possible TF as features (see below). The model's internal feature selection identifies a subset of TFs whose dynamics are predictive of the target gene's dynamics. See e.g., [the original XGBoost paper](https://doi.org/10.48550/arXiv.1603.02754) for details. \n\n$$\n\\text{Dynamics}_{\\text{Target}} = \\begin{bmatrix} \\text{Dynamics}_{\\text{TF}_1} & \\text{Dynamics}_{\\text{TF}_2} & \\dots & \\text{Dynamics}_{\\text{TF}_N} \\end{bmatrix}\n$$ {#eq-XGBoost}\n\nOur GRNs will be lineage-specific, since the matrix of gene dynamics differs by lineage. First we fit the GRN for lineage A; I've opted to use the `LightGBM` package to fit the models as it's lightweight and in general much faster than other options such as `XGBoost`. In addition, I prefer this method to alternative penalized methods such as LASSO - boosted trees better capture nonlinearities in the data, though LASSO does offer advantages such as significance testing for coefficients and linear interpretability. Both methods have built-in cross-validation (CV) routines (`lightgbm::lgb.cv()` and `glmnet::cv.glmnet()`, respectively); here we use 5-fold CV to select the best set of hyperparameters before training the final model. \n\n::: {.callout-note}\nSince we're using the `foreach` and `doSNOW` packages to loop over the set of target genes in parallel, we need to ensure that our `LightGBM` model only uses a single thread when fitting the model. This is done by setting the parameters `tree_learner = \"serial\"` and `num_threads = 1L` in the model parameters list. \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncl <- parallel::makeCluster(6L)\ndoSNOW::registerDoSNOW(cl)\nlgbm_params <- list(objective = \"gamma\", \n                    tree_learner = \"serial\", \n                    metric = \"l2\", \n                    boosting_type = \"gbdt\", \n                    num_threads = 1L, \n                    seed = 312)\ngrn_res_linA <- foreach(g = seq(target_genes), \n                        .combine = \"list\",\n                        .multicombine = ifelse(length(target_genes) > 1, TRUE, FALSE),\n                        .maxcombine = ifelse(length(target_genes) > 1, length(target_genes), 2),\n                        .packages = c(\"lightgbm\", \"dplyr\"),\n                        .errorhandling = \"pass\",\n                        .inorder = TRUE,\n                        .verbose = FALSE) %dopar% {\n                          feature_mat <- smoothed_counts$Lineage_A[, valid_hs_tfs]\n                          resp_var <- smoothed_counts$Lineage_A[, target_genes[g]]\n                          lgbm_data <- lightgbm::lgb.Dataset(data = feature_mat, label = resp_var)\n                          lgbm_cv <- lightgbm::lgb.cv(params = lgbm_params, \n                                                      data = lgbm_data, \n                                                      nrounds = 100L, \n                                                      nfold = 5L, \n                                                      stratified = FALSE)\n                          lgbm_model <- lightgbm::lgb.train(params = lgbm_params, \n                                                            data = lgbm_data, \n                                                            nrounds = lgbm_cv$best_iter)\n                          imp_table <- as.data.frame(lightgbm::lgb.importance(lgbm_model)) %>% \n                                       dplyr::mutate(Lineage = \"A\", \n                                                     Target_Gene = target_genes[g], \n                                                     .before = 1)\n                          imp_table\n                        }\nnames(grn_res_linA) <- target_genes\ngrn_table_linA <- purrr::imap(grn_res_linA, \\(x, y) {\n  if (!inherits(x, \"data.frame\")) {\n    empty_res <- data.frame(Lineage = \"A\", \n                            Target_Gene = y, \n                            Feature = NA_character_, \n                            Gain = NA_real_, \n                            Cover = NA_real_, \n                            Frequency = NA_real_)\n    return(empty_res)\n  } else {\n    return(x)\n  }\n})\n```\n:::\n\n\nWe coerce the model output into a tidy table. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrn_table_linA <- purrr::reduce(grn_table_linA, rbind) %>% \n                  rename(Tx_Factor = Feature) %>% \n                  filter(!is.na(Target_Gene), \n                         !is.na(Tx_Factor)) %>% \n                  arrange(Tx_Factor, desc(Frequency))\n```\n:::\n\n\nNext we add the Spearman correlation between TF and target gene dynamics, as well as the normalized gene expression correlation. We denote the relationship between TF and target gene as repression if the correlation between their dynamics is negative, and activation if the correlation is positive. \n\n::: {.callout-warning}\nUsually the correlations between TF and target dynamics and TF and target expression are similar, or at least have the same directionality (positive or negative). However, when expression patterns are noisy, the correlation directions might differ (see @tbl-GRN_linA for examples). In this case, we're opting to trust the dynamics more, as they are a smoothed version of expression - though an argument could be made for the opposite stance as well. \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndyn_cormat <- cor(smoothed_counts$Lineage_A, method = \"spearman\")\nexp_cormat <- cor(as.matrix(Matrix::t(seu_cortex@assays$RNA$data[dyn_genes, ])), method = \"spearman\")\ngrn_table_linA <- mutate(grn_table_linA, \n                         Dyn_Cor = NA_real_, \n                         Exp_Cor = NA_real_)\nfor (i in seq(nrow(grn_table_linA))) {\n  grn_table_linA$Dyn_Cor[i] <- dyn_cormat[grn_table_linA$Target_Gene[i], grn_table_linA$Tx_Factor[i]]\n  grn_table_linA$Exp_Cor[i] <- exp_cormat[grn_table_linA$Target_Gene[i], grn_table_linA$Tx_Factor[i]]\n}\ngrn_table_linA <- mutate(grn_table_linA, State = if_else(Dyn_Cor < 0, \"Repression\", \"Activation\"))\n```\n:::\n\n\nThe output is shown below. Here we use the frequency with which the TF is included in the final boosted tree model as the feature importance, which can be interpreted as the strength of the predictive relationship between TF & target gene. See e.g., [this StackExchange post](https://datascience.stackexchange.com/questions/12318/how-to-interpret-the-output-of-xgboost-importance) for more detail.  \n\n\n::: {#tbl-GRN_linA .cell tbl-cap='GRN for dynamic genes across Lineage A'}\n\n```{.r .cell-code  code-fold=\"true\"}\nselect(grn_table_linA, \n       Lineage, \n       Tx_Factor, \n       Target_Gene, \n       Frequency, \n       Dyn_Cor, \n       Exp_Cor, \n       State) %>% \n  slice_sample(n = 10) %>% \n  kableExtra::kbl(digits = 4, \n                  booktabs = TRUE, \n                  col.names = c(\"Lineage\", \"TF\", \"Target\", \"Importance\", \"Dynamics cor.\", \"Expression cor.\", \"State\")) %>% \n  kableExtra::kable_classic(full_width = FALSE, \"hover\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-classic lightable-hover\" style='font-family: \"Arial Narrow\", \"Source Sans Pro\", sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Lineage </th>\n   <th style=\"text-align:left;\"> TF </th>\n   <th style=\"text-align:left;\"> Target </th>\n   <th style=\"text-align:right;\"> Importance </th>\n   <th style=\"text-align:right;\"> Dynamics cor. </th>\n   <th style=\"text-align:right;\"> Expression cor. </th>\n   <th style=\"text-align:left;\"> State </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:left;\"> TSHZ2 </td>\n   <td style=\"text-align:left;\"> KLHL14 </td>\n   <td style=\"text-align:right;\"> 0.0333 </td>\n   <td style=\"text-align:right;\"> 0.3740 </td>\n   <td style=\"text-align:right;\"> 0.0356 </td>\n   <td style=\"text-align:left;\"> Activation </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:left;\"> CXXC4 </td>\n   <td style=\"text-align:left;\"> PEX5L </td>\n   <td style=\"text-align:right;\"> 0.0007 </td>\n   <td style=\"text-align:right;\"> 0.0926 </td>\n   <td style=\"text-align:right;\"> 0.0962 </td>\n   <td style=\"text-align:left;\"> Activation </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:left;\"> EOMES </td>\n   <td style=\"text-align:left;\"> MDM4 </td>\n   <td style=\"text-align:right;\"> 0.0170 </td>\n   <td style=\"text-align:right;\"> 0.6390 </td>\n   <td style=\"text-align:right;\"> -0.0034 </td>\n   <td style=\"text-align:left;\"> Activation </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:left;\"> CUX2 </td>\n   <td style=\"text-align:left;\"> RP11.335E14.1 </td>\n   <td style=\"text-align:right;\"> 0.0490 </td>\n   <td style=\"text-align:right;\"> 0.5553 </td>\n   <td style=\"text-align:right;\"> -0.0111 </td>\n   <td style=\"text-align:left;\"> Activation </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:left;\"> FOXP2 </td>\n   <td style=\"text-align:left;\"> LGI1 </td>\n   <td style=\"text-align:right;\"> 0.0133 </td>\n   <td style=\"text-align:right;\"> -0.4933 </td>\n   <td style=\"text-align:right;\"> 0.0552 </td>\n   <td style=\"text-align:left;\"> Repression </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:left;\"> TGIF2 </td>\n   <td style=\"text-align:left;\"> PTPRR </td>\n   <td style=\"text-align:right;\"> 0.0540 </td>\n   <td style=\"text-align:right;\"> -0.0378 </td>\n   <td style=\"text-align:right;\"> -0.0173 </td>\n   <td style=\"text-align:left;\"> Repression </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:left;\"> FOXP2 </td>\n   <td style=\"text-align:left;\"> RP11.1112C15.2 </td>\n   <td style=\"text-align:right;\"> 0.0260 </td>\n   <td style=\"text-align:right;\"> -0.7971 </td>\n   <td style=\"text-align:right;\"> 0.0502 </td>\n   <td style=\"text-align:left;\"> Repression </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:left;\"> CREB5 </td>\n   <td style=\"text-align:left;\"> NTRK2 </td>\n   <td style=\"text-align:right;\"> 0.0566 </td>\n   <td style=\"text-align:right;\"> -0.6718 </td>\n   <td style=\"text-align:right;\"> -0.0825 </td>\n   <td style=\"text-align:left;\"> Repression </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:left;\"> EOMES </td>\n   <td style=\"text-align:left;\"> UNC5D </td>\n   <td style=\"text-align:right;\"> 0.1240 </td>\n   <td style=\"text-align:right;\"> 0.9615 </td>\n   <td style=\"text-align:right;\"> 0.1371 </td>\n   <td style=\"text-align:left;\"> Activation </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:left;\"> DLX5 </td>\n   <td style=\"text-align:left;\"> AASS </td>\n   <td style=\"text-align:right;\"> 0.0723 </td>\n   <td style=\"text-align:right;\"> -0.3497 </td>\n   <td style=\"text-align:right;\"> -0.0159 </td>\n   <td style=\"text-align:left;\"> Repression </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nWe repeat the fitting process for the other two lineages (expand this code block to see the details). Skip to @sec-conclusions if you want a version of this logic that's been wrapped into a function!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ngrn_res_linB <- foreach(g = seq(target_genes), \n                        .combine = \"list\",\n                        .multicombine = ifelse(length(target_genes) > 1, TRUE, FALSE),\n                        .maxcombine = ifelse(length(target_genes) > 1, length(target_genes), 2),\n                        .packages = c(\"lightgbm\", \"dplyr\"),\n                        .errorhandling = \"pass\",\n                        .inorder = TRUE,\n                        .verbose = FALSE) %dopar% {\n                          feature_mat <- smoothed_counts$Lineage_B[, valid_hs_tfs]\n                          resp_var <- smoothed_counts$Lineage_B[, target_genes[g]]\n                          lgbm_data <- lightgbm::lgb.Dataset(data = feature_mat, label = resp_var)\n                          lgbm_cv <- lightgbm::lgb.cv(params = lgbm_params, \n                                                      data = lgbm_data, \n                                                      nrounds = 100L, \n                                                      nfold = 5L, \n                                                      stratified = FALSE)\n                          lgbm_model <- lightgbm::lgb.train(params = lgbm_params, \n                                                            data = lgbm_data, \n                                                            nrounds = lgbm_cv$best_iter)\n                          imp_table <- as.data.frame(lightgbm::lgb.importance(lgbm_model)) %>% \n                                       dplyr::mutate(Lineage = \"B\", \n                                                     Target_Gene = target_genes[g], \n                                                     .before = 1)\n                          imp_table\n                        }\nnames(grn_res_linB) <- target_genes\ngrn_table_linB <- purrr::imap(grn_res_linB, \\(x, y) {\n  if (!inherits(x, \"data.frame\")) {\n    empty_res <- data.frame(Lineage = \"B\", \n                            Target_Gene = y, \n                            Feature = NA_character_, \n                            Gain = NA_real_, \n                            Cover = NA_real_, \n                            Frequency = NA_real_)\n    return(empty_res)\n  } else {\n    return(x)\n  }\n})\ngrn_table_linB <- purrr::reduce(grn_table_linB, rbind) %>% \n                  rename(Tx_Factor = Feature) %>% \n                  filter(!is.na(Target_Gene), \n                         !is.na(Tx_Factor)) %>% \n                  arrange(Tx_Factor, desc(Frequency))\ndyn_cormat <- cor(smoothed_counts$Lineage_B, method = \"spearman\")\ngrn_table_linB <- mutate(grn_table_linB, \n                         Dyn_Cor = NA_real_, \n                         Exp_Cor = NA_real_)\nfor (i in seq(nrow(grn_table_linB))) {\n  grn_table_linB$Dyn_Cor[i] <- dyn_cormat[grn_table_linB$Target_Gene[i], grn_table_linB$Tx_Factor[i]]\n  grn_table_linB$Exp_Cor[i] <- exp_cormat[grn_table_linB$Target_Gene[i], grn_table_linB$Tx_Factor[i]]\n}\ngrn_table_linB <- mutate(grn_table_linB, State = if_else(Dyn_Cor < 0, \"Repression\", \"Activation\"))\ngrn_res_linC <- foreach(g = seq(target_genes), \n                        .combine = \"list\",\n                        .multicombine = ifelse(length(target_genes) > 1, TRUE, FALSE),\n                        .maxcombine = ifelse(length(target_genes) > 1, length(target_genes), 2),\n                        .packages = c(\"lightgbm\", \"dplyr\"),\n                        .errorhandling = \"pass\",\n                        .inorder = TRUE,\n                        .verbose = FALSE) %dopar% {\n                          feature_mat <- smoothed_counts$Lineage_C[, valid_hs_tfs]\n                          resp_var <- smoothed_counts$Lineage_C[, target_genes[g]]\n                          lgbm_data <- lightgbm::lgb.Dataset(data = feature_mat, label = resp_var)\n                          lgbm_cv <- lightgbm::lgb.cv(params = lgbm_params, \n                                                      data = lgbm_data, \n                                                      nrounds = 100L, \n                                                      nfold = 5L, \n                                                      stratified = FALSE)\n                          lgbm_model <- lightgbm::lgb.train(params = lgbm_params, \n                                                            data = lgbm_data, \n                                                            nrounds = lgbm_cv$best_iter)\n                          imp_table <- as.data.frame(lightgbm::lgb.importance(lgbm_model)) %>% \n                                       dplyr::mutate(Lineage = \"C\", \n                                                     Target_Gene = target_genes[g], \n                                                     .before = 1)\n                          imp_table\n                        }\nnames(grn_res_linC) <- target_genes\ngrn_table_linC <- purrr::imap(grn_res_linC, \\(x, y) {\n  if (!inherits(x, \"data.frame\")) {\n    empty_res <- data.frame(Lineage = \"C\", \n                            Target_Gene = y, \n                            Feature = NA_character_, \n                            Gain = NA_real_, \n                            Cover = NA_real_, \n                            Frequency = NA_real_)\n    return(empty_res)\n  } else {\n    return(x)\n  }\n})\ngrn_table_linC <- purrr::reduce(grn_table_linC, rbind) %>% \n                  rename(Tx_Factor = Feature) %>% \n                  filter(!is.na(Target_Gene), \n                         !is.na(Tx_Factor)) %>% \n                  arrange(Tx_Factor, desc(Frequency))\ndyn_cormat <- cor(smoothed_counts$Lineage_C, method = \"spearman\")\ngrn_table_linC <- mutate(grn_table_linC, \n                         Dyn_Cor = NA_real_, \n                         Exp_Cor = NA_real_)\nfor (i in seq(nrow(grn_table_linC))) {\n  grn_table_linC$Dyn_Cor[i] <- dyn_cormat[grn_table_linC$Target_Gene[i], grn_table_linC$Tx_Factor[i]]\n  grn_table_linC$Exp_Cor[i] <- exp_cormat[grn_table_linC$Target_Gene[i], grn_table_linC$Tx_Factor[i]]\n}\ngrn_table_linC <- mutate(grn_table_linC, State = if_else(Dyn_Cor < 0, \"Repression\", \"Activation\"))\nparallel::stopCluster(cl)\n```\n:::\n\n\nWe collate all three GRNs into a single overall table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrn_table_all <- bind_rows(grn_table_linA, \n                           grn_table_linB, \n                           grn_table_linC) %>% \n                 arrange(Tx_Factor, Target_Gene)\n```\n:::\n\n\nFor each lineage we create a directed, weighted graph of the relationships between TFs and target genes using the `igraph` package. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_df_linA <- select(grn_table_linA, \n                        Tx_Factor, \n                        Target_Gene,\n                        Frequency, \n                        State) %>% \n                 arrange(Tx_Factor, desc(Frequency)) %>% \n                 with_groups(Tx_Factor,\n                             slice_head, \n                             n = 10)\ngraph_obj_linA <- graph.data.frame(graph_df_linA, directed = TRUE)\ngraph_df_linB <- select(grn_table_linB, \n                        Tx_Factor, \n                        Target_Gene,\n                        Frequency, \n                        State) %>% \n                 arrange(Tx_Factor, desc(Frequency)) %>% \n                 with_groups(Tx_Factor,\n                             slice_head, \n                             n = 10)\ngraph_obj_linB <- graph.data.frame(graph_df_linB, directed = TRUE)\ngraph_df_linC <- select(grn_table_linC, \n                        Tx_Factor, \n                        Target_Gene,\n                        Frequency, \n                        State) %>% \n                 arrange(Tx_Factor, desc(Frequency)) %>% \n                 with_groups(Tx_Factor,\n                             slice_head, \n                             n = 10)\ngraph_obj_linC <- graph.data.frame(graph_df_linC, directed = TRUE)\n```\n:::\n\n\nOne TF of particular interest is SRY-box transcription factor 4 (*SOX4*). This TF helps to regulate development and is involved in the specification of cell fate, so a comparison of its behavior across lineages should be pretty neat. We use a Fruchterman-Reingold layout to embed the graphs in 2D space via the `layout_with_fr()` function from `igraph`. We see that not only do the top target genes differ widely by lineage, so too do the directions of the relationships (activation vs. repression), and the strengths of those relationships. For example, in lineage A the top target gene is BACE2, whereas for lineage B it's LINC01268. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1)\nfreqs <- purrr::map(list(graph_df_linA, graph_df_linB, graph_df_linC), \\(x) {\n  filter(x, Tx_Factor == \"SOX4\") %>% \n  pull(Frequency)\n})\nfreq_min <- min(purrr::reduce(freqs, c))\nfreq_max <- max(purrr::reduce(freqs, c))\np11 <- fortify(graph_obj_linA, \n               layout = layout_with_fr(graph = graph_obj_linA, \n                                       grid = \"nogrid\", \n                                       weights = E(graph_obj_linA)$weights^3),\n               arrow.gap = .02) %>% \n       mutate(Gene_Type = if_else(name %in% hs_tfs$hgnc_symbol, \"TF\", \"Target Gene\")) %>% \n       filter(name %in% (filter(graph_df_linA, Tx_Factor == \"SOX4\") %>% pull(Target_Gene)) | name == \"SOX4\") %>% \n       ggplot(aes(x = x, y = y, xend = xend, yend = yend)) + \n       facet_wrap(~\"Lineage A\") + \n       geom_edges(aes(linewidth = Frequency, alpha = Frequency, color = State), \n                  arrow = arrow(length = unit(8, \"pt\"), type = \"closed\")) + \n       geom_nodelabel(aes(label = name, fill = Gene_Type), \n                      size = 5) + \n       scale_color_manual(values = c(\"forestgreen\", \"firebrick\")) + \n       scale_fill_manual(values = c(\"darkorange2\", \"dodgerblue3\")) + \n       scale_linewidth_continuous(range = c(0.5, 1.5), limits = c(freq_min, freq_max)) + \n       scale_alpha_continuous(range = c(0.75, 1), limits = c(freq_min, freq_max)) + \n       labs(x = \"FR 1\", \n            y = \"FR 2\", \n            color = \"TF State\", \n            fill = \"Gene Type\") + \n       theme_scLANE(umap = TRUE) + \n       guides(fill = guide_legend(override.aes = list(label = \"\"), order = 1), \n              color = guide_legend(order = 2))\np12 <- fortify(graph_obj_linB, \n               layout = layout_with_fr(graph = graph_obj_linB, \n                                       grid = \"nogrid\", \n                                       weights = E(graph_obj_linB)$weights^3),\n               arrow.gap = .02) %>% \n       mutate(Gene_Type = if_else(name %in% hs_tfs$hgnc_symbol, \"TF\", \"Target Gene\")) %>% \n       filter(name %in% (filter(graph_df_linB, Tx_Factor == \"SOX4\") %>% pull(Target_Gene)) | name == \"SOX4\") %>% \n       ggplot(aes(x = x, y = y, xend = xend, yend = yend)) + \n       facet_wrap(~\"Lineage B\") + \n       geom_edges(aes(linewidth = Frequency, alpha = Frequency, color = State), \n                  arrow = arrow(length = unit(8, \"pt\"), type = \"closed\")) + \n       geom_nodelabel(aes(label = name, fill = Gene_Type), \n                      size = 5) + \n       scale_color_manual(values = c(\"forestgreen\", \"firebrick\")) + \n       scale_fill_manual(values = c(\"darkorange2\", \"dodgerblue3\")) + \n       scale_linewidth_continuous(range = c(0.5, 1.5), limits = c(freq_min, freq_max)) + \n       scale_alpha_continuous(range = c(0.75, 1), limits = c(freq_min, freq_max)) + \n       labs(x = \"FR 1\", \n            y = \"FR 2\", \n            color = \"TF State\", \n            fill = \"Gene Type\") + \n       theme_scLANE(umap = TRUE) + \n       guides(fill = guide_legend(override.aes = list(label = \"\"), order = 1), \n              color = guide_legend(order = 2))\np13 <- fortify(graph_obj_linC, \n               layout = layout_with_fr(graph = graph_obj_linC, \n                                       grid = \"nogrid\", \n                                       weights = E(graph_obj_linC)$weights^3),\n               arrow.gap = .02) %>% \n       mutate(Gene_Type = if_else(name %in% hs_tfs$hgnc_symbol, \"TF\", \"Target Gene\")) %>% \n       filter(name %in% (filter(graph_df_linC, Tx_Factor == \"SOX4\") %>% pull(Target_Gene)) | name == \"SOX4\") %>% \n       ggplot(aes(x = x, y = y, xend = xend, yend = yend)) + \n       facet_wrap(~\"Lineage C\") + \n       geom_edges(aes(linewidth = Frequency, alpha = Frequency, color = State), \n                  arrow = arrow(length = unit(8, \"pt\"), type = \"closed\")) + \n       geom_nodelabel(aes(label = name, fill = Gene_Type), \n                      size = 5) + \n       scale_color_manual(values = c(\"forestgreen\", \"firebrick\")) + \n       scale_fill_manual(values = c(\"darkorange2\", \"dodgerblue3\")) + \n       scale_linewidth_continuous(range = c(0.5, 1.5), limits = c(freq_min, freq_max)) + \n       scale_alpha_continuous(range = c(0.75, 1), limits = c(freq_min, freq_max)) + \n       labs(x = \"FR 1\", \n            y = \"FR 2\", \n            color = \"TF State\", \n            fill = \"Gene Type\") + \n       theme_scLANE(umap = TRUE) + \n       guides(fill = guide_legend(override.aes = list(label = \"\"), order = 1), \n              color = guide_legend(order = 2))\np14 <- (p11 / p12 / p13) + plot_layout(guides = \"collect\")\np14\n```\n\n::: {.cell-output-display}\n![Fruchterman-Reingold embeddings of the relationships between SRY-box transcription factor 4 and lineage-specific target genes](Trajectory_GRN_files/figure-html/fig-FR_embed-1.png){#fig-FR_embed width=960}\n:::\n:::\n\n\n# Conclusions {#sec-conclusions}\n\nHopefully this analysis has demonstrated the utility of trajectory GRNs for comparing gene dynamics across lineages. Beyond just visual comparison of how gene expression changes over pseudotime, trajectory GRNs allow us to identify which transcription factors are activating or suppressing target genes, how top TF targets differ between lineages, and the ways in which TF-target relationships change based on the cell fate towards which cells are progressing. To conclude, I've written up the methodology for creating a trajectory GRN into a function, which is shown in the code block below. It includes functionality for a progress bar if desired, and takes as input a matrix of gene dynamics (`expr.mat`), a set of dynamic genes (`dyn.genes`), and a set of transcription factors (`tx.factors`). Eventually I plan to expand this functionality and turn it into an R package, but for now it'll stay a simple function. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nestimateTGRN <- function(expr.mat = NULL,\n                         dyn.genes = NULL, \n                         tx.factors = NULL, \n                         log1p.norm = TRUE,\n                         cor.method = \"spearman\",\n                         n.cores = 4L, \n                         verbose = TRUE, \n                         random.seed = 312) {\n  # check inputs \n  if (is.null(expr.mat) || is.null(dyn.genes) || is.null(tx.factors)) { stop(\"Arguments to estimateTGRN() are missing.\") }\n  # ID non-TF genes & filter out non-dynamic TFs\n  target_genes <- dyn.genes[!dyn.genes %in% tx.factors]\n  tx.factors <- tx.factors[tx.factors %in% dyn.genes]\n  # normalize matrix of dynamics\n  if (log1p.norm) {\n    expr.mat <- log1p(expr.mat)\n  }\n  # set up progress bar\n  if (verbose) {\n    withr::with_output_sink(tempfile(), {\n      pb <- utils::txtProgressBar(0, length(target_genes), style = 3)\n    })\n    progress_fun <- function(n) utils::setTxtProgressBar(pb, n)\n    snow_opts <- list(progress = progress_fun)\n  } else {\n    snow_opts <- list()\n  }\n  # set up parallel processing\n  if (n.cores > 1L) {\n    cl <- parallel::makeCluster(6L)\n    doSNOW::registerDoSNOW(cl)\n  } else {\n    cl <- foreach::registerDoSEQ()\n  }\n  # set up LightGBM model settings\n  lgbm_params <- list(objective = \"gamma\", \n                      tree_learner = \"serial\", \n                      metric = \"l2\", \n                      boosting_type = \"gbdt\", \n                      num_threads = 1L, \n                      seed = random.seed)\n  # estimate trajectory GRN\n  grn_res <- foreach::foreach(g = seq(target_genes), \n                              .combine = \"list\",\n                              .multicombine = ifelse(length(target_genes) > 1, TRUE, FALSE),\n                              .maxcombine = ifelse(length(target_genes) > 1, length(target_genes), 2),\n                              .packages = c(\"lightgbm\", \"dplyr\"),\n                              .export = c(\"expr.mat\", \"tx.factors\", \"target_genes\", \"lgbm_params\"), \n                              .errorhandling = \"pass\",\n                              .inorder = TRUE,\n                              .verbose = FALSE,\n                              .options.snow = snow_opts) %dopar% {\n                                feature_mat <- expr.mat[, tx.factors]\n                                resp_var <- expr.mat[, target_genes[g]]\n                                lgbm_data <- lightgbm::lgb.Dataset(data = feature_mat, label = resp_var)\n                                lgbm_cv <- lightgbm::lgb.cv(params = lgbm_params, \n                                                            data = lgbm_data, \n                                                            nrounds = 100L, \n                                                            nfold = 5L, \n                                                            stratified = FALSE)\n                                lgbm_model <- lightgbm::lgb.train(params = lgbm_params, \n                                                                  data = lgbm_data, \n                                                                  nrounds = lgbm_cv$best_iter)\n                                imp_table <- as.data.frame(lightgbm::lgb.importance(lgbm_model)) %>% \n                                             dplyr::mutate(Target_Gene = target_genes[g], .before = 1)\n                                imp_table\n                              }\n  names(grn_res) <- target_genes\n  if (n.cores > 1L) {\n    parallel::stopCluster(cl)\n  }\n  # format GRN table\n  grn_table <- purrr::imap(grn_res, \\(x, y) {\n    if (!inherits(x, \"data.frame\")) {\n      empty_res <- data.frame(Target_Gene = y, \n                              Feature = NA_character_, \n                              Gain = NA_real_, \n                              Cover = NA_real_, \n                              Frequency = NA_real_)\n      return(empty_res)\n    } else {\n      return(x)\n    }\n  })\n  grn_table <- purrr::reduce(grn_table, rbind) %>% \n               dplyr::rename(Tx_Factor = Feature) %>% \n               dplyr::filter(!is.na(Target_Gene), \n                             !is.na(Tx_Factor))\n  # add correlation b/t TF and each target gene \n  dyn_cormat <- stats::cor(expr.mat[, dyn.genes], method = cor.method)\n  grn_table <- dplyr::mutate(grn_table, Dyn_Cor = NA_real_)\n  for (i in seq(nrow(grn_table))) {\n    grn_table$Dyn_Cor[i] <- dyn_cormat[grn_table$Target_Gene[i], grn_table$Tx_Factor[i]]\n  }\n  grn_table <- dplyr::mutate(grn_table, State = dplyr::if_else(Dyn_Cor < 0, \"Repression\", \"Activation\"))\n  return(grn_table)\n}\n```\n:::\n\n\n# Session info {#sec-SI}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Session info \n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1.2\n system   x86_64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2024-01-21\n pandoc   3.1.9 @ /usr/local/bin/ (via rmarkdown)\n\n Packages \n package                * version    date (UTC) lib source\n abind                    1.4-5      2016-07-21 [1] CRAN (R 4.3.0)\n AnnotationDbi            1.64.1     2023-11-03 [1] Bioconductor\n AnnotationFilter         1.26.0     2023-10-24 [1] Bioconductor\n AnnotationHub            3.10.0     2023-10-24 [1] Bioconductor\n backports                1.4.1      2021-12-13 [1] CRAN (R 4.3.0)\n beeswarm                 0.4.0      2021-06-01 [1] CRAN (R 4.3.0)\n bigassertr               0.1.6      2023-01-10 [1] CRAN (R 4.3.0)\n bigparallelr             0.3.2      2021-10-02 [1] CRAN (R 4.3.0)\n bigstatsr                1.5.12     2022-10-14 [1] CRAN (R 4.3.0)\n Biobase                * 2.62.0     2023-10-24 [1] Bioconductor\n BiocFileCache            2.10.1     2023-10-26 [1] Bioconductor\n BiocGenerics           * 0.48.1     2023-11-01 [1] Bioconductor\n BiocIO                   1.12.0     2023-10-24 [1] Bioconductor\n BiocManager              1.30.22    2023-08-08 [1] CRAN (R 4.3.0)\n BiocParallel             1.36.0     2023-10-24 [1] Bioconductor\n BiocVersion              3.18.1     2023-11-15 [1] Bioconductor\n biomaRt                * 2.58.0     2023-10-24 [1] Bioconductor\n Biostrings               2.70.1     2023-10-25 [1] Bioconductor\n bit                      4.0.5      2022-11-15 [1] CRAN (R 4.3.0)\n bit64                    4.0.5      2020-08-30 [1] CRAN (R 4.3.0)\n bitops                   1.0-7      2021-04-24 [1] CRAN (R 4.3.0)\n blob                     1.2.4      2023-03-17 [1] CRAN (R 4.3.0)\n boot                     1.3-28.1   2022-11-22 [1] CRAN (R 4.3.2)\n broom                    1.0.5      2023-06-09 [1] CRAN (R 4.3.0)\n broom.mixed              0.2.9.4    2022-04-17 [1] CRAN (R 4.3.0)\n cachem                   1.0.8      2023-05-01 [1] CRAN (R 4.3.0)\n car                      3.1-2      2023-03-30 [1] CRAN (R 4.3.0)\n carData                  3.0-5      2022-01-06 [1] CRAN (R 4.3.0)\n cli                      3.6.2      2023-12-11 [1] CRAN (R 4.3.0)\n cluster                  2.1.6      2023-12-01 [1] CRAN (R 4.3.0)\n codetools                0.2-19     2023-02-01 [1] CRAN (R 4.3.2)\n colorspace               2.1-0      2023-01-23 [1] CRAN (R 4.3.0)\n cowplot                  1.1.2      2023-12-15 [1] CRAN (R 4.3.0)\n crayon                   1.5.2      2022-09-29 [1] CRAN (R 4.3.0)\n curl                     5.2.0      2023-12-08 [1] CRAN (R 4.3.0)\n data.table               1.14.10    2023-12-08 [1] CRAN (R 4.3.0)\n DBI                      1.2.0      2023-12-21 [1] CRAN (R 4.3.0)\n dbplyr                   2.4.0      2023-10-26 [1] CRAN (R 4.3.0)\n DelayedArray             0.28.0     2023-10-24 [1] Bioconductor\n DelayedMatrixStats       1.24.0     2023-10-24 [1] Bioconductor\n deldir                   2.0-2      2023-11-23 [1] CRAN (R 4.3.0)\n digest                   0.6.33     2023-07-07 [1] CRAN (R 4.3.0)\n doParallel               1.0.17     2022-02-07 [1] CRAN (R 4.3.0)\n doSNOW                   1.0.20     2022-02-04 [1] CRAN (R 4.3.0)\n dotCall64                1.1-1      2023-11-28 [1] CRAN (R 4.3.0)\n dplyr                  * 1.1.4      2023-11-17 [1] CRAN (R 4.3.0)\n ellipsis                 0.3.2      2021-04-29 [1] CRAN (R 4.3.0)\n ensembldb                2.26.0     2023-10-24 [1] Bioconductor\n evaluate                 0.23       2023-11-01 [1] CRAN (R 4.3.0)\n ExperimentHub            2.10.0     2023-10-24 [1] Bioconductor\n fansi                    1.0.6      2023-12-08 [1] CRAN (R 4.3.0)\n farver                   2.1.1      2022-07-06 [1] CRAN (R 4.3.0)\n fastDummies              1.7.3      2023-07-06 [1] CRAN (R 4.3.0)\n fastmap                  1.1.1      2023-02-24 [1] CRAN (R 4.3.0)\n ff                       4.0.9      2023-01-25 [1] CRAN (R 4.3.0)\n filelock                 1.0.3      2023-12-11 [1] CRAN (R 4.3.0)\n fitdistrplus             1.1-11     2023-04-25 [1] CRAN (R 4.3.0)\n flock                    0.7        2016-11-12 [1] CRAN (R 4.3.0)\n forcats                  1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n foreach                * 1.5.2      2022-02-02 [1] CRAN (R 4.3.0)\n furrr                    0.3.1      2022-08-15 [1] CRAN (R 4.3.0)\n future                   1.33.1     2023-12-22 [1] CRAN (R 4.3.0)\n future.apply             1.11.1     2023-12-21 [1] CRAN (R 4.3.0)\n gamlss                   5.4-20     2023-10-04 [1] CRAN (R 4.3.0)\n gamlss.data              6.0-2      2021-11-07 [1] CRAN (R 4.3.0)\n gamlss.dist              6.1-1      2023-08-23 [1] CRAN (R 4.3.0)\n geeM                     0.10.1     2018-06-18 [1] CRAN (R 4.3.0)\n generics                 0.1.3      2022-07-05 [1] CRAN (R 4.3.0)\n GenomeInfoDb           * 1.38.5     2023-12-28 [1] Bioconductor 3.18 (R 4.3.2)\n GenomeInfoDbData         1.2.11     2023-12-22 [1] Bioconductor\n GenomicAlignments        1.38.0     2023-10-24 [1] Bioconductor\n GenomicFeatures          1.54.1     2023-10-29 [1] Bioconductor\n GenomicRanges          * 1.54.1     2023-10-29 [1] Bioconductor\n ggbeeswarm               0.7.2      2023-04-29 [1] CRAN (R 4.3.0)\n ggnetwork              * 0.5.12     2023-03-06 [1] CRAN (R 4.3.0)\n ggplot2                * 3.4.4      2023-10-12 [1] CRAN (R 4.3.0)\n ggpubr                   0.6.0      2023-02-10 [1] CRAN (R 4.3.0)\n ggrepel                  0.9.4      2023-10-13 [1] CRAN (R 4.3.0)\n ggridges                 0.5.5      2023-12-15 [1] CRAN (R 4.3.0)\n ggsignif                 0.6.4      2022-10-13 [1] CRAN (R 4.3.0)\n glm2                   * 1.2.1      2018-08-11 [1] CRAN (R 4.3.0)\n glmmTMB                  1.1.8      2023-10-07 [1] CRAN (R 4.3.0)\n globals                  0.16.2     2022-11-21 [1] CRAN (R 4.3.0)\n glue                     1.6.2      2022-02-24 [1] CRAN (R 4.3.0)\n goftest                  1.2-3      2021-10-07 [1] CRAN (R 4.3.0)\n gridExtra                2.3        2017-09-09 [1] CRAN (R 4.3.0)\n gtable                   0.3.4      2023-08-21 [1] CRAN (R 4.3.0)\n highr                    0.10       2022-12-22 [1] CRAN (R 4.3.0)\n hms                      1.1.3      2023-03-21 [1] CRAN (R 4.3.0)\n htmltools                0.5.7      2023-11-03 [1] CRAN (R 4.3.0)\n htmlwidgets              1.6.4      2023-12-06 [1] CRAN (R 4.3.0)\n httpuv                   1.6.13     2023-12-06 [1] CRAN (R 4.3.0)\n httr                     1.4.7      2023-08-15 [1] CRAN (R 4.3.0)\n ica                      1.0-3      2022-07-08 [1] CRAN (R 4.3.0)\n igraph                 * 1.6.0      2023-12-11 [1] CRAN (R 4.3.0)\n interactiveDisplayBase   1.40.0     2023-10-24 [1] Bioconductor\n IRanges                * 2.36.0     2023-10-24 [1] Bioconductor\n irlba                    2.3.5.1    2022-10-03 [1] CRAN (R 4.3.0)\n iterators                1.0.14     2022-02-05 [1] CRAN (R 4.3.0)\n janitor                  2.2.0      2023-02-02 [1] CRAN (R 4.3.0)\n jsonlite                 1.8.8      2023-12-04 [1] CRAN (R 4.3.0)\n kableExtra               1.3.4      2021-02-20 [1] CRAN (R 4.3.0)\n KEGGREST                 1.42.0     2023-10-24 [1] Bioconductor\n KernSmooth               2.23-22    2023-07-10 [1] CRAN (R 4.3.2)\n knitr                    1.45       2023-10-30 [1] CRAN (R 4.3.0)\n labeling                 0.4.3      2023-08-29 [1] CRAN (R 4.3.0)\n later                    1.3.2      2023-12-06 [1] CRAN (R 4.3.0)\n lattice                  0.22-5     2023-10-24 [1] CRAN (R 4.3.0)\n lazyeval                 0.2.2      2019-03-15 [1] CRAN (R 4.3.0)\n leiden                   0.4.3.1    2023-11-17 [1] CRAN (R 4.3.0)\n lifecycle                1.0.4      2023-11-07 [1] CRAN (R 4.3.0)\n limma                    3.58.1     2023-10-31 [1] Bioconductor\n listenv                  0.9.0      2022-12-16 [1] CRAN (R 4.3.0)\n lme4                     1.1-35.1   2023-11-05 [1] CRAN (R 4.3.0)\n lmtest                   0.9-40     2022-03-21 [1] CRAN (R 4.3.0)\n lubridate                1.9.3      2023-09-27 [1] CRAN (R 4.3.0)\n magrittr               * 2.0.3      2022-03-30 [1] CRAN (R 4.3.0)\n MASS                     7.3-60     2023-05-04 [1] CRAN (R 4.3.0)\n Matrix                   1.6-4      2023-11-30 [1] CRAN (R 4.3.0)\n MatrixGenerics         * 1.14.0     2023-10-24 [1] Bioconductor\n matrixStats            * 1.2.0      2023-12-11 [1] CRAN (R 4.3.0)\n memoise                  2.0.1      2021-11-26 [1] CRAN (R 4.3.0)\n mgcv                     1.9-1      2023-12-21 [1] CRAN (R 4.3.0)\n mime                     0.12       2021-09-28 [1] CRAN (R 4.3.0)\n miniUI                   0.1.1.1    2018-05-18 [1] CRAN (R 4.3.0)\n minqa                    1.2.6      2023-09-11 [1] CRAN (R 4.3.0)\n munsell                  0.5.0      2018-06-12 [1] CRAN (R 4.3.0)\n nlme                     3.1-164    2023-11-27 [1] CRAN (R 4.3.0)\n nloptr                   2.0.3      2022-05-26 [1] CRAN (R 4.3.0)\n numDeriv                 2016.8-1.1 2019-06-06 [1] CRAN (R 4.3.0)\n paletteer                1.5.0      2022-10-19 [1] CRAN (R 4.3.0)\n parallelly               1.36.0     2023-05-26 [1] CRAN (R 4.3.0)\n patchwork              * 1.1.3      2023-08-14 [1] CRAN (R 4.3.0)\n pbapply                  1.7-2      2023-06-27 [1] CRAN (R 4.3.0)\n pillar                   1.9.0      2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig                2.0.3      2019-09-22 [1] CRAN (R 4.3.0)\n plotly                   4.10.3     2023-10-21 [1] CRAN (R 4.3.0)\n plyr                     1.8.9      2023-10-02 [1] CRAN (R 4.3.0)\n png                      0.1-8      2022-11-29 [1] CRAN (R 4.3.0)\n polyclip                 1.10-6     2023-09-27 [1] CRAN (R 4.3.0)\n presto                   1.0.0      2023-12-27 [1] Github (immunogenomics/presto@31dc97f)\n prettyunits              1.2.0      2023-09-24 [1] CRAN (R 4.3.0)\n princurve              * 2.1.6      2021-01-18 [1] CRAN (R 4.3.0)\n prismatic                1.1.1      2022-08-15 [1] CRAN (R 4.3.0)\n progress                 1.2.3      2023-12-06 [1] CRAN (R 4.3.0)\n progressr                0.14.0     2023-08-10 [1] CRAN (R 4.3.0)\n promises                 1.2.1      2023-08-10 [1] CRAN (R 4.3.0)\n ProtGenerics             1.34.0     2023-10-24 [1] Bioconductor\n ps                       1.7.5      2023-04-18 [1] CRAN (R 4.3.0)\n purrr                    1.0.2      2023-08-10 [1] CRAN (R 4.3.0)\n R6                       2.5.1      2021-08-19 [1] CRAN (R 4.3.0)\n RANN                     2.6.1      2019-01-08 [1] CRAN (R 4.3.0)\n rappdirs                 0.3.3      2021-01-31 [1] CRAN (R 4.3.0)\n RColorBrewer             1.1-3      2022-04-03 [1] CRAN (R 4.3.0)\n Rcpp                     1.0.11     2023-07-06 [1] CRAN (R 4.3.0)\n RcppAnnoy                0.0.21     2023-07-02 [1] CRAN (R 4.3.0)\n RcppEigen                0.3.3.9.4  2023-11-02 [1] CRAN (R 4.3.0)\n RcppHNSW                 0.5.0      2023-09-19 [1] CRAN (R 4.3.0)\n RCurl                    1.98-1.13  2023-11-02 [1] CRAN (R 4.3.0)\n readr                    2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n rematch2                 2.1.2      2020-05-01 [1] CRAN (R 4.3.0)\n reshape2                 1.4.4      2020-04-09 [1] CRAN (R 4.3.0)\n restfulr                 0.0.15     2022-06-16 [1] CRAN (R 4.3.0)\n reticulate               1.34.0     2023-10-12 [1] CRAN (R 4.3.0)\n rjson                    0.2.21     2022-01-09 [1] CRAN (R 4.3.0)\n rlang                    1.1.2      2023-11-04 [1] CRAN (R 4.3.0)\n rmarkdown                2.25       2023-09-18 [1] CRAN (R 4.3.0)\n rmio                     0.4.0      2022-02-17 [1] CRAN (R 4.3.0)\n ROCR                     1.0-11     2020-05-02 [1] CRAN (R 4.3.0)\n Rsamtools                2.18.0     2023-10-24 [1] Bioconductor\n RSpectra                 0.16-1     2022-04-24 [1] CRAN (R 4.3.0)\n RSQLite                  2.3.4      2023-12-08 [1] CRAN (R 4.3.0)\n rstatix                  0.7.2      2023-02-01 [1] CRAN (R 4.3.0)\n rstudioapi               0.15.0     2023-07-07 [1] CRAN (R 4.3.0)\n rtracklayer              1.62.0     2023-10-24 [1] Bioconductor\n Rtsne                    0.17       2023-12-07 [1] CRAN (R 4.3.0)\n rvest                    1.0.3      2022-08-19 [1] CRAN (R 4.3.0)\n S4Arrays                 1.2.0      2023-10-24 [1] Bioconductor\n S4Vectors              * 0.40.2     2023-11-23 [1] Bioconductor\n scales                   1.3.0      2023-11-28 [1] CRAN (R 4.3.0)\n scattermore              1.2        2023-06-12 [1] CRAN (R 4.3.0)\n scLANE                 * 0.7.9      2024-01-07 [1] Bioconductor\n scRNAseq               * 2.16.0     2023-10-26 [1] Bioconductor\n sctransform              0.4.1      2023-10-19 [1] CRAN (R 4.3.0)\n sessioninfo              1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n Seurat                 * 5.0.1      2023-11-17 [1] CRAN (R 4.3.0)\n SeuratObject           * 5.0.1      2023-11-17 [1] CRAN (R 4.3.0)\n shiny                    1.8.0      2023-11-17 [1] CRAN (R 4.3.0)\n SingleCellExperiment   * 1.24.0     2023-10-24 [1] Bioconductor\n slingshot              * 2.10.0     2023-10-24 [1] Bioconductor\n snakecase                0.11.1     2023-08-27 [1] CRAN (R 4.3.0)\n snow                     0.4-4      2021-10-27 [1] CRAN (R 4.3.0)\n sp                     * 2.1-2      2023-11-26 [1] CRAN (R 4.3.0)\n spam                     2.10-0     2023-10-23 [1] CRAN (R 4.3.0)\n SparseArray              1.2.3      2023-12-25 [1] Bioconductor 3.18 (R 4.3.2)\n sparseMatrixStats        1.14.0     2023-10-24 [1] Bioconductor\n spatstat.data            3.0-3      2023-10-24 [1] CRAN (R 4.3.0)\n spatstat.explore         3.2-5      2023-10-22 [1] CRAN (R 4.3.0)\n spatstat.geom            3.2-7      2023-10-20 [1] CRAN (R 4.3.0)\n spatstat.random          3.2-2      2023-11-29 [1] CRAN (R 4.3.0)\n spatstat.sparse          3.0-3      2023-10-24 [1] CRAN (R 4.3.0)\n spatstat.utils           3.0-4      2023-10-24 [1] CRAN (R 4.3.0)\n statmod                  1.5.0      2023-01-06 [1] CRAN (R 4.3.0)\n stringi                  1.8.3      2023-12-11 [1] CRAN (R 4.3.0)\n stringr                  1.5.1      2023-11-14 [1] CRAN (R 4.3.0)\n SummarizedExperiment   * 1.32.0     2023-10-24 [1] Bioconductor\n survival                 3.5-7      2023-08-14 [1] CRAN (R 4.3.2)\n svglite                  2.1.3      2023-12-08 [1] CRAN (R 4.3.0)\n systemfonts              1.0.5      2023-10-09 [1] CRAN (R 4.3.0)\n tensor                   1.5        2012-05-05 [1] CRAN (R 4.3.0)\n tibble                   3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n tidyr                    1.3.0      2023-01-24 [1] CRAN (R 4.3.0)\n tidyselect               1.2.0      2022-10-10 [1] CRAN (R 4.3.0)\n timechange               0.2.0      2023-01-11 [1] CRAN (R 4.3.0)\n TMB                      1.9.10     2023-12-12 [1] CRAN (R 4.3.0)\n TrajectoryUtils        * 1.10.0     2023-10-24 [1] Bioconductor\n tzdb                     0.4.0      2023-05-12 [1] CRAN (R 4.3.0)\n utf8                     1.2.4      2023-10-22 [1] CRAN (R 4.3.0)\n uwot                     0.1.16     2023-06-29 [1] CRAN (R 4.3.0)\n vctrs                    0.6.5      2023-12-01 [1] CRAN (R 4.3.0)\n vipor                    0.4.7      2023-12-18 [1] CRAN (R 4.3.0)\n viridisLite              0.4.2      2023-05-02 [1] CRAN (R 4.3.0)\n vroom                    1.6.5      2023-12-05 [1] CRAN (R 4.3.0)\n webshot                  0.5.5      2023-06-26 [1] CRAN (R 4.3.0)\n withr                    2.5.2      2023-10-30 [1] CRAN (R 4.3.0)\n xfun                     0.41       2023-11-01 [1] CRAN (R 4.3.0)\n XML                      3.99-0.16  2023-11-29 [1] CRAN (R 4.3.0)\n xml2                     1.3.6      2023-12-04 [1] CRAN (R 4.3.0)\n xtable                   1.8-4      2019-04-21 [1] CRAN (R 4.3.0)\n XVector                  0.42.0     2023-10-24 [1] Bioconductor\n yaml                     2.3.8      2023-12-11 [1] CRAN (R 4.3.0)\n zlibbioc                 1.48.0     2023-10-24 [1] Bioconductor\n zoo                      1.8-12     2023-04-13 [1] CRAN (R 4.3.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/library\n\n Python configuration \n python:         /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/bin/python\n libpython:      /usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/lib/python3.11/config-3.11-darwin/libpython3.11.dylib\n pythonhome:     /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site:/Users/jack/Desktop/PhD/Research/Python_Envs/personal_site\n version:        3.11.6 (main, Nov  2 2023, 04:52:24) [Clang 14.0.3 (clang-1403.0.22.14.1)]\n numpy:          /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/lib/python3.11/site-packages/numpy\n numpy_version:  1.23.5\n leidenalg:      /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/lib/python3.11/site-packages/leidenalg\n \n NOTE: Python version was forced by use_python() function\n\n\n```\n\n\n:::\n:::\n",
    "supporting": [
      "Trajectory_GRN_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}