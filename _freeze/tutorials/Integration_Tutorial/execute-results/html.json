{
  "hash": "d0a9a996137f3964d6be5c139f35e6db",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Integrating scRNA-seq Datasets with Python\"\nauthor:\n  name: Jack Leary\n  email: j.leary@ufl.edu\n  orcid: 0009-0004-8821-3269\n  affiliations:\n    - name: University of Florida\n      department: Biostatistics \n      city: Gainesville\n      state: FL\ndate: today\nformat:\n  html:\n    code-fold: show\n    code-copy: true\n    code-tools: true\n    toc: true\n    embed-resources: true\n    fig-format: retina\n    df-print: kable\n    link-external-newwindow: true\n    fig-cap-location: bottom\n    fig-align: center\nexecute: \n  cache: false\n  freeze: auto\n---\n\n\n\n\n# Introduction\n\nThe need to integrate data from scRNA-seq samples into one harmonized dataset has increased in recent years as single cell sequencing has gotten cheaper, making it easier to collect data from multiple subjects, timepoints, or conditions. The goal of most integration techniques is to create an embedding that is (relatively) free of batch effects and that does not lead to the cells clustering by subject ID. There are many methods available to perform integration in both R & Python, and evaluating which method is \"best\" for your dataset can be tricky & subjective. In this tutorial we'll try out several of the integration methods available in the `scanpy` package and compare their results. We'll use a SmartSeq2 dataset containing myeloid cells from the developing human fetal liver that was originally analyzed in [Popescu *et al* (2020)](https://doi.org/10.1038/s41586-019-1652-y). As such, our goal will be to determine which integration method results in the best embedding for downstream trajectory analysis. In developmental biology settings, a \"good\" scRNA-seq integrated embedding is smoothly connected (i.e., no spaced-out, discrete clusters), and places celltypes in roughly the order expected based on known biology. \n\n# Libraries\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)       # dataframe tools\nlibrary(Matrix)      # sparse matrices\nlibrary(Seurat)      # scRNA-seq tools\nlibrary(ggplot2)     # plots\nlibrary(reticulate)  # Python interface\n```\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport scvi                          # VAE integration\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/lib/python3.11/site-packages/scvi/_settings.py:63: UserWarning: Since v1.0.0, scvi-tools no longer uses a random seed by default. Run `scvi.settings.seed = 0` to reproduce results from previous versions.\n  self.seed = seed\n/Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/lib/python3.11/site-packages/scvi/_settings.py:70: UserWarning: Setting `dl_pin_memory_gpu_training` is deprecated in v1.0 and will be removed in v1.1. Please pass in `pin_memory` to the data loaders instead.\n  self.dl_pin_memory_gpu_training = (\n```\n\n\n:::\n\n```{.python .cell-code}\nimport warnings                      # filter out warnings\nimport numpy as np                   # matrix utilities\nimport scanpy as sc                  # scRNA-seq processing\nimport pandas as pd                  # dataframe tools\nimport anndata as ad                 # scRNA-seq data structures\nimport matplotlib.pyplot as plt      # plot utilities\nfrom scipy.sparse import csr_matrix  # sparse matrices\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nwarnings.simplefilter('ignore', category=UserWarning)\n```\n:::\n\n\n# Theme for `matplotlib`\n\nHere we define a theme for `matplotlib` that mostly matches `ggplot2::theme_classic()`. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nbase_size = 12\nplt.rcParams.update({\n    # font\n    'font.size': base_size, \n    'font.weight': 'normal',\n    # figure\n    'figure.dpi': 300, \n    'figure.edgecolor': 'white', \n    'figure.facecolor': 'white', \n    'figure.figsize': (6, 4), \n    'figure.constrained_layout.use': True,\n    # axes\n    'axes.edgecolor': 'black',\n    'axes.grid': False,\n    'axes.labelpad': 2.75,\n    'axes.labelsize': base_size * 0.8,\n    'axes.linewidth': 1.5,\n    'axes.spines.right': False,\n    'axes.spines.top': False,\n    'axes.titlelocation': 'left',\n    'axes.titlepad': 11,\n    'axes.titlesize': base_size,\n    'axes.titleweight': 'normal',\n    'axes.xmargin': 0.1, \n    'axes.ymargin': 0.1, \n    # legend\n    'legend.borderaxespad': 1,\n    'legend.borderpad': 0.5,\n    'legend.columnspacing': 2,\n    'legend.fontsize': base_size * 0.8,\n    'legend.frameon': False,\n    'legend.handleheight': 1,\n    'legend.handlelength': 1.2,\n    'legend.labelspacing': 1,\n    'legend.title_fontsize': base_size, \n    'legend.markerscale': 1.25\n})\n```\n:::\n\n\n# Data \n\nWe'll start by reading in the SmartSeq2 scRNA-seq data from [Popescu *et al*](https://doi.org/10.1038/s41586-019-1652-y), which we downloaded from [the Human Developmental Cell Atlas portal](https://developmental.cellatlas.io/fetal-liver). Some massaging of the data is necessary to get it ready to pass into Python. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu_blood <- readRDS(\"../../datasets/fetal_liver_SS2.RDS\")\nclass(seu_blood) <- \"Seurat\"\nblood_counts <- as.matrix(seu_blood@raw.data)\nblood_counts <- blood_counts[, colnames(seu_blood@scale.data)]\ncell_metadata <- seu_blood@meta.data[colnames(seu_blood@scale.data), ] %>% \n                 mutate(cell = rownames(.), \n                        .before = 1)\ngene_metadata <- data.frame(gene = rownames(blood_counts))\n```\n:::\n\n\n# Read data into Python\n\nUsing the `reticulate` R package we transfer our raw counts matrix and cell & gene metadata into Python, then create an `AnnData` object. Lastly, we rename some cell metadata features and subset to just the macrophage development lineage. This will simplify our trajectory structure and make choosing a good integration / embedding combination easier. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nblood_counts = csr_matrix(r.blood_counts.transpose())\ncell_metadata = r.cell_metadata\ngene_metadata = r.gene_metadata\nad_blood = ad.AnnData(blood_counts)\nad_blood.obs_names = cell_metadata['cell']\nad_blood.var_names = gene_metadata['gene']\nad_blood.obs = cell_metadata\nad_blood.obs.rename(columns={'cell.labels': 'celltype', 'fetal.ids': 'fetal_ID', 'percent.mito': 'percent_MT', 'sort.ids': 'sort_ID'}, inplace=True)\nad_blood = ad_blood[ad_blood.obs['celltype'].isin(['HSC_MPP', 'Neutrophil-myeloid progenitor', 'Monocyte precursor', 'Monocyte', 'Mono-Mac', 'Kupffer Cell'])]\nad_blood.obs['celltype'] = (\n    ad_blood.obs['celltype']\n              .map(lambda x: {'HSC_MPP': 'HSC', 'Mono-Mac': 'Monocyte-macrophage', 'Kupffer Cell': 'Kupffer cell'}.get(x, x))\n              .astype('category')\n)\nad_blood.var = gene_metadata\nad_blood\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnnData object with n_obs × n_vars = 486 × 33660\n    obs: 'cell', 'nGene', 'nUMI', 'orig.ident', 'percent_MT', 'fetal_ID', 'sort_ID', 'tissue.id', 'plate.id', 'lanes', 'stages', 'sample.type', 'gender', 'cell.label', 'doublets', 'celltype'\n    var: 'gene'\n```\n\n\n:::\n:::\n\n\n# Preprocessing\n\nAfter removing cells classified as doublets by the original authors, we filter out low-depth cells and genes expressed in less than 10 cells. We then set up a new layer named **counts** containing the raw counts - this is necessary for integration with `scVI`, which takes as input the raw, unnormalized expression estimates. Lastly, we identify 3,000 HVGs and subset our object to just those genes. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nad_blood = ad_blood[ad_blood.obs['doublets'] == 'Singlet']\nsc.pp.filter_cells(ad_blood, min_counts=200)\nsc.pp.filter_genes(ad_blood, min_cells=10)\nad_blood.layers['counts'] = ad_blood.X.copy() \nad_blood.raw = ad_blood\nsc.pp.highly_variable_genes(\n    ad_blood, \n    n_top_genes=3000, \n    flavor='seurat_v3', \n    layer='counts',\n    subset=True\n)\n```\n:::\n\n\n# Integration with `scVI`\n\n[Paper](https://doi.org/10.1038/s41592-018-0229-2), [Docs](https://scvi-tools.org)\n\n## Train `scVI` model\n\nWe'll integrate across the ID specifying which fetus the cells came from. We also make `scVI` aware of our celltypes, and instruct it to regress out variation associated with the percentage of mitochondrial reads. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nscvi.settings.verbosity = 0\nscvi.settings.seed = 312\n```\n\n```{.python .cell-code}\nscvi.settings.num_threads = 4\nscvi.model.SCVI.setup_anndata(\n    ad_blood, \n    layer='counts', \n    batch_key='fetal_ID', \n    labels_key='celltype', \n    continuous_covariate_keys=['percent_MT']\n)\n```\n:::\n\n\nWe allow gene dispersion estimates to vary by celltype, and specify expression as following a negative-binomial distribution. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nint_model = scvi.model.SCVI(\n    ad_blood, \n    n_layers=3, \n    n_hidden=96, \n    n_latent=20, \n    gene_likelihood='nb', \n    dispersion='gene-label'\n)\n```\n:::\n\n\nFinally we train a variational autoencoder (VAE) over 250 epochs to embed the cells in 20-dimensional latent space.  \n \n\n::: {.cell}\n\n```{.python .cell-code}\nint_model.train(\n    early_stopping=True,\n    accelerator='cpu', \n    max_epochs=250, \n    train_size=0.8\n)\n```\n\n```{.python .cell-code}\nad_blood.obsm['X_scVI'] = int_model.get_latent_representation()\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_blood, \n    basis='scVI', \n    color='celltype',\n    title='', \n    frameon=True, \n    size=30, \n    alpha=0.75, \n    show=False\n)\nplt.gca().set_xlabel('scVI 1')\nplt.gca().set_ylabel('scVI 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![scVI embedding](Integration_Tutorial_files/figure-html/fig-scvi_embed-1.png){#fig-scvi_embed width=576}\n:::\n:::\n\n\n## SNN graph estimation\n\nWe use the cosine distance to identify 20 NNs for each cell in the latent `scVI` space. This neighbor graph will serve as the basis for our nonlinear embeddings. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.pp.neighbors(\n    ad_blood, \n    n_neighbors=20,\n    n_pcs=None,  \n    metric='cosine', \n    random_state=312, \n    use_rep='X_scVI'\n)\n```\n:::\n\n\n## UMAP embedding\n\nUsing default parameters, we fit a 2D UMAP embedding. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.umap(ad_blood, random_state=312)\n```\n:::\n\n\nThe UMAP embedding is a bit oddly-shaped, but celltypes are well-connected and their progression follows known biology i.e., HSCs form precursor populations which develop into mature monocytic cells. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_blood, \n    basis='umap', \n    color='celltype',\n    title='', \n    frameon=True, \n    size=30, \n    alpha=0.75, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![scVI-based UMAP embedding](Integration_Tutorial_files/figure-html/fig-umap_embed_scvi-3.png){#fig-umap_embed_scvi width=576}\n:::\n:::\n\n\n## Force-directed graph embedding\n\nWith the Fruchterman-Reingold algorithm we generate a force-directed graph embedding in 2 dimensions. In my experience this algorithm often works better than UMAP at preserving trajectory structures. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.draw_graph(\n    ad_blood, \n    layout='fr',  \n    random_state=312,\n    n_jobs=2\n)\n```\n:::\n\n\nSimilar to the UMAP embedding, the FR embedding is well-connected and the celltypes are arranged correctly. I like this embedding better, but that's mostly based on aesthetics as well as some intuition about how pseudotime estimation would perform on each. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.draw_graph(\n    ad_blood, \n    color='celltype', \n    title='', \n    alpha=0.75, \n    size=30, \n    show=False\n)\nplt.gca().set_xlabel('FR 1')\nplt.gca().set_ylabel('FR 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![scVI-based force-directed graph embedding](Integration_Tutorial_files/figure-html/fig-graph_embed_scvi-5.png){#fig-graph_embed_scvi width=576}\n:::\n:::\n\n\n## Diffusion map embedding\n\nLastly, we estimate a diffusion map embedding in 15 dimensions. This algorithm is specifically designed to preserve transitional structures, but in my experience it usually only works well on datasets with very simple trajectories. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.diffmap(\n    ad_blood, \n    random_state=312, \n    n_comps=16\n)\nad_blood.obsm['X_diffmap_old'] = ad_blood.obsm['X_diffmap']\nad_blood.obsm['X_diffmap'] = ad_blood.obsm['X_diffmap'][:, 1:] \n```\n:::\n\n\nLike the UMAP embedding the diffusion map embedding is pretty angular, but it recapitulates the biology well. Altogether, the `scVI` integration seems to have worked correctly as all embedding algorithms perform reasonably well. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.diffmap(\n    ad_blood, \n    color='celltype', \n    title='', \n    alpha=0.75, \n    size=30, \n    show=False\n)\nplt.gca().set_xlabel('DC 1')\nplt.gca().set_ylabel('DC 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![scVI-based diffusion map embedding](Integration_Tutorial_files/figure-html/fig-diffmap_embed_scvi-7.png){#fig-diffmap_embed_scvi width=576}\n:::\n:::\n\n\n# Integration with `Harmony`\n\n[Paper](https://doi.org/10.1038/s41592-019-0619-0), [Docs](https://github.com/slowkow/harmonypy)\n\n## Normalization\n\nThe `Harmony` algorithm works by \"correcting\" a principal component embedding for batch effects. As such, we need to first normalize and variance-stabilize the data. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.pp.normalize_total(ad_blood, target_sum=1e4)\nsc.pp.log1p(ad_blood)\n```\n:::\n\n\n## PCA embedding\n\nNext we scale the normalized counts and run PCA. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.pp.scale(ad_blood)\nsc.tl.pca(\n    ad_blood, \n    n_comps=30, \n    random_state=312, \n    use_highly_variable=True\n)\n```\n:::\n\n\nThe PCA embedding on its own is alright, and I don't imagine the integration procedure will change it much. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_blood, \n    basis='pca', \n    color='celltype', \n    title='', \n    frameon=True, \n    size=30, \n    alpha=0.75, \n    show=False\n)\nplt.gca().set_xlabel('PC 1')\nplt.gca().set_ylabel('PC 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![PCA embedding](Integration_Tutorial_files/figure-html/fig-pca_embed-9.png){#fig-pca_embed width=576}\n:::\n:::\n\n\n## PCA correction with `Harmony`\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.external.pp.harmony_integrate(ad_blood, key='fetal_ID')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2023-12-08 17:54:12,890 - harmonypy - INFO - Computing initial centroids with sklearn.KMeans...\n/Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/lib/python3.11/site-packages/threadpoolctl.py:1019: RuntimeWarning: libc not found. The ctypes module in Python 3.11 is maybe too old for this OS.\n  warnings.warn(\n2023-12-08 17:54:12,945 - harmonypy - INFO - sklearn.KMeans initialization complete.\n2023-12-08 17:54:12,946 - harmonypy - INFO - Iteration 1 of 10\n2023-12-08 17:54:12,992 - harmonypy - INFO - Iteration 2 of 10\n2023-12-08 17:54:13,037 - harmonypy - INFO - Iteration 3 of 10\n2023-12-08 17:54:13,081 - harmonypy - INFO - Iteration 4 of 10\n2023-12-08 17:54:13,127 - harmonypy - INFO - Iteration 5 of 10\n2023-12-08 17:54:13,171 - harmonypy - INFO - Converged after 5 iterations\n```\n\n\n:::\n:::\n\n\nAs expected, the corrected PCA space is pretty similar to the original one. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_blood, \n    basis='pca_harmony', \n    color='celltype', \n    title='', \n    frameon=True, \n    size=30, \n    alpha=0.75, \n    show=False\n)\nplt.gca().set_xlabel('Harmony 1')\nplt.gca().set_ylabel('Harmony 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Harmony embedding](Integration_Tutorial_files/figure-html/fig-harmony_embed-11.png){#fig-harmony_embed width=576}\n:::\n:::\n\n\n## SNN graph estimation\n\nWe compute $k = 20$ NNs in the `Harmony` PCA space. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.pp.neighbors(\n    ad_blood, \n    n_neighbors=20,\n    n_pcs=None,  \n    metric='cosine', \n    random_state=312, \n    use_rep='X_pca_harmony'\n)\n```\n:::\n\n\n## UMAP embedding\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.umap(ad_blood, random_state=312)\n```\n:::\n\n\nUh oh - the UMAP embedding displays disconnected clusters of cells. This indicates that the integration didn't perform very well, though other dimension reduction algorithms might perform better. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_blood, \n    basis='umap', \n    color='celltype',\n    title='', \n    frameon=True, \n    size=30, \n    alpha=0.75, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Harmony-based UMAP embedding](Integration_Tutorial_files/figure-html/fig-umap_embed_harmony-13.png){#fig-umap_embed_harmony width=576}\n:::\n:::\n\n\n## Force-directed graph embedding\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.draw_graph(\n    ad_blood, \n    layout='fr',  \n    random_state=312,\n    n_jobs=2\n)\n```\n:::\n\n\nThe FR embedding shows a disconnected cluster of monocytes as well. In addition, the progression from HSCs to progenitor / mature states is not well-represented. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.draw_graph(\n    ad_blood, \n    color='celltype', \n    title='', \n    alpha=0.75, \n    size=30, \n    show=False\n)\nplt.gca().set_xlabel('FR 1')\nplt.gca().set_ylabel('FR 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Harmony-based force-directed graph embedding](Integration_Tutorial_files/figure-html/fig-graph_embed_harmony-15.png){#fig-graph_embed_harmony width=576}\n:::\n:::\n\n\n## Diffusion map embedding\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.diffmap(\n    ad_blood, \n    random_state=312, \n    n_comps=16\n)\nad_blood.obsm['X_diffmap_old'] = ad_blood.obsm['X_diffmap']\nad_blood.obsm['X_diffmap'] = ad_blood.obsm['X_diffmap'][:, 1:] \n```\n:::\n\n\nThe diffusion map embedding is also fairly disconnected and has a tiny outlier cluster. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.diffmap(\n    ad_blood, \n    color='celltype', \n    title='', \n    alpha=0.75, \n    size=30, \n    show=False\n)\nplt.gca().set_xlabel('DC 1')\nplt.gca().set_ylabel('DC 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Harmony-based diffusion map embedding](Integration_Tutorial_files/figure-html/fig-diffmap_embed_harmony-17.png){#fig-diffmap_embed_harmony width=576}\n:::\n:::\n\n\n# Integration with `BBKNN`\n\n[Paper](https://doi.org/10.1093/bioinformatics/btz625), [Docs](https://github.com/Teichlab/bbknn)\n\n## Batch-specific SNN estimation\n\nNext we try the `BBKNN` algorithm which, instead of producing an integrated embedding (as do the other methods) produces a batch-corrected neighborhood graph. We can then use that graph structure to generate UMAP and other embeddings. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.external.pp.bbknn(\n  ad_blood, \n  batch_key='fetal_ID',\n  use_annoy=False,\n  metric='cosine',\n  pynndescent_random_state=312,\n  pynndescent_n_neighbors=20\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWARNING: consider updating your call to make use of `computation`\n```\n\n\n:::\n:::\n\n\n## UMAP embedding\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.umap(ad_blood, random_state=312)\n```\n:::\n\n\nThe UMAP is somewhat smoothly-connected, but the biological sequence of celltypes isn't correct. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_blood, \n    basis='umap', \n    color='celltype',\n    title='', \n    frameon=True, \n    size=30, \n    alpha=0.75, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![BBKNN-based UMAP embedding](Integration_Tutorial_files/figure-html/fig-umap_embed_bbknn-19.png){#fig-umap_embed_bbknn width=576}\n:::\n:::\n\n\n## Force-directed graph embedding\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.draw_graph(\n    ad_blood, \n    layout='fr',  \n    random_state=312,\n    n_jobs=2\n)\n```\n:::\n\n\nThe FR embedding suffers from the same issue. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.draw_graph(\n    ad_blood, \n    color='celltype', \n    title='', \n    alpha=0.75, \n    size=30, \n    show=False\n)\nplt.gca().set_xlabel('FR 1')\nplt.gca().set_ylabel('FR 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![BBKNN-based force-directed graph embedding](Integration_Tutorial_files/figure-html/fig-graph_embed_bbknn-21.png){#fig-graph_embed_bbknn width=576}\n:::\n:::\n\n\n## Diffusion map embedding\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.diffmap(\n    ad_blood, \n    random_state=312, \n    n_comps=16\n)\nad_blood.obsm['X_diffmap_old'] = ad_blood.obsm['X_diffmap']\nad_blood.obsm['X_diffmap'] = ad_blood.obsm['X_diffmap'][:, 1:] \n```\n:::\n\n\nThe diffusion map embedding also misplaces the monocyte phenotype. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.diffmap(\n    ad_blood, \n    color='celltype', \n    title='', \n    alpha=0.75, \n    size=30, \n    show=False\n)\nplt.gca().set_xlabel('DC 1')\nplt.gca().set_ylabel('DC 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![BBKNN-based diffusion map embedding](Integration_Tutorial_files/figure-html/fig-diffmap_embed_bbknn-23.png){#fig-diffmap_embed_bbknn width=576}\n:::\n:::\n\n\n# Integration with `Scanorama`\n\n[Paper](https://doi.org/10.1038/s41587-019-0113-3), [Docs](https://github.com/brianhie/scanorama)\n\n## Batch-correcting integration\n\nThe last method we'll try is `Scanorama`. Like `scVi` and `Harmony` this algorithm produces a corrected low-dimensional embedding. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.external.pp.scanorama_integrate(\n  ad_blood, \n  key='fetal_ID', \n  basis='X_pca', \n  knn=20\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[0. 1.]\n [0. 0.]]\nProcessing datasets F11_female_12+3PCW <=> F17_male_9+1PCW\n```\n\n\n:::\n:::\n\n\n## SNN graph estimation\n\nWe identify $k = 20$ NNs in the integrated space. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.pp.neighbors(\n    ad_blood, \n    n_neighbors=20,\n    n_pcs=None,  \n    metric='cosine', \n    random_state=312, \n    use_rep='X_scanorama'\n)\n```\n:::\n\n\n## UMAP embedding\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.umap(ad_blood, random_state=312)\n```\n:::\n\n\nWith UMAP the celltype progression is represented correctly, though the transition from the monocyte-macrophage phenotype to the mature Kupffer cells is a bit wonky. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_blood, \n    basis='umap', \n    color='celltype',\n    title='', \n    frameon=True, \n    size=30, \n    alpha=0.75, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Scanorama-based UMAP embedding](Integration_Tutorial_files/figure-html/fig-umap_embed_scanorama-25.png){#fig-umap_embed_scanorama width=576}\n:::\n:::\n\n\n## Force-directed graph embedding\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.draw_graph(\n    ad_blood, \n    layout='fr',  \n    random_state=312,\n    n_jobs=2\n)\n```\n:::\n\n\nThe FR embedding is a bit worse and isn't very smoothly connected. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.draw_graph(\n    ad_blood, \n    color='celltype', \n    title='', \n    alpha=0.75, \n    size=30, \n    show=False\n)\nplt.gca().set_xlabel('FR 1')\nplt.gca().set_ylabel('FR 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Harmony-based force-directed graph embedding](Integration_Tutorial_files/figure-html/fig-graph_embed_scanorama-27.png){#fig-graph_embed_scanorama width=576}\n:::\n:::\n\n\n## Diffusion map embedding\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.diffmap(\n    ad_blood, \n    random_state=312, \n    n_comps=16\n)\nad_blood.obsm['X_diffmap_old'] = ad_blood.obsm['X_diffmap']\nad_blood.obsm['X_diffmap'] = ad_blood.obsm['X_diffmap'][:, 1:] \n```\n:::\n\n\nThe diffusion map embedding is mostly OK, but there's a weird outlier cluster of monocytes located at the minimum of the first component. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.diffmap(\n    ad_blood, \n    color='celltype', \n    title='', \n    alpha=0.75, \n    size=30, \n    show=False\n)\nplt.gca().set_xlabel('DC 1')\nplt.gca().set_ylabel('DC 2')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Scanorama-based diffusion map embedding](Integration_Tutorial_files/figure-html/fig-diffmap_embed_scanorama-29.png){#fig-diffmap_embed_scanorama width=576}\n:::\n:::\n\n\n# Conclusions\n\nOverall, it seems that the `scVI` latent representation of the data performed the best. As for embeddings of that integrated space, I would probably choose the force-directed graph layout, though UMAP also performed well. The primary drawback of this method isn't readily apparent with this dataset - computation time. I've experienced long runtimes (1h+) on even medium-sized datasets of around 25-40k cells. This can make it difficult to experiment and tweak the algorithm's parameters, but overall it tends to perform well without much tuning. As for non-deep learning methods, I would subjectively say that `Scanorama` provided the second-best embeddings, though I've also had good experiences with the R implementation of `Harmony`. As always, it's important to try multiple methods and compare results both visually and quantitatively. \n\n# Session info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.1 (2022-06-23)\n os       macOS Big Sur ... 10.16\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2023-12-08\n pandoc   3.1.9 @ /usr/local/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package          * version date (UTC) lib source\n abind              1.4-5   2016-07-21 [1] CRAN (R 4.2.0)\n cli                3.6.1   2023-03-23 [1] CRAN (R 4.2.0)\n cluster            2.1.4   2022-08-22 [1] CRAN (R 4.2.0)\n codetools          0.2-18  2020-11-04 [1] CRAN (R 4.2.1)\n colorspace         2.0-3   2022-02-21 [1] CRAN (R 4.2.0)\n cowplot            1.1.1   2020-12-30 [1] CRAN (R 4.2.0)\n data.table         1.14.2  2021-09-27 [1] CRAN (R 4.2.0)\n deldir             1.0-6   2021-10-23 [1] CRAN (R 4.2.0)\n digest             0.6.33  2023-07-07 [1] CRAN (R 4.2.0)\n dotCall64          1.0-1   2021-02-11 [1] CRAN (R 4.2.0)\n dplyr            * 1.1.3   2023-09-03 [1] CRAN (R 4.2.0)\n ellipsis           0.3.2   2021-04-29 [1] CRAN (R 4.2.0)\n evaluate           0.23    2023-11-01 [1] CRAN (R 4.2.1)\n fansi              1.0.3   2022-03-24 [1] CRAN (R 4.2.0)\n fastDummies        1.7.3   2023-07-06 [1] CRAN (R 4.2.0)\n fastmap            1.1.0   2021-01-25 [1] CRAN (R 4.2.0)\n fitdistrplus       1.1-8   2022-03-10 [1] CRAN (R 4.2.0)\n future             1.33.0  2023-07-01 [1] CRAN (R 4.2.0)\n future.apply       1.9.0   2022-04-25 [1] CRAN (R 4.2.0)\n generics           0.1.3   2022-07-05 [1] CRAN (R 4.2.0)\n ggplot2          * 3.4.4   2023-10-12 [1] CRAN (R 4.2.0)\n ggrepel            0.9.4   2023-10-13 [1] CRAN (R 4.2.0)\n ggridges           0.5.3   2021-01-08 [1] CRAN (R 4.2.0)\n globals            0.16.1  2022-08-28 [1] CRAN (R 4.2.1)\n glue               1.6.2   2022-02-24 [1] CRAN (R 4.2.0)\n goftest            1.2-3   2021-10-07 [1] CRAN (R 4.2.0)\n gridExtra          2.3     2017-09-09 [1] CRAN (R 4.2.0)\n gtable             0.3.0   2019-03-25 [1] CRAN (R 4.2.0)\n here               1.0.1   2020-12-13 [1] CRAN (R 4.2.0)\n htmltools          0.5.3   2022-07-18 [1] CRAN (R 4.2.0)\n htmlwidgets        1.5.4   2021-09-08 [1] CRAN (R 4.2.0)\n httpuv             1.6.5   2022-01-05 [1] CRAN (R 4.2.0)\n httr               1.4.4   2022-08-17 [1] CRAN (R 4.2.0)\n ica                1.0-3   2022-07-08 [1] CRAN (R 4.2.0)\n igraph             1.5.1   2023-08-10 [1] CRAN (R 4.2.0)\n irlba              2.3.5.1 2022-10-03 [1] CRAN (R 4.2.1)\n jsonlite           1.8.7   2023-06-29 [1] CRAN (R 4.2.0)\n KernSmooth         2.23-20 2021-05-03 [1] CRAN (R 4.2.1)\n knitr              1.40    2022-08-24 [1] CRAN (R 4.2.0)\n later              1.3.0   2021-08-18 [1] CRAN (R 4.2.0)\n lattice            0.20-45 2021-09-22 [1] CRAN (R 4.2.1)\n lazyeval           0.2.2   2019-03-15 [1] CRAN (R 4.2.0)\n leiden             0.4.2   2022-05-09 [1] CRAN (R 4.2.0)\n lifecycle          1.0.3   2022-10-07 [1] CRAN (R 4.2.0)\n listenv            0.8.0   2019-12-05 [1] CRAN (R 4.2.0)\n lmtest             0.9-40  2022-03-21 [1] CRAN (R 4.2.0)\n magrittr           2.0.3   2022-03-30 [1] CRAN (R 4.2.0)\n MASS               7.3-60  2023-05-04 [1] CRAN (R 4.2.0)\n Matrix           * 1.6-3   2023-11-14 [1] CRAN (R 4.2.1)\n matrixStats        0.62.0  2022-04-19 [1] CRAN (R 4.2.0)\n mime               0.12    2021-09-28 [1] CRAN (R 4.2.0)\n miniUI             0.1.1.1 2018-05-18 [1] CRAN (R 4.2.0)\n munsell            0.5.0   2018-06-12 [1] CRAN (R 4.2.0)\n nlme               3.1-159 2022-08-09 [1] CRAN (R 4.2.0)\n parallelly         1.36.0  2023-05-26 [1] CRAN (R 4.2.0)\n patchwork          1.1.2   2022-08-19 [1] CRAN (R 4.2.0)\n pbapply            1.5-0   2021-09-16 [1] CRAN (R 4.2.0)\n pillar             1.9.0   2023-03-22 [1] CRAN (R 4.2.0)\n pkgconfig          2.0.3   2019-09-22 [1] CRAN (R 4.2.0)\n plotly             4.10.0  2021-10-09 [1] CRAN (R 4.2.0)\n plyr               1.8.7   2022-03-24 [1] CRAN (R 4.2.0)\n png                0.1-7   2013-12-03 [1] CRAN (R 4.2.0)\n polyclip           1.10-0  2019-03-14 [1] CRAN (R 4.2.0)\n progressr          0.10.1  2022-06-03 [1] CRAN (R 4.2.0)\n promises           1.2.0.1 2021-02-11 [1] CRAN (R 4.2.0)\n purrr              1.0.2   2023-08-10 [1] CRAN (R 4.2.0)\n R6                 2.5.1   2021-08-19 [1] CRAN (R 4.2.0)\n RANN               2.6.1   2019-01-08 [1] CRAN (R 4.2.0)\n RColorBrewer       1.1-3   2022-04-03 [1] CRAN (R 4.2.0)\n Rcpp               1.0.9   2022-07-08 [1] CRAN (R 4.2.0)\n RcppAnnoy          0.0.19  2021-07-30 [1] CRAN (R 4.2.0)\n RcppHNSW           0.4.1   2022-07-18 [1] CRAN (R 4.2.0)\n reshape2           1.4.4   2020-04-09 [1] CRAN (R 4.2.0)\n reticulate       * 1.28    2023-01-27 [1] CRAN (R 4.2.0)\n rlang              1.1.2   2023-11-04 [1] CRAN (R 4.2.1)\n rmarkdown          2.16    2022-08-24 [1] CRAN (R 4.2.0)\n ROCR               1.0-11  2020-05-02 [1] CRAN (R 4.2.0)\n rprojroot          2.0.3   2022-04-02 [1] CRAN (R 4.2.0)\n RSpectra           0.16-1  2022-04-24 [1] CRAN (R 4.2.0)\n Rtsne              0.16    2022-04-17 [1] CRAN (R 4.2.0)\n scales             1.2.1   2022-08-20 [1] CRAN (R 4.2.0)\n scattermore        1.2     2023-06-12 [1] CRAN (R 4.2.0)\n sctransform        0.4.1   2023-10-19 [1] CRAN (R 4.2.0)\n sessioninfo        1.2.2   2021-12-06 [1] CRAN (R 4.2.0)\n Seurat           * 5.0.0   2023-11-04 [1] CRAN (R 4.2.1)\n SeuratObject     * 5.0.0   2023-10-26 [1] CRAN (R 4.2.1)\n shiny              1.7.2   2022-07-19 [1] CRAN (R 4.2.0)\n sp               * 1.5-0   2022-06-05 [1] CRAN (R 4.2.0)\n spam               2.9-1   2022-08-07 [1] CRAN (R 4.2.0)\n spatstat.data      3.0-0   2022-10-21 [1] CRAN (R 4.2.0)\n spatstat.explore   3.0-5   2022-11-10 [1] CRAN (R 4.2.1)\n spatstat.geom      3.0-3   2022-10-25 [1] CRAN (R 4.2.0)\n spatstat.random    3.0-1   2022-11-03 [1] CRAN (R 4.2.0)\n spatstat.sparse    3.0-0   2022-10-21 [1] CRAN (R 4.2.0)\n spatstat.utils     3.0-1   2022-10-19 [1] CRAN (R 4.2.0)\n stringi            1.7.8   2022-07-11 [1] CRAN (R 4.2.0)\n stringr            1.5.0   2022-12-02 [1] CRAN (R 4.2.0)\n survival           3.4-0   2022-08-09 [1] CRAN (R 4.2.0)\n tensor             1.5     2012-05-05 [1] CRAN (R 4.2.0)\n tibble             3.2.1   2023-03-20 [1] CRAN (R 4.2.0)\n tidyr              1.3.0   2023-01-24 [1] CRAN (R 4.2.0)\n tidyselect         1.2.0   2022-10-10 [1] CRAN (R 4.2.0)\n utf8               1.2.2   2021-07-24 [1] CRAN (R 4.2.0)\n uwot               0.1.16  2023-06-29 [1] CRAN (R 4.2.0)\n vctrs              0.6.3   2023-06-14 [1] CRAN (R 4.2.0)\n viridisLite        0.4.1   2022-08-22 [1] CRAN (R 4.2.0)\n withr              2.5.2   2023-10-30 [1] CRAN (R 4.2.1)\n xfun               0.32    2022-08-10 [1] CRAN (R 4.2.0)\n xtable             1.8-4   2019-04-21 [1] CRAN (R 4.2.0)\n yaml               2.3.5   2022-02-21 [1] CRAN (R 4.2.0)\n zoo                1.8-10  2022-04-15 [1] CRAN (R 4.2.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.2/Resources/library\n\n─ Python configuration ───────────────────────────────────────────────────────\n python:         /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/bin/python\n libpython:      /usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/lib/python3.11/config-3.11-darwin/libpython3.11.dylib\n pythonhome:     /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site:/Users/jack/Desktop/PhD/Research/Python_Envs/personal_site\n version:        3.11.6 (main, Nov  2 2023, 04:52:24) [Clang 14.0.3 (clang-1403.0.22.14.1)]\n numpy:          /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/lib/python3.11/site-packages/numpy\n numpy_version:  1.23.5\n \n NOTE: Python version was forced by use_python function\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [
      "Integration_Tutorial_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}