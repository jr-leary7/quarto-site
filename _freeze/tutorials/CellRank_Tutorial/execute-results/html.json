{
  "hash": "aa419220941f1d900ca1d41cd537fbc6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Analyzing Transcriptional Dynamics with `CellRank`\"\nauthor:\n  name: Jack Leary\n  email: j.leary@ufl.edu\n  orcid: 0009-0004-8821-3269\n  affiliations:\n    - name: University of Florida\n      department: Biostatistics \n      city: Gainesville\n      state: FL\ndate: today\nformat:\n  html:\n    code-fold: show\n    code-copy: true\n    code-tools: true\n    toc: true\n    embed-resources: true\n    fig-format: retina\n    df-print: kable\n    link-external-newwindow: true\n    fig-cap-location: bottom\n    fig-align: center\nexecute: \n  cache: false\n  freeze: auto\n---\n\n\n\n\n# Introduction\n\nIn this analysis we'll use `CellRank` to identify multiple cell fates in pancreatic endocrinogenesis data by combining RNA velocity, pseudotime, & developmental potential information. The goal is to showcase a more advanced analysis that incorporates multiple modalities to infer a confident final trajectory.\n\n# Libraries\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport warnings                  # filter out warnings\nimport numpy as np               # matrix utilities\nimport scanpy as sc              # scRNA-seq processing\nimport pandas as pd              # dataframe tools\nimport scvelo as scv             # RNA velocity estimation\nimport anndata as ad             # scRNA-seq data structures\nimport cellrank as cr            # cell fate estimation\nimport matplotlib.pyplot as plt  # plot utilities\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nwarnings.simplefilter('ignore', category=UserWarning)\n```\n:::\n\n\n# Theme for `matplotlib`\n\n\n::: {.cell}\n\n```{.python .cell-code}\nbase_size = 12\nplt.rcParams.update({\n    # font\n    'font.size': base_size, \n    'font.weight': 'normal',\n    # figure\n    'figure.dpi': 320, \n    'figure.edgecolor': 'white', \n    'figure.facecolor': 'white', \n    'figure.figsize': (6, 4), \n    # axes\n    'axes.edgecolor': 'black',\n    'axes.grid': False,\n    'axes.labelpad': 2.75,\n    'axes.labelsize': base_size * 0.8,\n    'axes.linewidth': 1.5,\n    'axes.spines.right': False,\n    'axes.spines.top': False,\n    'axes.titlelocation': 'left',\n    'axes.titlepad': 11,\n    'axes.titlesize': base_size,\n    'axes.titleweight': 'normal',\n    'axes.xmargin': 0.1, \n    'axes.ymargin': 0.1, \n    # legend\n    'legend.borderaxespad': 1,\n    'legend.borderpad': 0.5,\n    'legend.columnspacing': 2,\n    'legend.fontsize': base_size * 0.8,\n    'legend.frameon': False,\n    'legend.handleheight': 1,\n    'legend.handlelength': 1.2,\n    'legend.labelspacing': 1,\n    'legend.title_fontsize': base_size, \n    'legend.markerscale': 1.25\n})\n```\n:::\n\n\n# Data \n\nFirst, we load the data from [Bastidas-Ponce *et al* (2019)](https://doi.org/10.1242/dev.173849). This dataset is comprised of murine pancreas cells from timepoint E15.5, and includes both spliced & unspliced mRNA counts. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nad_panc = scv.datasets.pancreas()\n```\n\n```{.python .cell-code}\nad_panc.raw = ad_panc\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n# Analysis \n\n## Preprocessing\n\n### HVG Selection & Normalization\n\nWe begin by filtering out cells that have fewer than 20 total counts between the spliced & unspliced assays. Next, we select the top 3,000 most highly variable genes (HVGs), after which we normalize the counts using a log1p-transform. Lastly, we use the cell cycle gene sets from [Tirosh *et al* (2016)](https://doi.org/10.1126/science.aad0501) to assign S-phase and G2M-phase scores to each cell in order to identify populations of cycling cells. Cell cycle variation is not always of biological interest, and can prevent trajectory structures from being as clean or simple as we'd like. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nscv.pp.filter_and_normalize(\n    ad_panc, \n    min_shared_counts=20, \n    n_top_genes=3000,\n    flavor='seurat',  \n    subset_highly_variable=False, \n    log=False\n)\nsc.pp.log1p(ad_panc)\nscv.tl.score_genes_cell_cycle(ad_panc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFiltered out 20801 genes that are detected 20 counts (shared).\nNormalized count data: X, spliced, unspliced.\nExtracted 3000 highly variable genes.\ncalculating cell cycle phase\n-->     'S_score' and 'G2M_score', scores of cell cycle phases (adata.obs)\n```\n\n\n:::\n:::\n\n\n### PCA Embedding\n\nAfter centering & scaling the normalized spliced mRNA counts matrix, we use the HVGs identified earlier to generate a 30-dimensional principal component analysis (PCA) embedding. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.pp.scale(ad_panc)\nsc.tl.pca(\n    ad_panc, \n    n_comps=30, \n    random_state=312, \n    use_highly_variable=True\n)\n```\n:::\n\n\nVisualizing the PCA embedding shows us a rather simple trajectory from endocrine precursors to mature endocrine cells. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_panc, \n    basis='pca', \n    color='clusters',\n    title='', \n    frameon=True, \n    size=20, \n    alpha=0.75, \n    show=False\n)\nplt.gca().set_xlabel('PC 1')\nplt.gca().set_ylabel('PC 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![PCA embedding](CellRank_Tutorial_files/figure-html/fig-pca_embed-1.png){#fig-pca_embed width=576}\n:::\n:::\n\n\n### Graph-based Clustering\n\nAfter identifying the 20 nearest neighbors (NNs) for each cell in PCA space, we use the Leiden algorithm to partition the NN graph into discrete clusters. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.pp.neighbors(\n    ad_panc, \n    use_rep='X_pca', \n    n_pcs=30, \n    n_neighbors=20, \n    metric='cosine', \n    random_state=312\n)\nsc.tl.leiden(\n    ad_panc, \n    resolution=0.3, \n    random_state=312\n)\n```\n:::\n\n\nThe clusters generally correspond to our celltypes, with some minor differences e.g., overclustering in the ductal cell population (most likely due to cell cycle variation). \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_panc, \n    basis='pca', \n    color='leiden',\n    title='', \n    frameon=True, \n    size=20, \n    alpha=0.75, \n    show=False\n)\nplt.gca().set_xlabel('PC 1')\nplt.gca().set_ylabel('PC 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Leiden clusters in PCA space](CellRank_Tutorial_files/figure-html/fig-pca_leiden-3.png){#fig-pca_leiden width=576}\n:::\n:::\n\n\nPlotting the cell cycle scores on the PCA embedding shows us that the two ductal cell clusters are in fact split by enrichment for cell cycle genes. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nscv.pl.scatter(\n  ad_panc, \n  basis='pca', \n  color_gradients=['S_score', 'G2M_score'], \n  smooth=True,\n  perc=[5, 95], \n  frameon=True, \n  show=False\n)\nplt.gca().set_xlabel('PC 1')\nplt.gca().set_ylabel('PC 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Cell cycle scores](CellRank_Tutorial_files/figure-html/fig-pca_cc_scores-5.png){#fig-pca_cc_scores width=576}\n:::\n:::\n\n\n### UMAP Embedding \n\nWe generate a UMAP embedding in two dimensions. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.umap(ad_panc, random_state=312)\n```\n:::\n\n\nUpon visual inspection, the UMAP embedding appears to preserve both the transitions between celltypes and the heterogeneity of the mature endocrine cells better than the PCA embedding. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_panc, \n    basis='umap', \n    color='clusters',\n    title='', \n    frameon=True, \n    size=20, \n    alpha=0.75, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![UMAP embedding](CellRank_Tutorial_files/figure-html/fig-umap_embed-7.png){#fig-umap_embed width=576}\n:::\n:::\n\n\n### Diffusion Map Embedding\n\nWe'll also generate a 2D diffusion map embedding, since that algorithm often works well for trajectory manifolds. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.diffmap(\n  ad_panc, \n  n_comps=10, \n  random_state=312\n)\n```\n:::\n\n\nWe visualize the 2nd and 3rd components - for some reason there's a bug in the `scanpy` source code that incorrectly arranges the returned array for the embedding. While the overall trajectory structure is preserved, the local structure of the mature endocrine celltypes is messy, making this embedding less than ideal for our purposes.\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_panc, \n    basis='diffmap', \n    color='clusters',\n    title='', \n    frameon=True, \n    size=20, \n    alpha=0.75, \n    show=False, \n    components='2, 3'\n)\nplt.gca().set_xlabel('DC 1')\nplt.gca().set_ylabel('DC 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Diffusion map embedding](CellRank_Tutorial_files/figure-html/fig-diffmap_embed-9.png){#fig-diffmap_embed width=576}\n:::\n:::\n\n\nDespite the imperfection of the diffusion map embedding, we'll also estimate a diffusion pseudotime value for each cell, as the estimates might be useful later on. We set the root cell to be the ductal cell closest to the minimum of the second diffusion component (as visualized above).\n\n\n::: {.cell}\n\n```{.python .cell-code}\nad_panc.uns['iroot'] = np.argmin(ad_panc.obsm['X_diffmap'][:2])\nsc.tl.dpt(ad_panc, n_dcs=10)\n```\n:::\n\n\nVisualizing the diffusion pseudotime on our UMAP embedding shows that it seems to recapitulate the underlying biological process fairly well, with ductal cells assigned lower values and endocrine cells assigned higher values.\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_panc, \n    basis='umap', \n    color='dpt_pseudotime',\n    title='', \n    frameon=True, \n    size=20, \n    alpha=0.75, \n    show=False, \n    cmap='plasma'\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Estimated diffusion pseudotime](CellRank_Tutorial_files/figure-html/fig-umap_dpt_pt-11.png){#fig-umap_dpt_pt width=576}\n:::\n:::\n\n\n### Force-directed Graph Embedding\n\nIt's often worth checking a force-directed graph embedding in addition to the UMAP embedding, as it can sometimes better preserve trajectory structure in the data. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.tl.draw_graph(\n    ad_panc, \n    layout='kk',\n    random_state=312,\n    root=np.argmin(ad_panc.obsm['X_diffmap'][:2]), \n    n_jobs=4\n)\n```\n:::\n\n\nWhile the overall trajectory structure is better (visually speaking) than the PCA embedding, variation in the ductal & endocrine progenitor celltypes is hidden. We'll stick with the UMAP embedding going forwards. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.draw_graph(\n    ad_panc, \n    color='clusters', \n    title='', \n    alpha=0.75, \n    size=20, \n    show=False\n)\nplt.gca().set_xlabel('Dim 1')\nplt.gca().set_ylabel('Dim 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Force-directed graph embedding](CellRank_Tutorial_files/figure-html/fig-graph_embed-13.png){#fig-graph_embed width=576}\n:::\n:::\n\n\n## RNA Velocity Estimation\n\nNext, we'll estimate RNA velocity vectors for each cell via `scvelo`. Details on the methodology can be found in [the original paper](https://doi.org/10.1038/s41587-020-0591-3), and a review of current challenges & limitations of velocity analyses can be read [here](https://doi.org/10.15252/msb.202110282). \n\n### SNN-based Imputation\n\nWe start by smoothing the spliced & unspliced counts across the NNs we identified earlier. This helps to preserve signal in otherwise very noisy velocity vectors. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nscv.pp.moments(\n    ad_panc, \n    n_pcs=None, \n    n_neighbors=20, \n    use_rep='X_pca'\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncomputing moments based on connectivities\n    finished (0:00:01) --> added \n    'Ms' and 'Mu', moments of un/spliced abundances (adata.layers)\n```\n\n\n:::\n:::\n\n\n### Dynamical Velocity Computation\n\nNext, we utilize the dynamical model to estimate velocity vectors, generate a velocity graph, and compute the uncertainty of each cells' differentiation direction. Lastly, we project the velocity vectors onto our 2D UMAP embedding for visualization purposes. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nscv.tl.recover_dynamics(ad_panc, n_jobs=6)\nscv.tl.velocity(\n    ad_panc, \n    mode='dynamical', \n    use_highly_variable=True\n)\nscv.tl.velocity_graph(\n    ad_panc, \n    n_jobs=4, \n    compute_uncertainties=True\n)\nscv.tl.velocity_confidence(ad_panc)\nscv.tl.velocity_embedding(ad_panc, basis='umap')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nrecovering dynamics (using 6/8 cores)\n  0%|          | 0/1430 [00:00<?, ?gene/s]\n    finished (0:02:44) --> added \n    'fit_pars', fitted parameters for splicing dynamics (adata.var)\ncomputing velocities\n    finished (0:00:05) --> added \n    'velocity', velocity vectors for each individual cell (adata.layers)\ncomputing velocity graph (using 4/8 cores)\n  0%|          | 0/3696 [00:00<?, ?cells/s]\n    finished (0:00:19) --> added \n    'velocity_graph', sparse matrix with cosine correlations (adata.uns)\n--> added 'velocity_length' (adata.obs)\n--> added 'velocity_confidence' (adata.obs)\n--> added 'velocity_confidence_transition' (adata.obs)\ncomputing velocity embedding\n    finished (0:00:00) --> added\n    'velocity_umap', embedded velocity vectors (adata.obsm)\n```\n\n\n:::\n:::\n\n\nVisualizing the projected velocities with a streamline plot allows us to get a rough idea of which direction cells are differentiating towards in each local area. From the endocrine progenitors through pre-endocrine cells we see a smooth flow of differentiation, which is followed by branching trajectories towards each of the mature endocrine celltypes. The streamlines broadly correspond to known biology, which indicates that RNA velocity should provide decent biological insights about this dataset. We also see cycling in the ductal cells, which is expected as this dataset is [known to have strong cell-cycle effects in the ductal cell cluster](https://scvelo.readthedocs.io/en/stable/VelocityBasics/).\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nscv.pl.velocity_embedding_stream(\n    ad_panc, \n    basis='umap', \n    color='clusters',\n    alpha=0.75, \n    size=20, \n    frameon=True, \n    linewidth=0.5, \n    legend_loc='right',\n    arrow_size=0.8,\n    title='', \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Velocity embedding streamlines](CellRank_Tutorial_files/figure-html/fig-umap_velo_stream-15.png){#fig-umap_velo_stream width=576}\n:::\n:::\n\n\n::: {.callout-note}\nStreamline embedding plots generally provide qualitative insight at best, & their interpretation can be very subjective. Take care when forming biological conclusions or further hypotheses based on them, and verify what you see in a quantitative manner. \n:::\n\nVisualizing the length of the velocity vectors in each cell gives us an idea of how quickly differentiation is occurring, as velocity vector length is a proxy measurement for differentiation speed. We see high scores in the pre-endocrine cells, as well as in the beta cells. This could be due to the phenomenon of self-duplication that is observed in beta cells, wherein new beta cells are produced in that way instead of through precursor differentiation. More information on beta cell specification can be read in [Murtaugh (2007)](https://doi.org/10.1242/dev.02770). \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_panc, \n    basis='umap', \n    color='velocity_length',\n    title='', \n    frameon=True, \n    size=20, \n    alpha=0.75, \n    show=False, \n    legend_loc='right margin', \n    cmap='coolwarm'\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Velocity length](CellRank_Tutorial_files/figure-html/fig-umap_velo_length-17.png){#fig-umap_velo_length width=576}\n:::\n:::\n\n\n### Investigation of Velocity Genes\n\nWe begin by identifying ranking the velocity genes, then pull the top 6 highest-likelihood genes for each celltype. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nscv.tl.rank_dynamical_genes(ad_panc, groupby='clusters')\n```\n\n```{.python .cell-code}\ntop_dyn_genes = scv.get_df(ad_panc, 'rank_dynamical_genes/names').head(6)\n```\n:::\n\n\nPlotting the spliced vs. unspliced mRNA estimates along with the learned dynamics per-gene allows us to determine which genes have dynamics specific to mature endocrine celltypes. For example, [*Pak3*](https://www.ncbi.nlm.nih.gov/gene/18481) is present in the top 6 genes of every endocrine celltype. Interestingly, this gene is mostly known to be associated in humans with intellectual development disorders, though it's also present in GO biological processes [such as differentiation and system development](https://www.informatics.jax.org/marker/MGI:1339656). Lastly, according to [Piccand *et al* (2013)](https://doi.org/10.2337/db13-0384), *Pak3* is linked to beta cell specification and has implications for diabetes risk, but their study does not conclude that it is necessary for the development of other endocrine celltypes.\n\nAnother interesting tidbit is the presence of [*Meis2*](https://www.ncbi.nlm.nih.gov/gene?Cmd=DetailsSearch&Term=17536) as a top gene for both delta & epsilon cells. This gene is associated with organogenesis and autism, and is known to be a vital part of neural crest development as per [Machon *et al* (2015)](https://doi.org/10.1186%2Fs12861-015-0093-6). It's role in some endocrine celltypes' development but not others could indicate that the specification of delta & epsilon cells is more similar than that of alpha and beta cells. \n\n#### Alpha Cells\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nscv.pl.scatter(\n  ad_panc, \n  top_dyn_genes['Alpha'], \n  ncols=3, \n  frameon=False, \n  alpha=0.75, \n  size=20, \n  show=False\n)\nplt.gcf().supxlabel('Spliced mRNA')\nplt.gcf().supylabel('Unspliced mRNA')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Alpha cell velocity genes](CellRank_Tutorial_files/figure-html/fig-alpha_genes-19.png){#fig-alpha_genes width=1728}\n:::\n:::\n\n\n#### Beta Cells\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nscv.pl.scatter(\n  ad_panc, \n  top_dyn_genes['Beta'], \n  ncols=3, \n  frameon=False, \n  alpha=0.75, \n  size=20, \n  show=False\n)\nplt.gcf().supxlabel('Spliced mRNA')\nplt.gcf().supylabel('Unspliced mRNA')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Beta cell velocity genes](CellRank_Tutorial_files/figure-html/fig-beta_genes-21.png){#fig-beta_genes width=1728}\n:::\n:::\n\n\n#### Delta Cells\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nscv.pl.scatter(\n  ad_panc, \n  top_dyn_genes['Delta'], \n  ncols=3, \n  frameon=False, \n  alpha=0.75, \n  size=20, \n  show=False\n)\nplt.gcf().supxlabel('Spliced mRNA')\nplt.gcf().supylabel('Unspliced mRNA')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Delta cell velocity genes](CellRank_Tutorial_files/figure-html/fig-delta_genes-23.png){#fig-delta_genes width=1728}\n:::\n:::\n\n\n#### Epsilon Cells\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nscv.pl.scatter(\n  ad_panc, \n  top_dyn_genes['Epsilon'], \n  ncols=3, \n  frameon=False, \n  alpha=0.75, \n  size=20, \n  show=False\n)\nplt.gcf().supxlabel('Spliced mRNA')\nplt.gcf().supylabel('Unspliced mRNA')\nplt.show()\n```\n\n::: {.cell-output-display}\n![Epsilon cell velocity genes](CellRank_Tutorial_files/figure-html/fig-epsilon_genes-25.png){#fig-epsilon_genes width=1728}\n:::\n:::\n\n\n## Cell Fate Identification\n\nIn this part of the analysis we'll focus on identifying a set of terminal and initial cell states, along with the probabilities of transitions between them. This is performed via `CellRank`; the details of the method can be read in [the original paper](https://doi.org/10.1038/s41592-021-01346-6) as well as [the preprint for the second version](https://doi.org/10.1101/2023.07.19.549685). \n\n### Velocity Kernel\n\nWe start by computing a cell-cell transition probability matrix based on our RNA velocity estimates from earlier. Using the `model='monte_carlo'` option allows us to propagate the velocity vector uncertainty estimates forward to the estimated transition probability matrix. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nvk = cr.kernels.VelocityKernel(ad_panc)\nvk.compute_transition_matrix(\n    model='monte_carlo', \n    similarity='cosine', \n    seed=312, \n    n_jobs=4\n)\n```\n:::\n\n\nVisualizing the directed transitions on our UMAP embedding shows essentially the same patterns as our velocity vector projections from above, as expected. A drawback of using velocity on this dataset is that the inferred directionality in the ductal cell population is uncertain, so we'll need another source of information to strengthen our inferred trajectory. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nvk.plot_projection(\n    basis='umap', \n    recompute=True, \n    linewidth=0.5, \n    arrow_size=0.8,\n    color='clusters', \n    size=20, \n    alpha=0.75, \n    legend_loc='right margin', \n    title='', \n    frameon=True, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Velocity kernel projection](CellRank_Tutorial_files/figure-html/fig-vkernel_stream-27.png){#fig-vkernel_stream width=576}\n:::\n:::\n\n\nVisualizing the velocity confidence for each cell confirms our intuition that the ductal cells aren't fully interpretable using velocity-based information, as scores are slightly lower for the ductal cells than for e.g., the endocrine precursors or mature endocrine cells.  \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_panc, \n    basis='umap', \n    color='velocity_confidence',\n    title='', \n    frameon=True, \n    size=20, \n    alpha=0.75, \n    show=False, \n    legend_loc='right margin', \n    cmap='coolwarm'\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![UMAP colored by velocity coherence](CellRank_Tutorial_files/figure-html/fig-velo_conf-29.png){#fig-velo_conf width=576}\n:::\n:::\n\n\nPlotting the coherence of the velocity estimates per-celltype shows us that the alpha cells also have a relatively low velocity confidence. This could be because they're located at the end of the trajectory / they're terminally differentiated, or it could mean that the cells are of lower quality than those in other clusters. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.violin(\n  ad_panc, \n  keys='velocity_confidence', \n  groupby='clusters', \n  rotation=30, \n  xlabel='', \n  ylabel='Velocity Confidence',\n  show=False\n)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Velocity coherence by celltype](CellRank_Tutorial_files/figure-html/fig-velo_conf_violins-31.png){#fig-velo_conf_violins width=717}\n:::\n:::\n\n\n### CytoTRACE Kernel\n\nIn addition to the velocity kernel we'll compute another transition probability matrix based on CytoTRACE scores. The CytoTRACE method essentially uses the number of expressed genes as a proxy for differentiation potential. The details of the method can be found in [Gulati *et al* (2020)](https://doi.org/10.1126/science.aax0249). \n\n\n::: {.cell}\n\n```{.python .cell-code}\nctk = cr.kernels.CytoTRACEKernel(ad_panc).compute_cytotrace()\nctk.compute_transition_matrix(\n    threshold_scheme='soft',\n    nu=0.5, \n    n_jobs=2\n)\n```\n:::\n\n\nVisualizing the CytoTRACE score shows what we would expect - ductal cells, which function as the initial cell state in this dataset, express more genes and have a higher differentiation potential than the intermediate and terminal cell states. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_panc, \n    basis='umap', \n    color='ct_score',\n    title='', \n    frameon=True, \n    size=20, \n    alpha=0.75, \n    show=False, \n    legend_loc='right margin'\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![CytoTRACE differentiation scores](CellRank_Tutorial_files/figure-html/fig-cyto_score-33.png){#fig-cyto_score width=576}\n:::\n:::\n\n\nThe embedding projection based on our CytoTRACE kernel displays a confident differentiation trajectory for the initial and intermediate cell states, but for the mature cell states with fewer expressed genes the differentiation directions are much less certain.  \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nctk.plot_projection(\n    basis='umap', \n    recompute=True, \n    linewidth=0.5, \n    color='clusters', \n    size=20, \n    alpha=0.75, \n    arrow_size=0.8, \n    legend_loc='right margin', \n    title='', \n    frameon=True, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![CytoTRACE kernel projection](CellRank_Tutorial_files/figure-html/fig-ctkernel_stream-35.png){#fig-ctkernel_stream width=576}\n:::\n:::\n\n\n### Pseudotime Kernel\n\nLastly, we can create another kernel based on our estimated diffusion pseudotime from earlier. This should help to smooth out the overall trajectory, since it represents the transitions between celltypes well. \n\n\n::: {.cell}\n\n```{.python .cell-code}\npk = cr.kernels.PseudotimeKernel(ad_panc, time_key='dpt_pseudotime')\npk.compute_transition_matrix(threshold_scheme='soft', n_jobs=2)\n```\n:::\n\n\nWe visualize the directed transition matrix on our UMAP embedding, and see that the pseudotime kernel does a bit better of a job than the CytoTRACE kernel at identifying directionality in the mature endocrine cells. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\npk.plot_projection(\n    basis='umap', \n    recompute=True, \n    linewidth=0.5, \n    color='clusters', \n    size=20, \n    alpha=0.75, \n    arrow_size=0.8, \n    legend_loc='right margin', \n    title='', \n    frameon=True, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Pseudotime kernel projection](CellRank_Tutorial_files/figure-html/fig-ptkernel_stream-37.png){#fig-ptkernel_stream width=576}\n:::\n:::\n\n\n### Combined Kernel\n\nAs we just saw, individual sources of information about our data can miss critical aspects, like CytoTRACE not detecting much differentiation during the latter half of the trajectory. One of the best features of `CellRank` is the ability to combine sources of information by combining the kernels themselves. Here we combine the velocity, CytoTRACE, & pseudotime kernels using an equal weighting scheme. This results in a new transition probability matrix, which we can then project onto our embedding. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nck = 0.33 * vk + 0.33 * ctk + 0.33 * pk\n```\n:::\n\n\nWith all three source of information (velocity, differentiation potential, & pseudotime) combined, we finally have a relatively smooth trajectory that more or less lines up with known biology. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nck.plot_projection(\n    basis='umap', \n    recompute=True, \n    linewidth=0.5, \n    arrow_size=0.8, \n    color='clusters', \n    size=20, \n    alpha=0.75, \n    legend_loc='right margin', \n    title='', \n    frameon=True, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Combined kernel projection](CellRank_Tutorial_files/figure-html/fig-combkernel_stream-39.png){#fig-combkernel_stream width=576}\n:::\n:::\n\n\n### Macrostate Estimation\n\n#### Terminal States\n\nAfter computing a Schur decomposition of the transition probability matrix, we make the assumption that each component corresponds to a cell macrostate - a somewhat vague concept that can loosely be interpreted as a cell phenotype.  \n\n\n::: {.cell}\n\n```{.python .cell-code}\ng = cr.estimators.GPCCA(ck)\ng.compute_schur(n_components=15, method='brandts')\n```\n\n```{.python .cell-code}\ng.compute_macrostates(\n    cluster_key='clusters', \n    n_cells=20, \n    n_states=13, \n    method='brandts'\n)\n```\n:::\n\n\nOn our UMAP embedding we plot the 20 cells most likely to be assigned to each macrostate. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\ng.plot_macrostates(\n    which='all', \n    discrete=True, \n    same_plot=True, \n    legend_loc='right margin', \n    title='', \n    basis='umap',\n    frameon=True,\n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Macrostates identified via Schur decomposition](CellRank_Tutorial_files/figure-html/fig-umap_macrostates-41.png){#fig-umap_macrostates width=576}\n:::\n:::\n\n\nBased on the macrostate estimates & known biology, we designate the four mature endocrine celltypes as terminal states. This step can be performed automatically using a heuristic \n\n\n::: {.cell}\n\n```{.python .cell-code}\ng.set_terminal_states(\n    states=['Alpha', 'Beta', 'Delta', 'Epsilon'], \n    n_cells=20, \n    cluster_key='clusters'\n)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\ng.plot_macrostates(\n    which='terminal', \n    discrete=False, \n    same_plot=True, \n    legend_loc='right margin', \n    title='', \n    frameon=True,\n    basis='umap',\n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Terminal cell fates](CellRank_Tutorial_files/figure-html/fig-terminal_states-43.png){#fig-terminal_states width=576}\n:::\n:::\n\n\n#### Initial States\n\nBased on our prior knowledge that the ductal cells are the root state, we set the initial state to be the ductal cell macrostate closest to the beginning of the trajectory.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ng.set_initial_states(\n    states=['Ductal_5'], \n    n_cells=20, \n    cluster_key='clusters'\n)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\ng.plot_macrostates(\n    which='initial', \n    discrete=True,\n    legend_loc='right margin', \n    title='', \n    frameon=True,\n    basis='umap', \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Initial cell state](CellRank_Tutorial_files/figure-html/fig-initial_state-45.png){#fig-initial_state width=576}\n:::\n:::\n\n\n### Absorption Probability Estimation\n\nNow that we have our terminal cell fates identified, we compute the probability of and time to absorption in each state. \n\n\n::: {.cell}\n\n```{.python .cell-code}\ng.compute_absorption_times(n_jobs=4)\n```\n:::\n\n\nWe visualize the transition probabilities and initial & stationary distributions for each coarse macrostate. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\ng.plot_coarse_T(\n    title='', \n    show_initial_dist=True, \n    show_stationary_dist=True\n)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Coarse transition probability matrix](CellRank_Tutorial_files/figure-html/fig-transmat-47.png){#fig-transmat width=768}\n:::\n:::\n\n\nThe next step is to estimate the absorption probability of each terminal state; these probabilities are denoted fate probabilities by `CellRank`. \n\n\n::: {.cell}\n\n```{.python .cell-code}\ng.compute_fate_probabilities()\n```\n:::\n\n\nAs expected, fate probabilities are highest near each terminal state. Beta cells seem to have the highest fate probability among endocrine progenitors, but this is most likely due to the higher frequency of beta cells in the dataset along with their position at the \"end\" of the trajectory on the embedding. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\ng.plot_fate_probabilities(\n    same_plot=True, \n    title='', \n    legend_loc='right margin', \n    frameon=True, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Cell fate probabilities](CellRank_Tutorial_files/figure-html/fig-umap_cellfates-49.png){#fig-umap_cellfates width=576}\n:::\n:::\n\n\n### Lineage Driver Identification\n\nWe compute lineage drivers for each cell fate by estimating the correlation between spliced mRNA and fate probability, after which we estimate lineage priming. Lineage priming is the degree to which a cell is \"committed\" towards its cell fate; details of how this is calculated can be read in [Velten *et al* (2017)](https://doi.org/10.1038/ncb3493). \n\n\n::: {.cell}\n\n```{.python .cell-code}\nlineage_drivers = g.compute_lineage_drivers(\n    seed=312, \n    cluster_key='clusters', \n    confidence_level=0.95, \n    method='fisher'\n)\nlineage_priming = g.compute_lineage_priming()\n```\n:::\n\n\nVisualizing lineage priming on our UMAP embedding shows that fate commitment is strongest in the mature endocrine cells, with values being particularly high among epsilon cells. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_panc, \n    basis='umap', \n    color='priming_degree_fwd', \n    title='', \n    frameon=True, \n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Lineage priming](CellRank_Tutorial_files/figure-html/fig-umap_priming-51.png){#fig-umap_priming width=576}\n:::\n:::\n\n\n### Latent Time Estimation\n\nBy using the initial & terminal cell state probabilities as priors, we obtain a more accurate estimate of per-cell latent time. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nscv.tl.latent_time(\n    ad_panc, \n    end_key='term_states_fwd_probs', \n    root_key='init_states_fwd_probs'\n)\n```\n:::\n\n\nThe estimated latent time seems to characterize our trajectory well, which is good news for later analysis of trajectory differential expression (TDE). Overall, the beta cells seem to take the longest to reach terminal differentiation. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nsc.pl.embedding(\n    ad_panc, \n    basis='umap', \n    color='latent_time', \n    title='', \n    frameon=True,\n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Gene-shared latent time](CellRank_Tutorial_files/figure-html/fig-umap_latenttime-53.png){#fig-umap_latenttime width=576}\n:::\n:::\n\n\n### Directed Graph Abstraction\n\nUsing the initial & terminal cell state probabilities and gene-shared latent time as priors, we estimated a directed partitioned graph abstraction (PAGA), which shows us the general direction each celltype differentiates towards. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nscv.tl.paga(\n    ad_panc, \n    groups='clusters', \n    end_key='term_states_fwd_probs', \n    root_key='init_states_fwd_probs', \n    use_time_prior='latent_time'\n)\n```\n:::\n\n\nVisualizing the PAGA on our UMAP embedding shows a transition from ductal cells to endocrine progenitors, from pre-endocrine cells to the mature endocrine celltypes. The one bit that doesn't agree with known biology is the transition from alpha to epsilon cells, as epsilon cells should be generated from pre-endocrine cells instead. This situation demonstrates the importance of having at least some *a priori* biological knowledge with which your analysis can be guided, since even with sophisticated methods scRNA-seq studies are still very difficult to get right. \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\"}\nscv.pl.paga(\n    ad_panc, \n    color='clusters',\n    basis='umap', \n    size=20, \n    alpha=.25,\n    min_edge_width=2, \n    frameon=True, \n    title='', \n    node_size_scale=0.75, \n    arrowsize=8,\n    show=False\n)\nplt.gca().set_xlabel('UMAP 1')\nplt.gca().set_ylabel('UMAP 2')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![Directed PAGA](CellRank_Tutorial_files/figure-html/fig-paga_path-55.png){#fig-paga_path width=576}\n:::\n:::\n\n\n# Conclusions\n\nThis dataset is relatively simple as far as trajectory structures go - there's only one subject, one timepoint, one developmental lineage. In reality, scRNA-seq experiments are often much more complex design-wise. Those situations are where the ability of `CellRank` to easily combine multiple sources of information really shines. We didn't use it here since the cells were all from a single timepoint, but the [`RealTimeKernel`](https://cellrank.readthedocs.io/en/latest/notebooks/tutorials/kernels/500_real_time.html) allows you to incorporate experimental time in addition to the other modalities we used here; this functionality is a great way to make sure your trajectory structure is capturing the cellular developmental process being studied and not just the progression of time. Overall, I think `CellRank` is a pretty well-designed method, and it's been very helpful to me on several scRNA-seq projects this year since the v2 release. \n\n# Session Info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.1 (2022-06-23)\n os       macOS Big Sur ... 10.16\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2023-11-03\n pandoc   2.19.2 @ /usr/local/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.1   2023-03-23 [1] CRAN (R 4.2.0)\n digest        0.6.29  2021-12-01 [1] CRAN (R 4.2.0)\n evaluate      0.16    2022-08-09 [1] CRAN (R 4.2.0)\n fastmap       1.1.0   2021-01-25 [1] CRAN (R 4.2.0)\n here          1.0.1   2020-12-13 [1] CRAN (R 4.2.0)\n htmltools     0.5.3   2022-07-18 [1] CRAN (R 4.2.0)\n htmlwidgets   1.5.4   2021-09-08 [1] CRAN (R 4.2.0)\n jsonlite      1.8.0   2022-02-22 [1] CRAN (R 4.2.0)\n knitr         1.40    2022-08-24 [1] CRAN (R 4.2.0)\n lattice       0.20-45 2021-09-22 [1] CRAN (R 4.2.1)\n magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.2.0)\n Matrix        1.4-1   2022-03-23 [1] CRAN (R 4.2.1)\n png           0.1-7   2013-12-03 [1] CRAN (R 4.2.0)\n Rcpp          1.0.9   2022-07-08 [1] CRAN (R 4.2.0)\n reticulate    1.28    2023-01-27 [1] CRAN (R 4.2.0)\n rlang         1.1.1   2023-04-28 [1] CRAN (R 4.2.0)\n rmarkdown     2.16    2022-08-24 [1] CRAN (R 4.2.0)\n rprojroot     2.0.3   2022-04-02 [1] CRAN (R 4.2.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.2.0)\n stringi       1.7.8   2022-07-11 [1] CRAN (R 4.2.0)\n stringr       1.4.1   2022-08-20 [1] CRAN (R 4.2.0)\n xfun          0.32    2022-08-10 [1] CRAN (R 4.2.0)\n yaml          2.3.5   2022-02-21 [1] CRAN (R 4.2.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.2/Resources/library\n\n─ Python configuration ───────────────────────────────────────────────────────\n python:         /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/bin/python\n libpython:      /usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/lib/python3.11/config-3.11-darwin/libpython3.11.dylib\n pythonhome:     /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site:/Users/jack/Desktop/PhD/Research/Python_Envs/personal_site\n version:        3.11.3 (main, Apr  7 2023, 19:25:52) [Clang 14.0.0 (clang-1400.0.29.202)]\n numpy:          /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/lib/python3.11/site-packages/numpy\n numpy_version:  1.23.5\n \n NOTE: Python version was forced by use_python function\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [
      "CellRank_Tutorial_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}