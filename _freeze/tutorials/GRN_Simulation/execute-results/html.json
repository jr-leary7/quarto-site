{
  "hash": "0f5d9621710d0567f5ccbc2bb23fe707",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Simulating Trajectory Gene Regulatory Networks via `dyngen`\"\nauthor:\n  name: Jack R. Leary\n  email: j.leary@ufl.edu\n  orcid: 0009-0004-8821-3269\n  affiliations:\n    - name: University of Florida\n      department: Department of Biostatistics \n      city: Gainesville\n      state: FL\ndate: today\ndate-format: long\nformat:\n  html:\n    code-fold: show\n    code-copy: true\n    code-tools: true\n    toc: true\n    toc-depth: 2\n    embed-resources: true\n    fig-format: retina\n    fig-width: 9\n    fig-height: 6\n    df-print: kable\n    link-external-newwindow: true\n    tbl-cap-location: bottom\n    fig-cap-location: bottom\n    number-sections: true\nexecute:\n  cache: false\n  freeze: auto\n---\n\n\n\n\n# Introduction {#sec-introduction}\n\nAs 2024 begins, a concept I've been very interested in is gene regulatory networks (GRNs), specifically how they function during developmental biological processes such as hematopoesis, neurogenesis, etc. As such, I've been prototyping some methods for trajectory GRN estimation & downstream analysis. This has necessarily led to the need for a ground-truth network against which I can compare GRN estimation tools. Most published GRN methods use ChIP-seq or ATAC-seq datasets as a silver-standard source of truth, since simulating GRNs is complex and difficult. To my knowledge, the only tool that exists that implements GRN-based scRNA-seq trajectory simulation is [`dyngen`](https://dyngen.dynverse.org/index.html). However, it isn't the easiest tool to use, hence why I've decided to put together a guide for 1) simulating a GRN and 2) checking several estimation methods against the ground truth network. Skip to @sec-sims for the simulation, and @sec-analysis for the method comparisons. \n\n# Libraries {#sec-libraries}\n\nFirst we load the packages we'll need for our analysis. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(epoch)      # dynamic GRN estimation\nlibrary(dplyr)      # data manipulation\nlibrary(Seurat)     # scRNA-seq tools\nlibrary(dyngen)     # simulations\nlibrary(scLANE)     # trajectory DE\nlibrary(ggplot2)    # pretty plots\nlibrary(foreach)    # parallel for-loops\nlibrary(patchwork)  # plot combination\nlibrary(slingshot)  # pseudotime estimation\nrename <- dplyr::rename\n```\n:::\n\n\n# Helper functions {#sec-fns}\n\nWe define a utility function to make our plot legends easier to read. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nguide_umap <- function(key.size = 4) {\n  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = key.size,\n                                                                    alpha = 1, \n                                                                    stroke = 0.25)))\n}\n```\n:::\n\n\nAnd consistent color palettes will make our plots easier to understand. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npalette_cluster <- paletteer::paletteer_d(\"ggsci::nrc_npg\")\npalette_heatmap <- paletteer::paletteer_d(\"MetBrewer::Hiroshige\", direction = -1)\n```\n:::\n\n\nLastly, we load in a function [I wrote previously](https://jr-leary7.github.io/quarto-site/tutorials/Trajectory_GRN.html) that estimates a trajectory GRN using XGBoost. Expand the code block below for details. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nestimateTGRN <- function(dyn.mat = NULL,\n                         expr.mat = NULL, \n                         dyn.genes = NULL, \n                         tx.factors = NULL, \n                         cor.method = \"spearman\",\n                         n.cores = 4L, \n                         verbose = TRUE, \n                         random.seed = 312) {\n  # check inputs \n  if (is.null(expr.mat) || is.null(dyn.mat) || is.null(dyn.genes) || is.null(tx.factors)) { stop(\"Arguments to estimateTGRN() are missing.\") }\n  # identify dynamic TFs\n  tx.factors <- tx.factors[tx.factors %in% dyn.genes]\n  # set up progress bar if desired\n  if (verbose) {\n    withr::with_output_sink(tempfile(), {\n      pb <- utils::txtProgressBar(0, length(dyn.genes), style = 3)\n    })\n    progress_fun <- function(n) utils::setTxtProgressBar(pb, n)\n    snow_opts <- list(progress = progress_fun)\n  } else {\n    snow_opts <- list()\n  }\n  # set up parallel processing\n  if (n.cores > 1L) {\n    cl <- parallel::makeCluster(n.cores)\n    doSNOW::registerDoSNOW(cl)\n  } else {\n    cl <- foreach::registerDoSEQ()\n  }\n  # set up LightGBM model settings\n  lgbm_params <- list(objective = \"gamma\", \n                      tree_learner = \"serial\", \n                      metric = \"l2\", \n                      boosting_type = \"dart\",\n                      device = \"cpu\",\n                      num_threads = 1L, \n                      seed = random.seed)\n  # estimate trajectory GRN\n  grn_res <- foreach::foreach(g = seq(dyn.genes), \n                              .combine = \"list\",\n                              .multicombine = ifelse(length(dyn.genes) > 1, TRUE, FALSE),\n                              .maxcombine = ifelse(length(dyn.genes) > 1, length(dyn.genes), 2),\n                              .packages = c(\"lightgbm\", \"dplyr\"),\n                              .errorhandling = \"pass\",\n                              .inorder = TRUE,\n                              .verbose = FALSE,\n                              .options.snow = snow_opts) %dopar% {\n                                feature_mat <- dyn.mat[, tx.factors]\n                                feature_mat <- feature_mat[, colnames(feature_mat) != dyn.genes[g]]\n                                resp_var <- dyn.mat[, dyn.genes[g]]\n                                lgbm_data <- lightgbm::lgb.Dataset(data = feature_mat, label = resp_var)\n                                lgbm_cv <- lightgbm::lgb.cv(params = lgbm_params, \n                                                            data = lgbm_data, \n                                                            nrounds = 100L, \n                                                            nfold = 5L, \n                                                            stratified = FALSE)\n                                lgbm_model <- lightgbm::lgb.train(params = lgbm_params, \n                                                                  data = lgbm_data, \n                                                                  nrounds = lgbm_cv$best_iter)\n                                imp_table <- as.data.frame(lightgbm::lgb.importance(lgbm_model)) %>% \n                                             dplyr::mutate(Target_Gene = dyn.genes[g],\n                                                           Target_Gene_Type = dplyr::if_else(Target_Gene %in% tx.factors, \"TF\", \"Non-TF\"), \n                                                           .before = 1)\n                                imp_table\n                              }\n  names(grn_res) <- dyn.genes\n  if (n.cores > 1L) {\n    parallel::stopCluster(cl)\n  }\n  # format GRN table\n  grn_table <- purrr::imap(grn_res, \\(x, y) {\n    if (!inherits(x, \"data.frame\")) {\n      empty_res <- data.frame(Target_Gene = y, \n                              Target_Gene_Type = ifelse(y %in% tx.factors, \"TF\", \"Non-TF\"), \n                              Feature = NA_character_, \n                              Gain = NA_real_, \n                              Cover = NA_real_, \n                              Frequency = NA_real_)\n      return(empty_res)\n    } else {\n      return(x)\n    }\n  })\n  # add mean rank of gain & frequency\n  grn_table <- purrr::reduce(grn_table, rbind) %>% \n               dplyr::select(-Cover) %>% \n               dplyr::rename(Tx_Factor = Feature) %>% \n               dplyr::filter(!is.na(Target_Gene), \n                             !is.na(Tx_Factor)) %>% \n               dplyr::arrange(Tx_Factor, dplyr::desc(Frequency)) %>% \n               dplyr::with_groups(Tx_Factor, \n                                  dplyr::mutate, \n                                  Frequency_Rank = dplyr::row_number()) %>% \n               dplyr::arrange(Tx_Factor, dplyr::desc(Gain)) %>% \n               dplyr::with_groups(Tx_Factor, \n                                  dplyr::mutate, \n                                  Gain_Rank = dplyr::row_number()) %>% \n               dplyr::rowwise() %>% \n               dplyr::mutate(Mean_Rank = mean(dplyr::c_across(c(Frequency_Rank, Gain_Rank)))) %>% \n               dplyr::ungroup() %>% \n               dplyr::arrange(Tx_Factor, Mean_Rank) %>% \n               dplyr::mutate(Mean_Rank_Weight = 1 / Mean_Rank)\n  # add correlation & mutual information b/t TF and each target gene (dynamics and normalized expression)\n  dyn_cormat <- stats::cor(dyn.mat[, dyn.genes], method = cor.method)\n  expr_cormat <- stats::cor(expr.mat[, dyn.genes], method = cor.method)\n  dyn_mimat <- minet::build.mim(dyn.mat[, dyn.genes], \n                                estimator = \"mi.empirical\", \n                                disc = \"equalwidth\")\n  expr_mimat <- minet::build.mim(expr.mat[, dyn.genes],  \n                                 estimator = \"mi.empirical\", \n                                 disc = \"equalwidth\")\n  grn_table <- dplyr::mutate(grn_table, \n                             Dyn_Cor = NA_real_, \n                             Exp_Cor = NA_real_, \n                             Dyn_MI = NA_real_, \n                             Exp_MI = NA_real_)\n  for (i in seq(nrow(grn_table))) {\n    grn_table$Dyn_Cor[i] <- dyn_cormat[grn_table$Target_Gene[i], grn_table$Tx_Factor[i]]\n    grn_table$Dyn_MI[i] <- dyn_mimat[grn_table$Target_Gene[i], grn_table$Tx_Factor[i]]\n    grn_table$Exp_Cor[i] <- expr_cormat[grn_table$Target_Gene[i], grn_table$Tx_Factor[i]]\n    grn_table$Exp_MI[i] <- expr_mimat[grn_table$Target_Gene[i], grn_table$Tx_Factor[i]]\n  }\n  grn_table <- dplyr::mutate(grn_table, State = dplyr::if_else(Dyn_Cor < 0, \"Repression\", \"Activation\"))\n  return(grn_table)\n}\n```\n:::\n\n\n# Simulating scRNA-seq data {#sec-sims}\n\nThe `dyngen` workflow starts with what they call a *backbone*, which specifies the shape of the cellular manifold. In this case we opt for a simple bifurcating trajectory composed of 2500 cells. The number of transcription factors (TFs) is a random variable, but we specify 500 target genes and 5000 housekeeping genes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_backbone <- backbone_bifurcating()\nsim_config <- initialise_model(sim_backbone,\n                               num_cells = 4000, \n                               num_tfs = nrow(sim_backbone$module_info),\n                               num_targets = 500,\n                               num_hks = 4000,\n                               distance_metric = \"pearson\", \n                               num_cores = 4L, \n                               verbose = FALSE)\n```\n:::\n\n\nWe visualize the gene module structure of our trajectory; note that we simulated `nrow(sim_backbone$module_info)` modules, each with a controlling TF. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np1 <- plot_backbone_modulenet(sim_config) + \n      labs(x = \"Dim 1\", \n           y = \"Dim 2\", \n           edge_width = \"Strength\", \n           color = \"Gene Module\") + \n      theme_scLANE(umap = TRUE) + \n      theme(legend.box = \"horizontal\")\np1\n```\n\n::: {.cell-output-display}\n![The cascading gene module structure of our trajectory.](GRN_Simulation_files/figure-html/fig-str1-1.png){#fig-str1 width=768}\n:::\n:::\n\n\nUsing the gene modules, we estimate our TF network.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntf_model <- generate_tf_network(sim_config)\n```\n:::\n\n\nWe visualize the relationships between our TFs. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np2 <- plot_feature_network(tf_model, show_targets = FALSE) + \n      labs(x = \"Dim 1\", \n           y = \"Dim 2\", \n           size = \"TF Status\", \n           color = \"Gene Module\") + \n      theme_scLANE(umap = TRUE) + \n      theme(legend.box = \"horizontal\") + \n      guides(color = guide_legend(override.aes = list(size = 4, alpha = 1)))\np2\n```\n\n::: {.cell-output-display}\n![Directional relationships between the TFs that control each gene module.](GRN_Simulation_files/figure-html/fig-str2-1.png){#fig-str2 width=768}\n:::\n:::\n\n\nNext, we generate our target and housekeeping genes, along with the splicing kinetics for all genes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntf_model <- generate_feature_network(tf_model) %>% \n            generate_kinetics()\n```\n:::\n\n\nThis extraordinarily messy (thanks to the large number of genes) plot shows our TFs, their targets, and the non-regulatory housekeeping genes. The `dyngen` documentation specifies that TFs are regulated solely by TFs, target genes may be regulated by TFs or other target genes, and housekeeping genes are not part of regulatory structure of the trajectory. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np3 <- plot_feature_network(tf_model, show_hks = TRUE) + \n      labs(x = \"Dim 1\", \n           y = \"Dim 2\", \n           size = \"TF Status\", \n           color = \"Gene Module\") + \n      theme_scLANE(umap = TRUE) + \n      theme(legend.box = \"horizontal\") + \n      guides(color = guide_legend(override.aes = list(size = 4, alpha = 1), order = 1))\np3\n```\n\n::: {.cell-output-display}\n![The directed structure of the relationships between all genes - TFs, target genes, and housekeeping genes.](GRN_Simulation_files/figure-html/fig-str3-1.png){#fig-str3 width=768}\n:::\n:::\n\n\nContinuing on, we use the following sequence of functions to simulate cells along our bifurcating trajectory. \n\n::: {.callout-warning}\nIf you're using a local machine (like I am), this step will take 30 or so minutes to run. \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntf_model <- generate_gold_standard(tf_model) %>% \n            generate_cells() %>% \n            generate_experiment()\n```\n:::\n\n\nFinally, we convert our simulated dataset to a `Seurat` object for easier downstream analysis. In addition, we add a normalized ground-truth pseudotime that exists on $[0, 1]$ for aesthetic purposes. \n \n\n::: {.cell}\n\n```{.r .cell-code}\nseu <- as_seurat(tf_model)\nseu@meta.data <- mutate(seu@meta.data, \n                        sim_time_norm = (sim_time - min(sim_time)) / (max(sim_time) - min(sim_time)), \n                        .before = 7)\n```\n:::\n\n\nThe ground-truth pseudotime values are stored in **sim_time**, and sequencing depth and feature counts have already been computed for total RNA, unspliced & spliced RNA, and protein. \n\n\n::: {#tbl-metadata .cell tbl-cap='The cell-level metadata of our Seurat object.'}\n\n```{.r .cell-code  code-fold=\"true\"}\nslice_sample(seu@meta.data, n = 10) %>% \n  kableExtra::kable(digits = 2, booktabs = TRUE) %>% \n  kableExtra::kable_classic(\"hover\", full_width = FALSE)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-classic lightable-hover\" style='font-family: \"Arial Narrow\", \"Source Sans Pro\", sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> orig.ident </th>\n   <th style=\"text-align:right;\"> nCount_RNA </th>\n   <th style=\"text-align:right;\"> nFeature_RNA </th>\n   <th style=\"text-align:right;\"> step_ix </th>\n   <th style=\"text-align:right;\"> simulation_i </th>\n   <th style=\"text-align:right;\"> sim_time </th>\n   <th style=\"text-align:right;\"> sim_time_norm </th>\n   <th style=\"text-align:right;\"> nCount_spliced </th>\n   <th style=\"text-align:right;\"> nFeature_spliced </th>\n   <th style=\"text-align:right;\"> nCount_unspliced </th>\n   <th style=\"text-align:right;\"> nFeature_unspliced </th>\n   <th style=\"text-align:right;\"> nCount_protein </th>\n   <th style=\"text-align:right;\"> nFeature_protein </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> cell2381 </td>\n   <td style=\"text-align:left;\"> SeuratProject </td>\n   <td style=\"text-align:right;\"> 2910 </td>\n   <td style=\"text-align:right;\"> 1683 </td>\n   <td style=\"text-align:right;\"> 147 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 400.01 </td>\n   <td style=\"text-align:right;\"> 0.52 </td>\n   <td style=\"text-align:right;\"> 2063 </td>\n   <td style=\"text-align:right;\"> 1328 </td>\n   <td style=\"text-align:right;\"> 847 </td>\n   <td style=\"text-align:right;\"> 722 </td>\n   <td style=\"text-align:right;\"> 173650007 </td>\n   <td style=\"text-align:right;\"> 3933 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> cell1922 </td>\n   <td style=\"text-align:left;\"> SeuratProject </td>\n   <td style=\"text-align:right;\"> 3436 </td>\n   <td style=\"text-align:right;\"> 1823 </td>\n   <td style=\"text-align:right;\"> 161 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 456.01 </td>\n   <td style=\"text-align:right;\"> 0.59 </td>\n   <td style=\"text-align:right;\"> 2471 </td>\n   <td style=\"text-align:right;\"> 1444 </td>\n   <td style=\"text-align:right;\"> 965 </td>\n   <td style=\"text-align:right;\"> 796 </td>\n   <td style=\"text-align:right;\"> 175090008 </td>\n   <td style=\"text-align:right;\"> 3933 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> cell3169 </td>\n   <td style=\"text-align:left;\"> SeuratProject </td>\n   <td style=\"text-align:right;\"> 2252 </td>\n   <td style=\"text-align:right;\"> 1412 </td>\n   <td style=\"text-align:right;\"> 2954 </td>\n   <td style=\"text-align:right;\"> 13 </td>\n   <td style=\"text-align:right;\"> 204.01 </td>\n   <td style=\"text-align:right;\"> 0.27 </td>\n   <td style=\"text-align:right;\"> 1642 </td>\n   <td style=\"text-align:right;\"> 1103 </td>\n   <td style=\"text-align:right;\"> 610 </td>\n   <td style=\"text-align:right;\"> 536 </td>\n   <td style=\"text-align:right;\"> 172936840 </td>\n   <td style=\"text-align:right;\"> 3876 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> cell3888 </td>\n   <td style=\"text-align:left;\"> SeuratProject </td>\n   <td style=\"text-align:right;\"> 2331 </td>\n   <td style=\"text-align:right;\"> 1444 </td>\n   <td style=\"text-align:right;\"> 7469 </td>\n   <td style=\"text-align:right;\"> 32 </td>\n   <td style=\"text-align:right;\"> 176.00 </td>\n   <td style=\"text-align:right;\"> 0.23 </td>\n   <td style=\"text-align:right;\"> 1679 </td>\n   <td style=\"text-align:right;\"> 1144 </td>\n   <td style=\"text-align:right;\"> 652 </td>\n   <td style=\"text-align:right;\"> 570 </td>\n   <td style=\"text-align:right;\"> 172914222 </td>\n   <td style=\"text-align:right;\"> 3903 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> cell807 </td>\n   <td style=\"text-align:left;\"> SeuratProject </td>\n   <td style=\"text-align:right;\"> 1439 </td>\n   <td style=\"text-align:right;\"> 1048 </td>\n   <td style=\"text-align:right;\"> 4580 </td>\n   <td style=\"text-align:right;\"> 20 </td>\n   <td style=\"text-align:right;\"> 44.01 </td>\n   <td style=\"text-align:right;\"> 0.06 </td>\n   <td style=\"text-align:right;\"> 1056 </td>\n   <td style=\"text-align:right;\"> 806 </td>\n   <td style=\"text-align:right;\"> 383 </td>\n   <td style=\"text-align:right;\"> 355 </td>\n   <td style=\"text-align:right;\"> 171761100 </td>\n   <td style=\"text-align:right;\"> 3857 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> cell1707 </td>\n   <td style=\"text-align:left;\"> SeuratProject </td>\n   <td style=\"text-align:right;\"> 2577 </td>\n   <td style=\"text-align:right;\"> 1529 </td>\n   <td style=\"text-align:right;\"> 4872 </td>\n   <td style=\"text-align:right;\"> 21 </td>\n   <td style=\"text-align:right;\"> 260.01 </td>\n   <td style=\"text-align:right;\"> 0.34 </td>\n   <td style=\"text-align:right;\"> 1892 </td>\n   <td style=\"text-align:right;\"> 1196 </td>\n   <td style=\"text-align:right;\"> 685 </td>\n   <td style=\"text-align:right;\"> 608 </td>\n   <td style=\"text-align:right;\"> 172955001 </td>\n   <td style=\"text-align:right;\"> 3893 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> cell3909 </td>\n   <td style=\"text-align:left;\"> SeuratProject </td>\n   <td style=\"text-align:right;\"> 4764 </td>\n   <td style=\"text-align:right;\"> 2134 </td>\n   <td style=\"text-align:right;\"> 1830 </td>\n   <td style=\"text-align:right;\"> 8 </td>\n   <td style=\"text-align:right;\"> 468.01 </td>\n   <td style=\"text-align:right;\"> 0.61 </td>\n   <td style=\"text-align:right;\"> 3477 </td>\n   <td style=\"text-align:right;\"> 1792 </td>\n   <td style=\"text-align:right;\"> 1287 </td>\n   <td style=\"text-align:right;\"> 996 </td>\n   <td style=\"text-align:right;\"> 177649564 </td>\n   <td style=\"text-align:right;\"> 3988 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> cell2405 </td>\n   <td style=\"text-align:left;\"> SeuratProject </td>\n   <td style=\"text-align:right;\"> 3333 </td>\n   <td style=\"text-align:right;\"> 1776 </td>\n   <td style=\"text-align:right;\"> 7047 </td>\n   <td style=\"text-align:right;\"> 30 </td>\n   <td style=\"text-align:right;\"> 392.01 </td>\n   <td style=\"text-align:right;\"> 0.51 </td>\n   <td style=\"text-align:right;\"> 2401 </td>\n   <td style=\"text-align:right;\"> 1437 </td>\n   <td style=\"text-align:right;\"> 932 </td>\n   <td style=\"text-align:right;\"> 764 </td>\n   <td style=\"text-align:right;\"> 175397683 </td>\n   <td style=\"text-align:right;\"> 3951 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> cell2122 </td>\n   <td style=\"text-align:left;\"> SeuratProject </td>\n   <td style=\"text-align:right;\"> 2312 </td>\n   <td style=\"text-align:right;\"> 1437 </td>\n   <td style=\"text-align:right;\"> 1801 </td>\n   <td style=\"text-align:right;\"> 8 </td>\n   <td style=\"text-align:right;\"> 352.01 </td>\n   <td style=\"text-align:right;\"> 0.46 </td>\n   <td style=\"text-align:right;\"> 1694 </td>\n   <td style=\"text-align:right;\"> 1128 </td>\n   <td style=\"text-align:right;\"> 618 </td>\n   <td style=\"text-align:right;\"> 550 </td>\n   <td style=\"text-align:right;\"> 172296747 </td>\n   <td style=\"text-align:right;\"> 3911 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> cell755 </td>\n   <td style=\"text-align:left;\"> SeuratProject </td>\n   <td style=\"text-align:right;\"> 3070 </td>\n   <td style=\"text-align:right;\"> 1698 </td>\n   <td style=\"text-align:right;\"> 5361 </td>\n   <td style=\"text-align:right;\"> 23 </td>\n   <td style=\"text-align:right;\"> 312.01 </td>\n   <td style=\"text-align:right;\"> 0.41 </td>\n   <td style=\"text-align:right;\"> 2286 </td>\n   <td style=\"text-align:right;\"> 1392 </td>\n   <td style=\"text-align:right;\"> 784 </td>\n   <td style=\"text-align:right;\"> 664 </td>\n   <td style=\"text-align:right;\"> 175106616 </td>\n   <td style=\"text-align:right;\"> 3929 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n# Analysis {#sec-analysis}\n\n## Preprocessing\n\nWe run the cells through a standard processing pipeline consisting of normalization, highly-variable gene (HVG) identification, linear dimension reduction with PCA followed by nonlinear dimension reduction with UMAP, and a graph-based clustering via the Leiden algorithm. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu <- NormalizeData(seu, verbose = FALSE) %>% \n       FindVariableFeatures(nfeatures = 3000, verbose = FALSE) %>% \n       ScaleData(verbose = FALSE) %>% \n       RunPCA(npcs = 50, \n              approx = TRUE, \n              seed.use = 312, \n              verbose = FALSE) %>% \n       RunUMAP(reduction = \"pca\", \n               dims = 1:30, \n               n.components = 2, \n               metric = \"cosine\", \n               seed.use = 312, \n               verbose = FALSE) %>% \n       FindNeighbors(reduction = \"pca\", \n                     k.param = 20,\n                     nn.method = \"annoy\", \n                     annoy.metric = \"cosine\", \n                     verbose = FALSE) %>% \n       FindClusters(algorithm = 4, \n                    method = \"igraph\", \n                    resolution = 0.3, \n                    random.seed = 312, \n                    verbose = FALSE)\n```\n:::\n\n\nOur UMAP embedding has retained the bifurcating structure of our simulated trajectory well, and our clustering appears correct too. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np4 <- as.data.frame(Embeddings(seu, \"umap\")) %>% \n      mutate(leiden = seu$seurat_clusters) %>% \n      ggplot(aes(x = umap_1, y = umap_2, color = leiden)) + \n      geom_point(size = 1.75, \n                 stroke = 0, \n                 alpha = 0.75) + \n      scale_color_manual(values = palette_cluster) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           color = \"Leiden\") +\n      theme_scLANE(umap = TRUE) + \n      guide_umap()\np5 <- as.data.frame(Embeddings(seu, \"umap\")) %>% \n      mutate(PT = seu$sim_time_norm) %>% \n      ggplot(aes(x = umap_1, y = umap_2, color = PT)) + \n      geom_point(size = 1.75, \n                 stroke = 0, \n                 alpha = 0.75) + \n      scale_color_gradientn(colors = palette_heatmap) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           color = \"Pseudotime\") +\n      scLANE::theme_scLANE(umap = TRUE)\np6 <- (p4 | p5) + \n      plot_layout(guides = \"collect\", axes = \"collect\")\np6\n```\n\n::: {.cell-output-display}\n![UMAP embedding colored by Leiden cluster ID (left) and ground-truth pseudotime (right).](GRN_Simulation_files/figure-html/fig-umap1-1.png){#fig-umap1 width=768}\n:::\n:::\n\n\nVisualizing the spread of pseudotime values per-cluster reveals that cluster 1 should the starting (or root) node, and clusters 3 & 5 the terminal (or leaf) nodes. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np7 <- data.frame(leiden = seu$seurat_clusters, \n                 PT = seu$sim_time_norm) %>% \n      ggplot(aes(x = leiden, y = PT, color = leiden)) + \n      ggbeeswarm::geom_quasirandom(size = 1.5, \n                                   stroke = 0,\n                                   alpha = 0.75) + \n      stat_summary(color = \"black\", \n                   geom = \"point\", \n                   fun = \"mean\", \n                   size = 3) + \n      scale_color_manual(values = palette_cluster) + \n      labs(y = \"Pseudotime\", color = \"Leiden\") + \n      theme_scLANE() + \n      theme(axis.title.x = element_blank()) + \n      guide_umap()\np7\n```\n\n::: {.cell-output-display}\n![Beeswarm plot displaying the distribution of ground-truth pseudotime per Leiden cluster.](GRN_Simulation_files/figure-html/fig-PT_beeswarm-1.png){#fig-PT_beeswarm width=576}\n:::\n:::\n\n\n## Pseudotime estimation\n\nSince `dyngen` doesn't explicitly assign each cell to a lineage (at least as far as I can tell), we use `slingshot` to estimate a lineage-specific pseudotime. As per @fig-PT_beeswarm, we specify cluster 1 as the root of the trajectory. Afterwards, we create an overall pseudotime by mean-aggregating the per-lineage pseudotime values assigned to each cell. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsling_res <- slingshot(Embeddings(seu, \"umap\"), \n                       clusterLabels = seu$seurat_clusters, \n                       start.clus = c(\"1\"))\nsling_curves <- slingCurves(sling_res, as.df = TRUE)\nsling_mst <- slingMST(sling_res, as.df = TRUE)\nsling_pt <- as.data.frame(slingPseudotime(sling_res)) %>% \n            rowwise() %>% \n            mutate(PT_Overall = mean(c_across(starts_with(\"Lineage\")), na.rm = TRUE)) %>% \n            ungroup() %>% \n            mutate(across(c(starts_with(\"Lineage\"), PT_Overall), \n                          \\(x) (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))))\nseu <- AddMetaData(seu, \n                   metadata = sling_pt$PT_Overall, \n                   col.name = \"PT_Overall\")\n```\n:::\n\n\nThe Spearman correlation between the true & estimated pseudotimes for each cell is quite high, indicating that `slingshot` did a solid job recapitulating the ground truth. The fit isn't perfect, but it looks good enough to justify using the lineage-specific estimated pseudotime. This will allow us to build a GRN per-lineage, which is more useful than a single overall network. \n\n\n::: {.cell}\n\n```{.r .cell-code}\np8 <- data.frame(PT_true = seu$sim_time_norm, \n                 PT_est = seu$PT_Overall, \n                 leiden = seu$seurat_clusters) %>% \n      ggplot(aes(x = PT_true, y = PT_est)) + \n      geom_point(aes(color = leiden), \n                 size = 1.5, \n                 stroke = 0, \n                 alpha = 0.75) + \n      geom_smooth(method = \"lm\", color = \"black\") + \n      ggpubr::stat_cor(method = \"spearman\", \n                       cor.coef.name = \"rho\", \n                       geom = \"label\", \n                       label.x = 0.5, \n                       label.y = 0.25) + \n      scale_x_continuous(limits = c(0, 1)) + \n      scale_y_continuous(limits = c(0, 1)) + \n      scale_color_manual(values = palette_cluster) + \n      labs(x = \"True Pseudotime\", \n           y = \"Estimated Pseudotime\", \n           color = \"Leiden\") + \n      theme_scLANE() + \n      guide_umap()\np8\n```\n\n::: {.cell-output-display}\n![The Spearman correlation between true & estimated pseudotime. A fit from a simple linear model is overlaid in black.](GRN_Simulation_files/figure-html/fig-PT_cor-1.png){#fig-PT_cor width=480}\n:::\n:::\n\n\nThe minimum spanning tree (MST) and principal curves from `slingshot` appear to match our ground-truth trajectory structure quite well. In addition, as shown above in @fig-PT_cor the estimated pseudotime closely matches the ground truth. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np9 <- data.frame(Embeddings(seu, \"umap\")) %>% \n      mutate(leiden = seu$seurat_clusters) %>% \n      ggplot(aes(x = umap_1, y = umap_2, color = leiden)) + \n      geom_point(size = 1.5, \n                 stroke = 0, \n                 alpha = 0.75) + \n      geom_path(data = sling_mst, mapping = aes(x = umap_1, y = umap_2, group = Lineage), \n                linewidth = 1.25, \n                color = \"black\") + \n      geom_point(data = sling_mst, mapping = aes(x = umap_1, y = umap_2, fill = Cluster), \n                color = \"black\", \n                shape = 21, \n                size = 4.5, \n                stroke = 1.25, \n                show.legend = FALSE) + \n      scale_color_manual(values = palette_cluster) + \n      scale_fill_manual(values = palette_cluster) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           color = \"Leiden\") + \n      theme_scLANE(umap = TRUE) +  \n      guide_umap()\np10 <- data.frame(Embeddings(seu, \"umap\")) %>% \n       mutate(leiden = seu$seurat_clusters) %>% \n       ggplot(aes(x = umap_1, y = umap_2, color = leiden)) + \n       geom_point(size = 1.5, \n                  stroke = 0, \n                  alpha = 0.75) + \n       geom_path(data = sling_curves,\n                 mapping = aes(x = umap_1, y = umap_2, group = Lineage), \n                 color = \"black\", \n                 linewidth = 1.5, \n                 alpha = 0.75, \n                 lineend = \"round\") + \n       scale_color_manual(values = palette_cluster) + \n       labs(x = \"UMAP 1\", \n            y = \"UMAP 2\", \n            color =  \"Leiden\") + \n       theme_scLANE(umap = TRUE) + \n       guide_umap()\np11 <- select(sling_pt, starts_with(\"Lineage\")) %>% \n       mutate(cell = colnames(seu), \n              umap_1 = seu@reductions$umap@cell.embeddings[, 1], \n              umap_2 = seu@reductions$umap@cell.embeddings[, 2], \n              .before = 1) %>% \n       tidyr::pivot_longer(cols = starts_with(\"Lineage\"), \n                           names_to = \"lineage\",\n                           values_to = \"pseudotime\") %>% \n       ggplot(aes(x = umap_1, y = umap_2, color = pseudotime)) + \n       facet_wrap(~lineage) + \n       geom_point(size = 1.5, \n                  stroke = 0, \n                  alpha = 0.75) + \n       scale_color_gradientn(colors = palette_heatmap) + \n       labs(x = \"UMAP 1\", \n            y = \"UMAP 2\", \n            color = \"Pseudotime\") + \n       theme_scLANE(umap = TRUE)\np12 <- (((p9 | p10) + plot_layout(axes = \"collect\")) / p11) + \n       plot_layout(guides = \"collect\")\np12\n```\n\n::: {.cell-output-display}\n![UMAP embedding with MST from Slinghot overlaid.](GRN_Simulation_files/figure-html/fig-umap_MST-1.png){#fig-umap_MST width=768}\n:::\n:::\n\n\n## Estimating trajectory dynamics\n\nUsing `scLANE` ([GitHub](https://github.com/jr-leary7/scLANE)) we perform trajectory differential expression (DE) testing on the set of HVGs. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npt_df <- select(sling_pt, -PT_Overall)\ncell_offset <- createCellOffset(seu)\nscLANE_models <- testDynamic(seu, \n                             pt = pt_df, \n                             genes = VariableFeatures(seu), \n                             size.factor.offset = cell_offset,\n                             n.cores = 6L, \n                             verbose = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nscLANE testing completed for 3000 genes across 2 lineages in 21.853 mins\n```\n\n\n:::\n\n```{.r .cell-code}\nscLANE_de_res <- getResultsDE(scLANE_models)\n```\n:::\n\n\nThe top ten genes from `scLANE` are shown in @tbl-scLANE_res. \n\n\n::: {#tbl-scLANE_res .cell tbl-cap='The top-10 trajectory DE genes from scLANE.'}\n\n```{.r .cell-code  code-fold=\"true\"}\nslice_head(scLANE_de_res, n = 10) %>% \n  select(Gene, Lineage, Test_Stat, P_Val_Adj, Gene_Dynamic_Lineage, Gene_Dynamic_Overall) %>% \n  mutate(Gene_Dynamic_Lineage = if_else(Gene_Dynamic_Lineage == 1, \"Dynamic\", \"Static\"), \n         Gene_Dynamic_Overall = if_else(Gene_Dynamic_Overall == 1, \"Dynamic\", \"Static\")) %>% \n  kableExtra::kable(digits = 2, \n                    booktabs = TRUE, \n                    col.names = c(\"Gene\", \"Lineage\", \"LRT Stat.\", \"Adj. P-value\", \"Lineage Status\", \"Overall Status\")) %>% \n  kableExtra::kable_classic(\"hover\", full_width = FALSE)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-classic lightable-hover\" style='font-family: \"Arial Narrow\", \"Source Sans Pro\", sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Gene </th>\n   <th style=\"text-align:left;\"> Lineage </th>\n   <th style=\"text-align:right;\"> LRT Stat. </th>\n   <th style=\"text-align:right;\"> Adj. P-value </th>\n   <th style=\"text-align:left;\"> Lineage Status </th>\n   <th style=\"text-align:left;\"> Overall Status </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> B5-TF1 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 1855.07 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Target180 </td>\n   <td style=\"text-align:left;\"> B </td>\n   <td style=\"text-align:right;\"> 1799.82 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Target158 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 1725.68 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Target254 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 1683.16 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Target414 </td>\n   <td style=\"text-align:left;\"> B </td>\n   <td style=\"text-align:right;\"> 1637.27 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Target174 </td>\n   <td style=\"text-align:left;\"> B </td>\n   <td style=\"text-align:right;\"> 1613.97 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Target81 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 1584.33 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Target257 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 1567.35 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Target92 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 1519.12 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Target7 </td>\n   <td style=\"text-align:left;\"> A </td>\n   <td style=\"text-align:right;\"> 1424.00 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n   <td style=\"text-align:left;\"> Dynamic </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nWe identify a set of 202 dynamic genes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndyn_genes <- filter(scLANE_de_res, Gene_Dynamic_Overall == 1) %>% \n             distinct(Gene) %>% \n             pull(Gene)\n```\n:::\n\n\nNext, we pull a matrix of gene dynamics for each of the dynamic genes using the `smoothedCountsMatrix()` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_dynamics <- smoothedCountsMatrix(scLANE_models, \n                                      size.factor.offset = cell_offset, \n                                      pt = pt_df,\n                                      genes = dyn_genes, \n                                      log1p.norm = TRUE)\n```\n:::\n\n\n## Building a GRN from scratch\n\nWe'll start by building a GRN on our own with `scTIRN` (**s**ingle **c**ell **T**rajectory **I**nference via **R**egulatory **N**etworks) without using external packages. The main logic comes from the function `estimateTGRN()` defined in @sec-fns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntx_factors <- filter(seu@assays$RNA@meta.features, is_tf == TRUE) %>% \n              rownames()\nGRN_truth <- select(tf_model$feature_network, \n                    from, \n                    to, \n                    effect, \n                    strength) %>% \n             rename(Tx_Factor = from, \n                    Target_Gene = to) %>% \n             arrange(Tx_Factor, desc(strength)) %>% \n             mutate(Tx_Factor = gsub(\"_\", \"-\", Tx_Factor), \n                    Target_Gene = gsub(\"_\", \"-\", Target_Gene)) %>% \n             filter(!grepl(\"HK\", Tx_Factor), \n                    !grepl(\"Target\", Tx_Factor))\nGRN_lineage1 <- estimateTGRN(dyn.mat = gene_dynamics$Lineage_A, \n                             expr.mat = as.matrix(t(seu@assays$RNA@data[colnames(gene_dynamics$Lineage_A), !is.na(pt_df$Lineage1)])), \n                             dyn.genes = colnames(gene_dynamics$Lineage_A), \n                             tx.factors = tx_factors,\n                             n.cores = 6L, \n                             verbose = FALSE) %>% \n                mutate(Lineage = \"Lineage1\", .before = 1)\nGRN_lineage2 <- estimateTGRN(gene_dynamics$Lineage_B, \n                             expr.mat = as.matrix(t(seu@assays$RNA@data[colnames(gene_dynamics$Lineage_B), !is.na(pt_df$Lineage2)])), \n                             dyn.genes = colnames(gene_dynamics$Lineage_B), \n                             tx.factors = tx_factors,\n                             n.cores = 6L, \n                             verbose = FALSE) %>% \n                mutate(Lineage = \"Lineage2\", .before = 1)\nGRN_all <- bind_rows(GRN_lineage1, GRN_lineage2) %>% \n           arrange(Lineage, Target_Gene, desc(Mean_Rank)) %>% \n           with_groups(c(Lineage, Target_Gene), \n                       slice_head, \n                       n = 10)\n```\n:::\n\n\n### Estimating accuracy\n\nSince our simulation only defines the network over the entire dataset, instead of in a lineage-specific manner, we'll define `scTIRN` as being correct if a given TF-target gene link is recovered in either of the two lineage GRNs. In addition, we'll define the directionality as being correct if it is correct in either lineage. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nscTIRN_detected_vec <- scTIRN_dir_vec_lin1 <- scTIRN_dir_vec_lin2 <- vector(\"numeric\", nrow(GRN_truth))\nfor (i in seq(nrow(GRN_truth))) {\n  sub_df <- filter(GRN_all, \n                   Tx_Factor == GRN_truth$Tx_Factor[i], \n                   Target_Gene == GRN_truth$Target_Gene[i])\n scTIRN_detected_vec[i] <- ifelse(nrow(sub_df > 0), 1, 0)\n scTIRN_dir_lin1 <- filter(GRN_lineage1, \n                           Tx_Factor == GRN_truth$Tx_Factor[i], \n                           Target_Gene == GRN_truth$Target_Gene[i]) %>% \n                    pull(Dyn_Cor)\n scTIRN_dir_vec_lin1[i] <- ifelse(length(scTIRN_dir_lin1) != 0, scTIRN_dir_lin1, NA_real_)\n scTIRN_dir_lin2 <- filter(GRN_lineage2, \n                           Tx_Factor == GRN_truth$Tx_Factor[i], \n                           Target_Gene == GRN_truth$Target_Gene[i]) %>% \n                    pull(Dyn_Cor)\n scTIRN_dir_vec_lin2[i] <- ifelse(length(scTIRN_dir_lin1) != 0, scTIRN_dir_lin2, NA_real_)\n}\nGRN_truth <- mutate(GRN_truth, \n                    scTIRN_detected = scTIRN_detected_vec, \n                    scTIRN_direction_lineage1 = scTIRN_dir_vec_lin1,\n                    scTIRN_direction_lineage2 = scTIRN_dir_vec_lin2) %>% \n             mutate(scTIRN_dir_correct = case_when(effect == 1 & (scTIRN_direction_lineage1 > 0 | scTIRN_direction_lineage2 > 0) ~ 1, \n                                                   effect == -1 & (scTIRN_direction_lineage1 < 0 | scTIRN_direction_lineage2 < 0) ~ 1, \n                                                   TRUE ~ 0), \n                    scTIRN_fully_correct = if_else(scTIRN_detected == 1 & scTIRN_dir_correct == 1, 1, 0))\n```\n:::\n\n\nIn order to correctly estimate the accuracy of `scTIRN`, we first filter the ground-truth GRN to just the genes identified by `scLANE` as being dynamic over the trajectory, then estimate the proportion of the true TF to target gene links identified by our method. The accuracy looks pretty good!\n\n\n::: {#tbl-acc-scTIRN .cell tbl-cap='The accuracy of `scTIRN` when filtering to just the genes identified by `scLANE` as trajectory DE.'}\n\n```{.r .cell-code  code-fold=\"true\"}\nfilter(GRN_truth, Tx_Factor %in% dyn_genes) %>% \n  summarise(mu = mean(scTIRN_detected) * 100) %>% \n  kableExtra::kable(digits = 2, \n                    col.names = \"Accuracy\",\n                    booktabs = TRUE, \n                    align = \"c\") %>% \n  kableExtra::kable_classic(full_width = FALSE, \"hover\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-classic lightable-hover\" style='font-family: \"Arial Narrow\", \"Source Sans Pro\", sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'>\n <thead>\n  <tr>\n   <th style=\"text-align:center;\"> Accuracy </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;\"> 63.22 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Building a GRN with `epoch`\n\nNext, we use the `epoch` R package ([paper](https://doi.org/10.1016/j.stemcr.2021.12.018), [GitHub](https://github.com/CahanLab/epoch/)) to estimate a GRN for each lineage using the Pearson correlation of expression between dynamic genes. We start by identifying a set of genes dynamic across lineage 1 (as with `scLANE`, we test solely the HVG set used to build the trajectory), which we do by fitting GAMs using their `findDynGenes()` function. A quirk of the `epoch` method is that it's necessary to provide the cluster structure of the trajectory - in order, which we do based on @fig-umap_MST. Next, we construct the GRN & perform crossweighting - the goal of which is to reduce the occurrence of false positives (see their Methods for details). \n\n::: {.callout-note}\nThe authors show in their paper (see e.g., Figure 2) that the mutual information (MI) method with crossweighting is the best. However, their MI implementation is very slow, so I'm opting to use the Pearson correlation implementation instead. \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nepoch_expr_mat_lin1 <- as.matrix(seu@assays$RNA$data[VariableFeatures(seu), !is.na(sling_pt$Lineage1)])\nepoch_pt_df <- select(sling_pt, Lineage1) %>% \n               mutate(leiden = seu$seurat_clusters) %>% \n               filter(!is.na(Lineage1)) %>% \n               as.data.frame() %>% \n               magrittr::set_rownames(colnames(epoch_expr_mat_lin1))\nepoch_models_lin1 <- findDynGenes(epoch_expr_mat_lin1, \n                                  sampTab = epoch_pt_df, \n                                  path = c(\"1\", \"6\", \"7\", \"4\", \"5\"), \n                                  group_column = \"leiden\", \n                                  pseudotime_column = \"Lineage1\",\n                                  method = \"gam\")\nepoch_dyn_genes_lin1 <- names(epoch_models_lin1$genes)[epoch_models_lin1$genes < 0.01]\nepoch_dyn_genes_lin1 <- na.omit(epoch_dyn_genes_lin1)\nepoch_GRN_lin1 <- reconstructGRN(epoch_expr_mat_lin1, \n                                 tfs = tx_factors, \n                                 dgenes = epoch_dyn_genes_lin1, \n                                 method = \"pearson\")\nepoch_GRN_lin1 <- crossweight(epoch_GRN_lin1, \n                              expDat = epoch_expr_mat_lin1, \n                              xdyn = epoch_models_lin1) %>% \n                  mutate(Lineage = \"Lineage1\", .before = 1)\n```\n:::\n\n\nThe results are shown below: \n\n\n::: {#tbl-epoch_GRN_lin1 .cell tbl-cap='A sample of the GRN output for lineage 1 from `epoch`.'}\n\n```{.r .cell-code  code-fold=\"true\"}\nslice_sample(epoch_GRN_lin1, n = 10) %>% \n  kableExtra::kable(digits = 2, \n                    row.names = FALSE, \n                    booktabs = TRUE, \n                    col.names = c(\"Lineage\", \"Target Gene\", \"TF\", \"Z-score\", \"Pearson Corr.\", \"Offset\", \"Weighted Score\")) %>% \n  kableExtra::kable_classic(full_width = FALSE, c(\"hover\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-classic lightable-hover\" style='font-family: \"Arial Narrow\", \"Source Sans Pro\", sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Lineage </th>\n   <th style=\"text-align:left;\"> Target Gene </th>\n   <th style=\"text-align:left;\"> TF </th>\n   <th style=\"text-align:right;\"> Z-score </th>\n   <th style=\"text-align:right;\"> Pearson Corr. </th>\n   <th style=\"text-align:right;\"> Offset </th>\n   <th style=\"text-align:right;\"> Weighted Score </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Lineage1 </td>\n   <td style=\"text-align:left;\"> A3-TF1 </td>\n   <td style=\"text-align:left;\"> B7-TF1 </td>\n   <td style=\"text-align:right;\"> 2.30 </td>\n   <td style=\"text-align:right;\"> 0.15 </td>\n   <td style=\"text-align:right;\"> 34.60 </td>\n   <td style=\"text-align:right;\"> 2.30 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Lineage1 </td>\n   <td style=\"text-align:left;\"> HK2715 </td>\n   <td style=\"text-align:left;\"> D2-TF1 </td>\n   <td style=\"text-align:right;\"> 4.35 </td>\n   <td style=\"text-align:right;\"> 0.15 </td>\n   <td style=\"text-align:right;\"> 25.13 </td>\n   <td style=\"text-align:right;\"> 4.35 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Lineage1 </td>\n   <td style=\"text-align:left;\"> Burn4-TF1 </td>\n   <td style=\"text-align:left;\"> B13-TF1 </td>\n   <td style=\"text-align:right;\"> 2.47 </td>\n   <td style=\"text-align:right;\"> 0.10 </td>\n   <td style=\"text-align:right;\"> 4.70 </td>\n   <td style=\"text-align:right;\"> 2.47 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Lineage1 </td>\n   <td style=\"text-align:left;\"> HK3940 </td>\n   <td style=\"text-align:left;\"> B13-TF1 </td>\n   <td style=\"text-align:right;\"> 4.94 </td>\n   <td style=\"text-align:right;\"> 0.09 </td>\n   <td style=\"text-align:right;\"> 30.80 </td>\n   <td style=\"text-align:right;\"> 4.94 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Lineage1 </td>\n   <td style=\"text-align:left;\"> HK3158 </td>\n   <td style=\"text-align:left;\"> B3-TF1 </td>\n   <td style=\"text-align:right;\"> 4.37 </td>\n   <td style=\"text-align:right;\"> 0.16 </td>\n   <td style=\"text-align:right;\"> 9.72 </td>\n   <td style=\"text-align:right;\"> 4.37 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Lineage1 </td>\n   <td style=\"text-align:left;\"> HK1505 </td>\n   <td style=\"text-align:left;\"> B12-TF1 </td>\n   <td style=\"text-align:right;\"> 2.04 </td>\n   <td style=\"text-align:right;\"> 0.11 </td>\n   <td style=\"text-align:right;\"> 77.36 </td>\n   <td style=\"text-align:right;\"> 0.57 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Lineage1 </td>\n   <td style=\"text-align:left;\"> HK277 </td>\n   <td style=\"text-align:left;\"> B12-TF1 </td>\n   <td style=\"text-align:right;\"> 2.24 </td>\n   <td style=\"text-align:right;\"> 0.12 </td>\n   <td style=\"text-align:right;\"> 43.89 </td>\n   <td style=\"text-align:right;\"> 1.32 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Lineage1 </td>\n   <td style=\"text-align:left;\"> HK151 </td>\n   <td style=\"text-align:left;\"> B5-TF1 </td>\n   <td style=\"text-align:right;\"> 2.52 </td>\n   <td style=\"text-align:right;\"> -0.12 </td>\n   <td style=\"text-align:right;\"> -91.41 </td>\n   <td style=\"text-align:right;\"> 2.52 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Lineage1 </td>\n   <td style=\"text-align:left;\"> HK1502 </td>\n   <td style=\"text-align:left;\"> B3-TF1 </td>\n   <td style=\"text-align:right;\"> 3.57 </td>\n   <td style=\"text-align:right;\"> 0.13 </td>\n   <td style=\"text-align:right;\"> -65.03 </td>\n   <td style=\"text-align:right;\"> 3.57 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Lineage1 </td>\n   <td style=\"text-align:left;\"> HK2587 </td>\n   <td style=\"text-align:left;\"> B3-TF1 </td>\n   <td style=\"text-align:right;\"> 3.64 </td>\n   <td style=\"text-align:right;\"> 0.11 </td>\n   <td style=\"text-align:right;\"> -83.22 </td>\n   <td style=\"text-align:right;\"> 3.64 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nWe repeat the process for lineage 2, again using the cluster structure shown in @fig-umap_MST when identifying dynamic genes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nepoch_expr_mat_lin2 <- as.matrix(seu@assays$RNA$data[VariableFeatures(seu), !is.na(sling_pt$Lineage2)])\nepoch_pt_df <- select(sling_pt, Lineage2) %>% \n               mutate(leiden = seu$seurat_clusters) %>% \n               filter(!is.na(Lineage2)) %>% \n               as.data.frame() %>% \n               magrittr::set_rownames(colnames(epoch_expr_mat_lin2))\nepoch_models_lin2 <- findDynGenes(epoch_expr_mat_lin2, \n                                  sampTab = epoch_pt_df, \n                                  path = c(\"1\", \"6\", \"2\", \"3\"), \n                                  group_column = \"leiden\", \n                                  pseudotime_column = \"Lineage2\",\n                                  method = \"gam\")\nepoch_dyn_genes_lin2 <- names(epoch_models_lin2$genes)[epoch_models_lin2$genes < 0.01]\nepoch_dyn_genes_lin2 <- na.omit(epoch_dyn_genes_lin2)\nepoch_GRN_lin2 <- reconstructGRN(epoch_expr_mat_lin2, \n                                 tfs = tx_factors, \n                                 dgenes = epoch_dyn_genes_lin2, \n                                 method = \"pearson\")\nepoch_GRN_lin2 <- crossweight(epoch_GRN_lin2, \n                              expDat = epoch_expr_mat_lin2, \n                              xdyn = epoch_models_lin2) %>% \n                  mutate(Lineage = \"Lineage2\", .before = 1)\nepoch_GRN_all <- bind_rows(epoch_GRN_lin1, epoch_GRN_lin2)\n```\n:::\n\n\n### Estimating accuracy\n\nWe compute the accuracy of `epoch` using the same method as we did for `scTIRN` i.e., by filtering the ground-truth GRN to just the genes identified as dynamic (across either lineage) by `epoch`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nepoch_detected_vec <- epoch_dir_vec_lin1 <- epoch_dir_vec_lin2 <- vector(\"numeric\", nrow(GRN_truth))\nfor (i in seq(nrow(GRN_truth))) {\n  sub_df <- filter(epoch_GRN_all, \n                   TF == GRN_truth$Tx_Factor[i], \n                   TG == GRN_truth$Target_Gene[i])\n epoch_detected_vec[i] <- ifelse(nrow(sub_df > 0), 1, 0)\n epoch_dir_vec_lin1 <- filter(epoch_GRN_lin1, \n                              TF == GRN_truth$Tx_Factor[i], \n                              TG == GRN_truth$Target_Gene[i]) %>% \n                        pull(corr)\n epoch_dir_vec_lin1[i] <- ifelse(length(epoch_dir_vec_lin1) != 0, epoch_dir_vec_lin1, NA_real_)\n epoch_dir_vec_lin2 <- filter(epoch_GRN_lin2, \n                               TF == GRN_truth$Tx_Factor[i], \n                               TG == GRN_truth$Target_Gene[i]) %>% \n                        pull(corr)\n epoch_dir_vec_lin2[i] <- ifelse(length(epoch_dir_vec_lin2) != 0, epoch_dir_vec_lin2, NA_real_)\n}\nGRN_truth <- mutate(GRN_truth, \n                    epoch_detected = epoch_detected_vec, \n                    epoch_direction_lineage1 = epoch_dir_vec_lin1,\n                    epoch_direction_lineage2 = epoch_dir_vec_lin2) %>% \n             mutate(epoch_dir_correct = case_when(effect == 1 & (epoch_direction_lineage1 > 0 | epoch_direction_lineage2 > 0) ~ 1, \n                                                  effect == -1 & (epoch_direction_lineage1 < 0 | epoch_direction_lineage2 < 0) ~ 1, \n                                                  TRUE ~ 0), \n                    epoch_fully_correct = if_else(epoch_detected == 1 & epoch_dir_correct == 1, 1, 0))\n```\n:::\n\n\n`epoch` performs fairly well; compare its accuracy with that of `scTIRN` as shown in @tbl-acc-scTIRN. \n\n\n::: {#tbl-acc-epoch .cell tbl-cap='The accuracy of `epoch` when filtering to just the genes identified by `epoch` as trajectory DE.'}\n\n```{.r .cell-code  code-fold=\"true\"}\nfilter(GRN_truth, Tx_Factor %in% union(epoch_dyn_genes_lin1, epoch_dyn_genes_lin2)) %>% \n  summarise(mu = mean(epoch_detected) * 100) %>% \n  kableExtra::kable(digits = 2, \n                    col.names = \"Accuracy\",\n                    booktabs = TRUE, \n                    align = \"c\") %>% \n  kableExtra::kable_classic(full_width = FALSE, \"hover\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-classic lightable-hover\" style='font-family: \"Arial Narrow\", \"Source Sans Pro\", sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'>\n <thead>\n  <tr>\n   <th style=\"text-align:center;\"> Accuracy </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;\"> 68.64 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n# Conclusions {#sec-conclusions}\n\nOverall both methods perform well, each having an accuracy in the mid-80s. `scTIRN` performed slightly better, likely due to its usage of less-noisy gene dynamics instead of normalized expression to build each lineage's network. In addition, given that we utilized lineage-specific pseudotime from `slingshot` instead of the overall ground-truth pseudotime I imagine the performance of `scTIRN` could be improved if we were to use the ground-truth data instead - though this would lose the lineage specificity. Lastly, the `dyngen` package, while somewhat difficult to use, proved to be a useful tool in that it provides a granular, ground-truth GRN against which we can evaluate different GRN estimation methods. \n\n\n::: {.cell}\n\n:::\n\n\n# Session info {#sec-SI}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.3\n system   x86_64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2024-02-27\n pandoc   3.1.9 @ /usr/local/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package              * version    date (UTC) lib source\n abind                  1.4-5      2016-07-21 [1] CRAN (R 4.3.0)\n assertthat             0.2.1      2019-03-21 [1] CRAN (R 4.3.0)\n backports              1.4.1      2021-12-13 [1] CRAN (R 4.3.0)\n beeswarm               0.4.0      2021-06-01 [1] CRAN (R 4.3.0)\n bigassertr             0.1.6      2023-01-10 [1] CRAN (R 4.3.0)\n bigparallelr           0.3.2      2021-10-02 [1] CRAN (R 4.3.0)\n bigstatsr              1.5.12     2022-10-14 [1] CRAN (R 4.3.0)\n Biobase              * 2.62.0     2023-10-24 [1] Bioconductor\n BiocGenerics         * 0.48.1     2023-11-01 [1] Bioconductor\n bit                    4.0.5      2022-11-15 [1] CRAN (R 4.3.0)\n bit64                  4.0.5      2020-08-30 [1] CRAN (R 4.3.0)\n bitops                 1.0-7      2021-04-24 [1] CRAN (R 4.3.0)\n boot                   1.3-28.1   2022-11-22 [1] CRAN (R 4.3.2)\n broom                  1.0.5      2023-06-09 [1] CRAN (R 4.3.0)\n broom.mixed            0.2.9.4    2022-04-17 [1] CRAN (R 4.3.0)\n car                    3.1-2      2023-03-30 [1] CRAN (R 4.3.0)\n carData                3.0-5      2022-01-06 [1] CRAN (R 4.3.0)\n cellranger             1.1.0      2016-07-27 [1] CRAN (R 4.3.0)\n class                  7.3-22     2023-05-03 [1] CRAN (R 4.3.2)\n cli                    3.6.2      2023-12-11 [1] CRAN (R 4.3.0)\n cluster                2.1.6      2023-12-01 [1] CRAN (R 4.3.0)\n coda                   0.19-4     2020-09-30 [1] CRAN (R 4.3.0)\n codetools              0.2-19     2023-02-01 [1] CRAN (R 4.3.2)\n colorspace             2.1-0      2023-01-23 [1] CRAN (R 4.3.0)\n cowplot                1.1.2      2023-12-15 [1] CRAN (R 4.3.0)\n crayon                 1.5.2      2022-09-29 [1] CRAN (R 4.3.0)\n data.table             1.14.10    2023-12-08 [1] CRAN (R 4.3.0)\n DelayedArray           0.28.0     2023-10-24 [1] Bioconductor\n DelayedMatrixStats     1.24.0     2023-10-24 [1] Bioconductor\n deldir                 2.0-2      2023-11-23 [1] CRAN (R 4.3.0)\n desc                   1.4.3      2023-12-10 [1] CRAN (R 4.3.0)\n DescTools            * 0.99.52    2023-12-01 [1] CRAN (R 4.3.0)\n digest                 0.6.33     2023-07-07 [1] CRAN (R 4.3.0)\n doParallel             1.0.17     2022-02-07 [1] CRAN (R 4.3.0)\n doSNOW                 1.0.20     2022-02-04 [1] CRAN (R 4.3.0)\n dotCall64              1.1-1      2023-11-28 [1] CRAN (R 4.3.0)\n dplyr                * 1.1.4      2023-11-17 [1] CRAN (R 4.3.0)\n dyngen               * 1.0.5      2022-10-12 [1] CRAN (R 4.3.0)\n dynutils               1.0.11     2022-10-11 [1] CRAN (R 4.3.0)\n e1071                  1.7-14     2023-12-06 [1] CRAN (R 4.3.0)\n ellipsis               0.3.2      2021-04-29 [1] CRAN (R 4.3.0)\n emmeans                1.10.0     2024-01-23 [1] CRAN (R 4.3.2)\n epoch                * 0.0.0.9000 2023-12-22 [1] Github (pcahan1/epoch@bf44dff)\n estimability           1.4.1      2022-08-05 [1] CRAN (R 4.3.0)\n evaluate               0.23       2023-11-01 [1] CRAN (R 4.3.0)\n Exact                  3.2        2022-09-25 [1] CRAN (R 4.3.0)\n expm                   0.999-8    2023-11-29 [1] CRAN (R 4.3.0)\n fansi                  1.0.6      2023-12-08 [1] CRAN (R 4.3.0)\n farver                 2.1.1      2022-07-06 [1] CRAN (R 4.3.0)\n fastDummies            1.7.3      2023-07-06 [1] CRAN (R 4.3.0)\n fastmap                1.1.1      2023-02-24 [1] CRAN (R 4.3.0)\n ff                     4.0.9      2023-01-25 [1] CRAN (R 4.3.0)\n fitdistrplus           1.1-11     2023-04-25 [1] CRAN (R 4.3.0)\n flock                  0.7        2016-11-12 [1] CRAN (R 4.3.0)\n forcats                1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n foreach              * 1.5.2      2022-02-02 [1] CRAN (R 4.3.0)\n furrr                  0.3.1      2022-08-15 [1] CRAN (R 4.3.0)\n future                 1.33.1     2023-12-22 [1] CRAN (R 4.3.0)\n future.apply           1.11.1     2023-12-21 [1] CRAN (R 4.3.0)\n gam                  * 1.22-3     2023-11-29 [1] CRAN (R 4.3.0)\n gamlss                 5.4-20     2023-10-04 [1] CRAN (R 4.3.0)\n gamlss.data            6.0-2      2021-11-07 [1] CRAN (R 4.3.0)\n gamlss.dist            6.1-1      2023-08-23 [1] CRAN (R 4.3.0)\n geeM                   0.10.1     2018-06-18 [1] CRAN (R 4.3.0)\n generics               0.1.3      2022-07-05 [1] CRAN (R 4.3.0)\n GENIE3               * 1.24.0     2023-10-24 [1] Bioconductor\n GenomeInfoDb         * 1.38.5     2023-12-28 [1] Bioconductor 3.18 (R 4.3.2)\n GenomeInfoDbData       1.2.11     2023-12-22 [1] Bioconductor\n GenomicRanges        * 1.54.1     2023-10-29 [1] Bioconductor\n ggbeeswarm             0.7.2      2023-04-29 [1] CRAN (R 4.3.0)\n ggforce                0.4.1      2022-10-04 [1] CRAN (R 4.3.0)\n ggnetwork            * 0.5.12     2024-02-12 [1] Github (briatte/ggnetwork@f3b8b84)\n ggplot2              * 3.4.4      2023-10-12 [1] CRAN (R 4.3.0)\n ggpubr                 0.6.0      2023-02-10 [1] CRAN (R 4.3.0)\n ggraph                 2.1.0      2022-10-09 [1] CRAN (R 4.3.0)\n ggrepel                0.9.5      2024-01-10 [1] CRAN (R 4.3.0)\n ggridges               0.5.5      2023-12-15 [1] CRAN (R 4.3.0)\n ggsignif               0.6.4      2022-10-13 [1] CRAN (R 4.3.0)\n GillespieSSA2          0.3.0      2023-01-23 [1] CRAN (R 4.3.0)\n gld                    2.6.6      2022-10-23 [1] CRAN (R 4.3.0)\n glm2                 * 1.2.1      2018-08-11 [1] CRAN (R 4.3.0)\n glmmTMB                1.1.8      2023-10-07 [1] CRAN (R 4.3.0)\n globals                0.16.2     2022-11-21 [1] CRAN (R 4.3.0)\n glue                   1.6.2      2022-02-24 [1] CRAN (R 4.3.0)\n goftest                1.2-3      2021-10-07 [1] CRAN (R 4.3.0)\n graphlayouts           1.1.0      2024-01-19 [1] CRAN (R 4.3.0)\n gridExtra            * 2.3        2017-09-09 [1] CRAN (R 4.3.0)\n gtable                 0.3.4      2023-08-21 [1] CRAN (R 4.3.0)\n hdf5r                * 1.3.8      2023-01-21 [1] CRAN (R 4.3.0)\n highr                  0.10       2022-12-22 [1] CRAN (R 4.3.0)\n hms                    1.1.3      2023-03-21 [1] CRAN (R 4.3.0)\n htmltools              0.5.7      2023-11-03 [1] CRAN (R 4.3.0)\n htmlwidgets            1.6.4      2023-12-06 [1] CRAN (R 4.3.0)\n httpuv                 1.6.13     2023-12-06 [1] CRAN (R 4.3.0)\n httr                   1.4.7      2023-08-15 [1] CRAN (R 4.3.0)\n ica                    1.0-3      2022-07-08 [1] CRAN (R 4.3.0)\n igraph               * 2.0.1.1    2024-01-30 [1] CRAN (R 4.3.2)\n infotheo               1.2.0.1    2022-04-08 [1] CRAN (R 4.3.0)\n IRanges              * 2.36.0     2023-10-24 [1] Bioconductor\n irlba                  2.3.5.1    2022-10-03 [1] CRAN (R 4.3.0)\n iterators            * 1.0.14     2022-02-05 [1] CRAN (R 4.3.0)\n itertools            * 0.1-3      2014-03-12 [1] CRAN (R 4.3.0)\n jsonlite               1.8.8      2023-12-04 [1] CRAN (R 4.3.0)\n kableExtra             1.3.4      2021-02-20 [1] CRAN (R 4.3.0)\n KernSmooth             2.23-22    2023-07-10 [1] CRAN (R 4.3.2)\n knitr                  1.45       2023-10-30 [1] CRAN (R 4.3.0)\n labeling               0.4.3      2023-08-29 [1] CRAN (R 4.3.0)\n later                  1.3.2      2023-12-06 [1] CRAN (R 4.3.0)\n lattice                0.22-5     2023-10-24 [1] CRAN (R 4.3.0)\n lazyeval               0.2.2      2019-03-15 [1] CRAN (R 4.3.0)\n leiden                 0.4.3.1    2023-11-17 [1] CRAN (R 4.3.0)\n lifecycle              1.0.4      2023-11-07 [1] CRAN (R 4.3.0)\n listenv                0.9.0      2022-12-16 [1] CRAN (R 4.3.0)\n lmds                   0.1.0      2019-09-27 [1] CRAN (R 4.3.0)\n lme4                   1.1-35.1   2023-11-05 [1] CRAN (R 4.3.0)\n lmom                   3.0        2023-08-29 [1] CRAN (R 4.3.0)\n lmtest                 0.9-40     2022-03-21 [1] CRAN (R 4.3.0)\n loomR                * 0.2.0      2023-12-22 [1] Github (mojaveazure/loomR@df0144b)\n magrittr             * 2.0.3      2022-03-30 [1] CRAN (R 4.3.0)\n MASS                   7.3-60     2023-05-04 [1] CRAN (R 4.3.0)\n Matrix                 1.6-5      2024-01-11 [1] CRAN (R 4.3.0)\n MatrixGenerics       * 1.14.0     2023-10-24 [1] Bioconductor\n matrixStats          * 1.2.0      2023-12-11 [1] CRAN (R 4.3.0)\n mgcv                   1.9-1      2023-12-21 [1] CRAN (R 4.3.0)\n mime                   0.12       2021-09-28 [1] CRAN (R 4.3.0)\n minet                * 3.60.0     2023-10-24 [1] Bioconductor\n miniUI                 0.1.1.1    2018-05-18 [1] CRAN (R 4.3.0)\n minqa                  1.2.6      2023-09-11 [1] CRAN (R 4.3.0)\n munsell                0.5.0      2018-06-12 [1] CRAN (R 4.3.0)\n mvtnorm                1.2-4      2023-11-27 [1] CRAN (R 4.3.0)\n nlme                   3.1-164    2023-11-27 [1] CRAN (R 4.3.0)\n nloptr                 2.0.3      2022-05-26 [1] CRAN (R 4.3.0)\n numDeriv               2016.8-1.1 2019-06-06 [1] CRAN (R 4.3.0)\n paletteer              1.6.0      2024-01-21 [1] CRAN (R 4.3.0)\n parallelly             1.36.0     2023-05-26 [1] CRAN (R 4.3.0)\n patchwork            * 1.2.0      2024-01-08 [1] CRAN (R 4.3.0)\n pbapply                1.7-2      2023-06-27 [1] CRAN (R 4.3.0)\n pheatmap             * 1.0.12     2019-01-04 [1] CRAN (R 4.3.0)\n pillar                 1.9.0      2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig              2.0.3      2019-09-22 [1] CRAN (R 4.3.0)\n plotly                 4.10.4     2024-01-13 [1] CRAN (R 4.3.0)\n plyr                   1.8.9      2023-10-02 [1] CRAN (R 4.3.0)\n png                    0.1-8      2022-11-29 [1] CRAN (R 4.3.0)\n polyclip               1.10-6     2023-09-27 [1] CRAN (R 4.3.0)\n princurve            * 2.1.6      2021-01-18 [1] CRAN (R 4.3.0)\n prismatic              1.1.1      2022-08-15 [1] CRAN (R 4.3.0)\n progressr              0.14.0     2023-08-10 [1] CRAN (R 4.3.0)\n promises               1.2.1      2023-08-10 [1] CRAN (R 4.3.0)\n proxy                  0.4-27     2022-06-09 [1] CRAN (R 4.3.0)\n proxyC                 0.3.4      2023-10-25 [1] CRAN (R 4.3.0)\n ps                     1.7.5      2023-04-18 [1] CRAN (R 4.3.0)\n purrr                  1.0.2      2023-08-10 [1] CRAN (R 4.3.0)\n R6                   * 2.5.1      2021-08-19 [1] CRAN (R 4.3.0)\n RANN                   2.6.1      2019-01-08 [1] CRAN (R 4.3.0)\n RColorBrewer         * 1.1-3      2022-04-03 [1] CRAN (R 4.3.0)\n Rcpp                   1.0.11     2023-07-06 [1] CRAN (R 4.3.0)\n RcppAnnoy              0.0.21     2023-07-02 [1] CRAN (R 4.3.0)\n RcppEigen              0.3.3.9.4  2023-11-02 [1] CRAN (R 4.3.0)\n RcppHNSW               0.5.0      2023-09-19 [1] CRAN (R 4.3.0)\n RcppParallel           5.1.7      2023-02-27 [1] CRAN (R 4.3.0)\n RcppXPtrUtils          0.1.2      2022-05-24 [1] CRAN (R 4.3.0)\n RCurl                  1.98-1.13  2023-11-02 [1] CRAN (R 4.3.0)\n readr                  2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n readxl                 1.4.3      2023-07-06 [1] CRAN (R 4.3.0)\n rematch2               2.1.2      2020-05-01 [1] CRAN (R 4.3.0)\n remotes                2.4.2.1    2023-07-18 [1] CRAN (R 4.3.0)\n reshape2             * 1.4.4      2020-04-09 [1] CRAN (R 4.3.0)\n reticulate             1.34.0     2023-10-12 [1] CRAN (R 4.3.0)\n rlang                  1.1.2      2023-11-04 [1] CRAN (R 4.3.0)\n rmarkdown              2.25       2023-09-18 [1] CRAN (R 4.3.0)\n rmio                   0.4.0      2022-02-17 [1] CRAN (R 4.3.0)\n ROCR                   1.0-11     2020-05-02 [1] CRAN (R 4.3.0)\n rootSolve              1.8.2.4    2023-09-21 [1] CRAN (R 4.3.0)\n RSpectra               0.16-1     2022-04-24 [1] CRAN (R 4.3.0)\n rstatix                0.7.2      2023-02-01 [1] CRAN (R 4.3.0)\n rstudioapi             0.15.0     2023-07-07 [1] CRAN (R 4.3.0)\n Rtsne                  0.17       2023-12-07 [1] CRAN (R 4.3.0)\n rvest                  1.0.3      2022-08-19 [1] CRAN (R 4.3.0)\n S4Arrays               1.2.0      2023-10-24 [1] Bioconductor\n S4Vectors            * 0.40.2     2023-11-23 [1] Bioconductor\n scales                 1.3.0      2023-11-28 [1] CRAN (R 4.3.0)\n scattermore            1.2        2023-06-12 [1] CRAN (R 4.3.0)\n scLANE               * 0.7.9      2024-02-18 [1] Bioconductor\n sctransform            0.4.1      2023-10-19 [1] CRAN (R 4.3.0)\n sessioninfo            1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n Seurat               * 5.0.1      2023-11-17 [1] CRAN (R 4.3.0)\n SeuratObject         * 5.0.1      2023-11-17 [1] CRAN (R 4.3.0)\n shiny                  1.8.0      2023-11-17 [1] CRAN (R 4.3.0)\n SingleCellExperiment * 1.24.0     2023-10-24 [1] Bioconductor\n slingshot            * 2.10.0     2023-10-24 [1] Bioconductor\n snow                   0.4-4      2021-10-27 [1] CRAN (R 4.3.0)\n sp                   * 2.1-2      2023-11-26 [1] CRAN (R 4.3.0)\n spam                   2.10-0     2023-10-23 [1] CRAN (R 4.3.0)\n SparseArray            1.2.3      2023-12-25 [1] Bioconductor 3.18 (R 4.3.2)\n sparseMatrixStats      1.14.0     2023-10-24 [1] Bioconductor\n spatstat.data          3.0-3      2023-10-24 [1] CRAN (R 4.3.0)\n spatstat.explore       3.2-5      2023-10-22 [1] CRAN (R 4.3.0)\n spatstat.geom          3.2-7      2023-10-20 [1] CRAN (R 4.3.0)\n spatstat.random        3.2-2      2023-11-29 [1] CRAN (R 4.3.0)\n spatstat.sparse        3.0-3      2023-10-24 [1] CRAN (R 4.3.0)\n spatstat.utils         3.0-4      2023-10-24 [1] CRAN (R 4.3.0)\n stringi                1.8.3      2023-12-11 [1] CRAN (R 4.3.0)\n stringr                1.5.1      2023-11-14 [1] CRAN (R 4.3.0)\n SummarizedExperiment * 1.32.0     2023-10-24 [1] Bioconductor\n survival               3.5-7      2023-08-14 [1] CRAN (R 4.3.2)\n svglite                2.1.3      2023-12-08 [1] CRAN (R 4.3.0)\n systemfonts            1.0.5      2023-10-09 [1] CRAN (R 4.3.0)\n tensor                 1.5        2012-05-05 [1] CRAN (R 4.3.0)\n tibble                 3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n tidygraph              1.3.0      2023-12-18 [1] CRAN (R 4.3.0)\n tidyr                  1.3.1      2024-01-24 [1] CRAN (R 4.3.2)\n tidyselect             1.2.0      2022-10-10 [1] CRAN (R 4.3.0)\n TMB                    1.9.10     2023-12-12 [1] CRAN (R 4.3.0)\n TrajectoryUtils      * 1.10.0     2023-10-24 [1] Bioconductor\n tweenr                 2.0.2      2022-09-06 [1] CRAN (R 4.3.0)\n tzdb                   0.4.0      2023-05-12 [1] CRAN (R 4.3.0)\n utf8                   1.2.4      2023-10-22 [1] CRAN (R 4.3.0)\n uwot                   0.1.16     2023-06-29 [1] CRAN (R 4.3.0)\n vctrs                  0.6.5      2023-12-01 [1] CRAN (R 4.3.0)\n vipor                  0.4.7      2023-12-18 [1] CRAN (R 4.3.0)\n viridis              * 0.6.4      2023-07-22 [1] CRAN (R 4.3.0)\n viridisLite          * 0.4.2      2023-05-02 [1] CRAN (R 4.3.0)\n webshot                0.5.5      2023-06-26 [1] CRAN (R 4.3.0)\n withr                  2.5.2      2023-10-30 [1] CRAN (R 4.3.0)\n xfun                   0.41       2023-11-01 [1] CRAN (R 4.3.0)\n xml2                   1.3.6      2023-12-04 [1] CRAN (R 4.3.0)\n xtable                 1.8-4      2019-04-21 [1] CRAN (R 4.3.0)\n XVector                0.42.0     2023-10-24 [1] Bioconductor\n yaml                   2.3.8      2023-12-11 [1] CRAN (R 4.3.0)\n zlibbioc               1.48.0     2023-10-24 [1] Bioconductor\n zoo                    1.8-12     2023-04-13 [1] CRAN (R 4.3.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/library\n\n─ Python configuration ───────────────────────────────────────────────────────\n python:         /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/bin/python\n libpython:      /usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/lib/python3.11/config-3.11-darwin/libpython3.11.dylib\n pythonhome:     /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site:/Users/jack/Desktop/PhD/Research/Python_Envs/personal_site\n version:        3.11.6 (main, Nov  2 2023, 04:52:24) [Clang 14.0.3 (clang-1403.0.22.14.1)]\n numpy:          /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/lib/python3.11/site-packages/numpy\n numpy_version:  1.26.3\n leidenalg:      /Users/jack/Desktop/PhD/Research/Python_Envs/personal_site/lib/python3.11/site-packages/leidenalg\n \n NOTE: Python version was forced by use_python() function\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [
      "GRN_Simulation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}