{
  "hash": "a1d52f2a1e6f9fbf84946e8a91f416f3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Converting scRNA-seq Datasets from `Seurat` to `AnnData`\"\nauthor:\n  name: Jack Leary\n  email: j.leary@ufl.edu\n  orcid: 0009-0004-8821-3269\n  affiliations:\n    - name: University of Florida\n      department: Biostatistics \n      city: Gainesville\n      state: FL\ndate: \"2023-11-02\"\nformat:\n  html:\n    code-fold: show\n    code-copy: true\n    code-tools: true\n    toc: true\n    embed-resources: true\n    fig-format: retina\n    df-print: kable\n    link-external-newwindow: true\nexecute: \n  cache: false\n  freeze: auto\n---\n\n\n\n\n# Introduction \n\nif you're like me, you switch between using R & Python pretty frequently. Despite all the hype, single cell is still a relatively nascent field, and not every method is implemented in both languages. For example: if you want to run an RNA velocity analysis you're probably going to need to use Python, but when it comes to making figures for your publication it's generally easier to go back to R and use `ggplot2`. Whatever the motivation, it's useful to be able to seamlessly switch between programming environments - though doing so isn't always easy.\n\nThere are several libraries that facilitate conversions from R-based scRNA-seq data structures (typically `SingleCellExperiment` or `Seurat` objects) to Python-based ones (`AnnData` and `loom` being the most common formats). I'm aware of [`{zellkonverter}`](https://theislab.github.io/zellkonverter/), [`{SeuratDisk}`](https://mojaveazure.github.io/seurat-disk/), [`{anndata2ri}`](https://icb-anndata2ri.readthedocs-hosted.com/en/latest/), [`{loomR}`](https://github.com/mojaveazure/loomR), & [`{sceasy}`](https://github.com/cellgeni/sceasy). While these packages generally work fairly well, they don't always transfer every piece of data that you need, and reading through the source code to try & figure out why your objects are incomplete can take up a lot of time. In addition, some of the more niche / less used dataset attributes are often undocumented or poorly-documented in conversion packages, making it difficult to identify how the data types correspond between formats. As such, sometimes it's necessary to get through the conversion on your own. This vignette will hopefully make doing so a bit easier by detailing the equivalencies across packages between different types of counts matrices, metadata, graphs, & more. We'll focus on converting directly from `Seurat` to `AnnData`, since converting between formats within the same language e.g., `AnnData` to `loom` or `SingleCellExperiment` to `Seurat` is generally easier & much better-documented. \n\n# Libraries \n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)       # data manipulation\nlibrary(Seurat)      # scRNA-seq tools \nlibrary(ggplot2)     # plots\nlibrary(biomaRt)     # gene metadata \nlibrary(paletteer)   # color palettes\nlibrary(patchwork)   # plot alignment\nlibrary(reticulate)  # Python interface\n```\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np                   # linear algebra tools\nimport pandas as pd                  # data manipulation\nimport scanpy as sc                  # scRNA-seq tools\nimport scvelo as scv                 # RNA velocity models\nimport anndata as ad                 # scRNA-seq data structures\nfrom scipy.io import mmread          # read .mtx files\nimport matplotlib.pyplot as plt      # matplotlib\nfrom plotnine import theme_classic   # plot themes\nfrom scipy.sparse import csr_matrix  # sparse matrices\n```\n:::\n\n\nWe tweak our `matplotlib` settings to match `ggplot2::theme_classic()`, which is my preferred theme. \n\n\n::: {.cell}\n\n```{.python .cell-code}\ngg_theme = theme_classic()\nplt.rcParams.update(gg_theme.rcParams)\nplt.ion()\n```\n:::\n\n\n# Data \n\nFirst we'll load a dataset to analyze; I'm a fan of the neural development data from [La Manno *et al* (2016)](https://doi.org/10.1016/j.cell.2016.09.027) as a good example for trajectory / velocity methods. The dataset is available in the `scRNAseq` package, though we'll need to convert it from the default `SingleCellExperiment` format to a `Seurat` object first. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrain <- scRNAseq::LaMannoBrainData(which = \"human-embryo\")\nbrain <- CreateSeuratObject(counts = counts(brain), \n                            project = \"neural_development\", \n                            assay = \"RNA\", \n                            meta.data = data.frame(colData(brain), row.names = colnames(brain)), \n                            min.cells = 3, \n                            min.features = 3)\n```\n:::\n\n\n# Analysis \n\n## Preprocessing in R\n\nWe'll start by running the data through a very typical preprocessing pipeline composed of QC, HVG selection, dimension reduction, Leiden graph-based clustering, & visualization. We'll do a couple things that are non-standard though - first, we make sure to return the fitted UMAP model after running `RunUMAP()`, which will allow us to later recompute the set of nearest-neighbors that UMAP uses internally. Next, we identify nearest neighbors twice, once with `return.neighbor` toggled & once without it. The set of NNs identified each time is the same, but the first run returns the NN indices and inter-cell distances, while the second returns the shared nearest-neighbor graph that we use as input to the Leiden clustering algorithm in `FindClusters()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrain <- brain %>% \n         PercentageFeatureSet(pattern = \"^RP[SL]\", col.name = \"percent_ribo\") %>% \n         PercentageFeatureSet(pattern = \"^MT-\", col.name = \"percent_mito\") %>% \n         CellCycleScoring(s.features = cc.genes.updated.2019$s.genes, \n                          g2m.features = cc.genes.updated.2019$g2m.genes, \n                          set.ident = FALSE) %>% \n         AddMetaData(metadata = .$S.Score - .$G2M.Score, col.name = \"CC_difference\") %>% \n         NormalizeData(verbose = FALSE) %>% \n         ScaleData(verbose = FALSE) %>% \n         FindVariableFeatures(nfeatures = 3000, verbose = FALSE) %>% \n         RunPCA(features = VariableFeatures(.), \n                npcs = 30, \n                verbose = FALSE, \n                seed.use = 312, \n                approx = TRUE) %>% \n         RunUMAP(reduction = \"pca\", \n                 dims = 1:30, \n                 return.model = TRUE, \n                 n.neighbors = 20, \n                 n.components = 2, \n                 metric = \"cosine\", \n                 n.epochs = 1000, \n                 seed.use = 312, \n                 verbose = FALSE) %>% \n         FindNeighbors(reduction = \"pca\", \n                       dims = 1:30, \n                       k.param = 20, \n                       return.neighbor = TRUE, \n                       nn.method = \"annoy\", \n                       annoy.metric = \"cosine\", \n                       verbose = FALSE) %>% \n         FindNeighbors(reduction = \"pca\", \n                       dims = 1:30, \n                       k.param = 20, \n                       compute.SNN = TRUE, \n                       nn.method = \"annoy\", \n                       annoy.metric = \"cosine\", \n                       verbose = FALSE) %>% \n         FindClusters(resolution = 0.25, \n                      algorithm = 4, \n                      method = \"igraph\", \n                      random.seed = 312, \n                      verbose = FALSE)\n```\n:::\n\n\nWe'll also add & clean up the metadata by creating a cell age variable and sorting the fine celltype labels into slightly coarser categories for visualization. This data is mostly derived from [Figure 1](https://www.sciencedirect.com/science/article/pii/S0092867416313095?via%3Dihub#fig1) and [Supplementary Table 1](https://www.sciencedirect.com/science/article/pii/S0092867416313095?via%3Dihub#mmc1) in the original paper. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrain@meta.data <- mutate(brain@meta.data, \n                          age = case_when(Timepoint == \"week_6\" ~ 6,\n                                          Timepoint == \"week_7\" ~ 7,\n                                          Timepoint == \"week_8\" ~ 8,\n                                          Timepoint == \"week_9\" ~ 9,\n                                          Timepoint == \"week_10\" ~ 10,\n                                          Timepoint == \"week_11\" ~ 11,\n                                          TRUE ~ NA_real_), \n                          age = as.factor(age), \n                          broad_celltype = case_when(Cell_type %in% c(\"hOMTN\") ~ \"Oculomotor & Trochlear Nucleus\", \n                                                     Cell_type %in% c(\"hSert\") ~ \"Serotonergic\", \n                                                     Cell_type %in% c(\"hGaba\", \"hNbGaba\") ~ \"Gabaergic\", \n                                                     Cell_type %in% c(\"hDA0\", \"hDA1\", \"hDA2\") ~ \"Dopaminergic\", \n                                                     Cell_type %in% c(\"hRgl1\", \"hRgl2a\", \"hRgl2b\", \"hRgl2c\", \"hRgl3\") ~ \"Radial Glia\", \n                                                     Cell_type %in% c(\"hOPC\") ~ \"Oligodendrocyte Precursor\", \n                                                     Cell_type %in% c(\"hPeric\") ~ \"Pericyte\", \n                                                     Cell_type %in% c(\"hEndo\") ~ \"Endothelial\", \n                                                     Cell_type %in% c(\"hNProg\", \"hProgBP\", \"hProgFPL\", \"hProgFPM\", \"hProgM\") ~ \"Progenitor\", \n                                                     Cell_type %in% c(\"hRN\") ~ \"Red Nucleus\", \n                                                     Cell_type %in% c(\"hNbM\", \"hNbML1\", \"hNbML5\") ~ \"Neuroblast\", \n                                                     Cell_type %in% c(\"hMgl\") ~ \"Microglia\", \n                                                     Cell_type %in% c(\"Unk\") ~ \"Unknown\", \n                                                     TRUE ~ NA_character_), \n                          broad_celltype = as.factor(broad_celltype))\n```\n:::\n\n\nLet's visualize the results. First, we'll define a color palette for each of our key metadata features using the `paletteer` package. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npalette_cluster <- paletteer_d(\"ggsci::nrc_npg\")\npalette_celltype <- paletteer_d(\"ggthemes::Tableau_20\")\npalette_age <- paletteer_d(\"MetBrewer::Juarez\")\npalette_cc <- paletteer_d(\"ggsci::default_locuszoom\")\n```\n:::\n\n\nWe'll also create a clean theme & legend settings for our dimension reduction plots. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_umap <- function(base.size = 14) {\n  theme_classic(base_size = base.size, \n                base_line_size = 0.75, \n                base_rect_size = 0.75) + \n  theme(axis.ticks = element_blank(), \n        axis.text = element_blank(), \n        plot.subtitle = element_text(face = \"italic\"), \n        plot.caption = element_text(face = \"italic\"))\n}\nguide_umap <- function(key.size = 4) {\n  guides(color = guide_legend(override.aes = list(size = key.size, alpha = 1)))\n}\n```\n:::\n\n\nWe plot the unsupervised graph-based clustering, the true celltype labels, cell ages, & estimated cell cycle phase on our UMAP embedding. \n\n\n::: {.cell}\n\n```{.r .cell-code}\np0 <- DimPlot(brain, \n              group.by = \"seurat_clusters\", \n              cols = alpha(0.75, colour = palette_cluster), \n              shuffle = TRUE, \n              seed = 312, \n              pt.size = 1) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           title = \"Leiden Graph-based Clustering\", \n           subtitle = \"k = 20, r = 0.25\") + \n      theme_umap() + \n      guide_umap()\np1 <- DimPlot(brain, \n              group.by = \"broad_celltype\", \n              cols = alpha(0.75, colour = palette_celltype), \n              shuffle = TRUE, \n              seed = 312, \n              pt.size = 1) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           title = \"Coarse Celltypes\", \n           subtitle = \"Derived from authors' original annotations\") + \n      theme_umap() + \n      guide_umap()\np2 <- DimPlot(brain, \n              group.by = \"age\", \n              cols = alpha(0.75, colour = palette_age), \n              shuffle = TRUE, \n              seed = 312, \n              pt.size = 1) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           title = \"Cell Age\", \n           subtitle = \"Timepoints measured in weeks\") + \n      theme_umap() + \n      guide_umap()\np3 <- DimPlot(brain, \n              group.by = \"Phase\", \n              cols = alpha(0.75, colour = palette_cc), \n              shuffle = TRUE, \n              seed = 312, \n              pt.size = 1) + \n      labs(x = \"UMAP 1\", \n           y = \"UMAP 2\", \n           title = \"Cell Cycle Phase\", \n           subtitle = \"Estimated using genes from Tirosh et al (2016)\") + \n      theme_umap() + \n      guide_umap()\n(p0 | p1) / (p2 | p3)\n```\n\n::: {.cell-output-display}\n![](Seurat_AnnData_Conversion_files/figure-html/unnamed-chunk-9-1.png)\n:::\n:::\n\n\n## Conversion to `AnnData`\n\nHaving done all this preprocessing already, when using tools in Python we'd ideally like to be able to keep our clustering, annotations, embeddings, etc. as they are instead of recomputing them with `scanpy`. That isn't a terrible worst option of course, but it's pretty much impossible to get the results of stochastic algorithms such as Leiden clustering and UMAP, and even simpler ones like HVG identification to agree when using differing implementations of differing methods. With that in mind, let's port our results to Python! \n\n::: {.callout-note}\nThere's essentially two ways to do this; the first relies on the usage of RMarkdown & `reticulate`, which allows you to pass objects back & forth between languages. The second, more general method is to write the data to common file formats from R, then read them in with Python & clean up the files afterwards. We'll show examples of both options, but the best general-practice method is the file-based way. We'll set up a temporary directory for the conversion files now, then remove it after we're done. \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!dir.exists(\"./conversion_files/\")) {\n  dir.create(\"./conversion_files\")\n}\n```\n:::\n\n\n### Raw Counts \n\nFirst, we'll write the counts matrices to a sparse matrix market file, which can be read into Python via `scipy`. **Note**: the `AnnData` ecosystem is built around $\\text{cell} \\times \\text{gene}$ counts matrices, which is transposed from how R-based single cell data structures store them. Make sure to transpose them in either R or Python before creating an `AnnData` object. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nMatrix::writeMM(brain@assays$RNA@counts, file = \"./conversion_files/RNA_counts.mtx\")\n```\n:::\n\n\n### Cell & Gene Metadata\n\nWe'll use CSVs to store the metadata for our cells & genes; these can be read into Python using `pandas`. The `biomaRt` package allows us to pull an Ensembl ID & biotype for each gene in our dataset, which we save as well. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::write_csv(brain@meta.data,\n                 file = \"./conversion_files/cell_metadata.csv\",\n                 col_names = TRUE)\nreadr::write_csv(data.frame(cell = colnames(brain)), \n                 file = \"./conversion_files/cells.csv\", \n                 col_names = TRUE)\nreadr::write_csv(data.frame(gene = rownames(brain)), \n                 file = \"./conversion_files/genes.csv\", \n                 col_names = TRUE)\nmart <- useDataset(\"hsapiens_gene_ensembl\", useMart(\"ensembl\"))\ngene_mapping_table <- getBM(filters = \"hgnc_symbol\",\n                            attributes = c(\"hgnc_symbol\", \"ensembl_gene_id\", \"gene_biotype\"),\n                            values = rownames(brain),\n                            mart = mart, \n                            uniqueRows = TRUE)\ngene_mapping_table <- data.frame(hgnc_symbol = rownames(brain)) %>% \n                      left_join(gene_mapping_table, by = \"hgnc_symbol\") %>% \n                      with_groups(hgnc_symbol, \n                                  mutate, \n                                  R = row_number()) %>% \n                      filter(R == 1) %>% \n                      dplyr::select(-R)\nreadr::write_csv(gene_mapping_table, \n                 file = \"./conversion_files/gene_mapping.csv\", \n                 col_names = TRUE)\n```\n:::\n\n\n### Embeddings \n\nNext, we'll create CSVs of our PCA & UMAP embeddings. Once we read these into Python they'll need to be converted to `numpy` arrays. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::write_csv(as.data.frame(brain@reductions$pca@cell.embeddings),\n                 file = \"./conversion_files/PCA.csv\",\n                 col_names = TRUE)\nreadr::write_csv(as.data.frame(brain@reductions$umap@cell.embeddings),\n                 file = \"./conversion_files/UMAP.csv\",\n                 col_names = TRUE)\n```\n:::\n\n\n### Graph Structures \n\nLastly, we'll save our nearest-neighbor graph data using a couple different formats - sparse matrices for the NN distance & UMAP connectivity graphs, and a CSV for the NN indices. First we need to actually create the NN distance graph though; in a `Seurat` object this graph is stored in an $n \\times k$ matrix containing only the distances for each cell's nearest neighbors, while in an `AnnData` object the matrix is expanded to also include a value of 0 for all non-neighbor cells i.e., a $n \\times n$ sparse matrix. Luckily this is a fairly quick conversion to make: we simply record the row & column index for each cell's nearest neighbors along with the accompanying cosine distance, then use that data to build a sparse matrix. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn_param <- ncol(brain@neighbors$RNA.nn@nn.idx)\nrow_idx <- col_idx <- X <- vector(\"numeric\", length = ncol(brain) * knn_param)\nfor (i in seq(ncol(brain))) {\n  row_idx[(knn_param * i - (knn_param - 1)):(knn_param * i)] <- i\n  col_idx[(knn_param * i - (knn_param - 1)):(knn_param * i)] <- brain@neighbors$RNA.nn@nn.idx[i, ]\n  X[(knn_param * i - (knn_param - 1)):(knn_param * i)] <- brain@neighbors$RNA.nn@nn.dist[i, ]\n  \n}\nknn_dist_mat <- Matrix::sparseMatrix(i = row_idx, \n                                     j = col_idx, \n                                     x = X)\n```\n:::\n\n\nThe trickiest bit is the cell-level [connectivities.](https://scanpy.readthedocs.io/en/stable/generated/scanpy.Neighbors.html) This term is used pretty often in analyses done with `scanpy` and `scvelo`, but there isn't really a direct equivalent in R. In short, `scanpy` (and the other packages built on top of it) uses part of the UMAP algorithm to both compute the nearest-neighbor graph & embed the cells in one step, rather than computing the neighbors separately from the UMAP embedding as is done in R. More technically, `scanpy` borrows the computation of the [fuzzy simplicial set](https://umap-learn.readthedocs.io/en/latest/_modules/umap/umap_.html#fuzzy_simplicial_set) from UMAP, which is essentially a local approximation of the distances between points for a given distance metric (cosine, in our case). See [here](https://umap-learn.readthedocs.io/en/latest/how_umap_works.html), specifically the section entitled \"Adapting to Real World Data\", for many more details. \n\nSince the UMAP embeddings you get from `Seurat` & `scanpy` will differ somewhat because of differences in their underlying implementations, we'd like to be able to extract the connectivities from our pre-computed embedding and bring them in Python, instead of recomputing them with `scanpy` and thus having a set of neighbors that doesn't exactly correspond to our UMAP. We can do this by refitting the UMAP model using the exact settings that we did when running it through the `Seurat` wrapper function, but this time we specify the parameter `ret_extra = c(\"fgraph\")`, which indicates that the fuzzy simplicial set matrix should be returned. Some of the parameters aren't stored in the returned `uwot` model, so we need to set them manually. The only tricky one is the initialization; `RunUMAP()` uses the spectral (normalized Laplacian plus Gaussian noise) initialization as of the time of writing. **Note**: make sure to use the same random seed as you did when calling `RunUMAP()` originally. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(312)\numap_reembed <- uwot::umap(X = brain@reductions$pca@cell.embeddings, \n                           n_neighbors = brain@reductions$umap@misc$model$n_neighbors,\n                           n_components = 2,\n                           metric = \"cosine\", \n                           n_epochs = brain@reductions$umap@misc$model$n_epochs, \n                           init = \"spectral\", \n                           learning_rate = brain@reductions$umap@misc$model$alpha, \n                           min_dist = 0.1, \n                           local_connectivity = brain@reductions$umap@misc$model$local_connectivity, \n                           nn_method = \"annoy\", \n                           negative_sample_rate = brain@reductions$umap@misc$model$negative_sample_rate, \n                           ret_extra = c(\"fgraph\"),\n                           n_threads = 2,\n                           a = brain@reductions$umap@misc$model$a, \n                           b = brain@reductions$umap@misc$model$b, \n                           search_k = brain@reductions$umap@misc$model$search_k, \n                           approx_pow = brain@reductions$umap@misc$model$approx_pow, \n                           verbose = FALSE)\n```\n:::\n\n\nNow that we've created our data, we write it to files. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nMatrix::writeMM(knn_dist_mat, file = \"./conversion_files/KNN_distances.mtx\")\nMatrix::writeMM(umap_reembed$fgraph, file = \"./conversion_files/UMAP_connectivity_matrix.mtx\")\nreadr::write_csv(as.data.frame(brain@neighbors$RNA.nn@nn.idx), \n                 file = \"./conversion_files/KNN_indices.csv\", \n                 col_names = TRUE)\n```\n:::\n\n\n## Downstream Analysis in Python\n\nWe read our data into Python, & do some necessary reformatting. \n\n\n::: {.cell}\n\n```{.python .cell-code}\n# raw counts \nRNA_counts = mmread('./conversion_files/RNA_counts.mtx').transpose().tocsr().astype('float64')\n# cell metadata\ncell_metadata = pd.read_csv('./conversion_files/cell_metadata.csv') \\\n                  .rename(columns={'Cell_ID': 'cell'}) \\\n                  .set_index('cell', drop=False)\ncell_metadata['seurat_clusters'] = cell_metadata['seurat_clusters'].astype('category')\ncell_metadata['age'] = pd.Categorical(cell_metadata['age'].astype('str'), categories=['6', '7', '8', '9', '10', '11'])\ncat_cols = ['broad_celltype', 'Phase', 'Cell_type']\ncell_metadata[cat_cols] = cell_metadata[cat_cols].apply(lambda x: pd.Categorical(x, categories=list(dict.fromkeys(sorted(x, key=str.lower)))))\ncell_names = pd.read_csv('./conversion_files/cells.csv').set_index('cell', drop=False)\n# gene metadata\ngene_names = pd.read_csv('./conversion_files/genes.csv').set_index('gene', drop=False)\ngene_mapping_table = pd.read_csv('./conversion_files/gene_mapping.csv').set_index('hgnc_symbol', drop=False)\n# reduced dimensional embeddings\npca_embedding = pd.read_csv('./conversion_files/PCA.csv') \\\n                  .set_index(pd.Index(cell_names['cell'])) \\\n                  .to_numpy()\numap_embedding = pd.read_csv('./conversion_files/UMAP.csv') \\\n                   .set_index(pd.Index(cell_names['cell'])) \\\n                   .to_numpy()\n# KNN graphs\nknn_idx = pd.read_csv('./conversion_files/KNN_indices.csv').to_numpy().astype('int32') - 1\nknn_dist_mat = mmread('./conversion_files/KNN_distances.mtx').tocsr().astype('float64')\nknn_conn_mat = mmread('./conversion_files/UMAP_connectivity_matrix.mtx').tocsr().astype('float64')\n```\n:::\n\n\nNow we can finally create our `AnnData` object. We make sure to store the unprocessed version of the data in the `AnnData.raw` slot. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nlayers_dict = {'RNA': RNA_counts}\ndimred_dict = {'X_pca': pca_embedding, 'X_umap': umap_embedding}\ngraph_dict = {'distances': knn_dist_mat, 'connectivities': knn_conn_mat}\nuns_dict = {\n    'broad_celltype_colors': np.array(r.palette_celltype[0:13]), \n    'seurat_clusters_colors': np.array(r.palette_cluster[0:7]), \n    'age_colors': np.array(r.palette_age[0:7]), \n    'Phase_colors': np.array(r.palette_cc[0:3]), \n    'neighbors': {\n        'connectivities_key': 'connectivities', \n        'distances_key': 'distances', \n        'indices': knn_idx, \n        'params': {\n            'n_neighbors': knn_idx.shape[1], \n            'method': 'Seurat::FindNeighbors()', \n            'metric': 'cosine', \n            'n_pcs': pca_embedding.shape[1], \n            'use_rep': 'X_pca'\n        } \n    }\n}\nadata = ad.AnnData(\n    X=layers_dict['RNA'], \n    obs=cell_metadata, \n    var=gene_mapping_table, \n    layers=layers_dict, \n    obsm=dimred_dict, \n    obsp=graph_dict, \n    uns=uns_dict\n)\nadata.raw = adata\nadata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnnData object with n_obs × n_vars = 1977 × 19527\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'cell', 'Cell_type', 'Timepoint', 'percent_ribo', 'percent_mito', 'S.Score', 'G2M.Score', 'Phase', 'CC_difference', 'RNA_snn_res.0.25', 'seurat_clusters', 'age', 'broad_celltype'\n    var: 'hgnc_symbol', 'ensembl_gene_id', 'gene_biotype'\n    uns: 'broad_celltype_colors', 'seurat_clusters_colors', 'age_colors', 'Phase_colors', 'neighbors'\n    obsm: 'X_pca', 'X_umap'\n    layers: 'RNA'\n    obsp: 'distances', 'connectivities'\n```\n\n\n:::\n:::\n\n\nWhen plotting the UMAP embedding, we can see that the coordinates & colors have been preserved. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nax = sc.pl.scatter(\n  adata, \n  basis='umap',\n  color='broad_celltype', \n  title='', \n  frameon=True, \n  show=False, \n  legend_fontsize=10, \n  right_margin=0.7\n)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['bottom'].set_linewidth(1.5)\nax.spines['left'].set_linewidth(1.5)\nax.set_xlabel('UMAP 1')\nax.set_ylabel('UMAP 2')\nax.set_title(label='UMAP Embedding from Seurat', loc='left')\nplt.gcf().set_dpi(320)\nplt.show()\n```\n\n::: {.cell-output-display}\n![](Seurat_AnnData_Conversion_files/figure-html/unnamed-chunk-19-1.png){width=922}\n:::\n:::\n\n\nNow we can proceed with a typical downstream analysis using the `scanpy` library. After processing the cells, we estimate a force-directed graph embedding and then a diffusion map embedding, which we'll use to estimate pseudotime. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nsc.pp.filter_genes_dispersion(adata, flavor='seurat', n_top_genes=3000)\nsc.pp.normalize_per_cell(adata)\nsc.pp.log1p(adata)\nsc.pp.scale(adata)\nsc.tl.draw_graph(adata, layout='fr', random_state=312)\nsc.tl.diffmap(adata, random_state=312)\nax = sc.pl.scatter(\n  adata,\n  basis='diffmap',\n  color='broad_celltype', \n  title='', \n  frameon=True, \n  show=False, \n  legend_fontsize=10, \n  right_margin=0.7\n)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['bottom'].set_linewidth(1.5)\nax.spines['left'].set_linewidth(1.5)\nax.set_xlabel('DC 1')\nax.set_ylabel('DC 2')\nax.set_title(label='Diffusion Map Embedding of Fine Celltypes', loc='left')\nplt.gcf().set_dpi(320)\nplt.show()\n```\n\n::: {.cell-output-display}\n![](Seurat_AnnData_Conversion_files/figure-html/unnamed-chunk-20-3.png){width=922}\n:::\n:::\n\n\nWe assign a root cell belonging to the progenitor population, then estimate diffusion pseudotime for each cell, and finally plot the results with our diffusion map embedding. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nadata.uns['iroot'] = np.flatnonzero(adata.obs['broad_celltype']  == 'Progenitor')[0]\nsc.tl.dpt(adata)\nax = sc.pl.scatter(\n  adata, \n  color='dpt_pseudotime', \n  basis='diffmap', \n  title='', \n  color_map='gnuplot', \n  legend_fontsize=10, \n  show=False\n)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['bottom'].set_linewidth(1.5)\nax.spines['left'].set_linewidth(1.5)\nax.set_xlabel('DC 1')\nax.set_ylabel('DC 2')\nax.set_title(label='Diffusion Pseudotime', loc='left')\nplt.gcf().set_dpi(320)\nplt.show()\n```\n\n::: {.cell-output-display}\n![](Seurat_AnnData_Conversion_files/figure-html/unnamed-chunk-21-5.png){width=717}\n:::\n:::\n\n\nWhen plotting the distribution of diffusion pseudotime for each coarse celltype, we see that more immature celltypes such as progenitors have lower values, whereas more mature celltypes like endothelial cells & microglia have larger values. This indicates that our DPT estimate is a decent proxy for progression through the underlying biological process. \n \n\n::: {.cell}\n\n```{.python .cell-code}\nviolin_order = pd.DataFrame(adata.obs[['broad_celltype', 'dpt_pseudotime']]) \\\n                 .groupby('broad_celltype')['dpt_pseudotime'].mean() \\\n                 .sort_values(ascending=True) \\\n                 .index.tolist()\nax = sc.pl.violin(\n  adata, \n  keys='dpt_pseudotime', \n  groupby='broad_celltype', \n  frameon=True, \n  order=violin_order, \n  show=False, \n  inner='box',\n  scale='width', \n  stripplot=False\n)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['bottom'].set_linewidth(1.5)\nax.spines['left'].set_linewidth(1.5)\nax.set_ylabel('Diffusion Pseudotime')\nax.set_xlabel(None)\nax.set_xticklabels(violin_order, rotation=40, ha='right')\nax.set_position([0.1, 0.375, 0.85, 0.575]) \nplt.gcf().set_dpi(320)\nplt.show()\n```\n\n::: {.cell-output-display}\n![](Seurat_AnnData_Conversion_files/figure-html/unnamed-chunk-22-7.png){width=771}\n:::\n:::\n\n\n## File Cleanup\n\nLastly, we'll remove the temporary directory we used to store our data while converting it all to `AnnData`. **Note**: always be super careful when using `rm -rf`!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (dir.exists(\"./conversion_files\")) {\n  system(\"rm -rf ./conversion_files\")\n}\n```\n:::\n\n\n## Returning Results to R\n\nWe'll quickly pull the diffusion pseudotime estimate for each cell back into R using `reticulate`, and add it to our `Seurat` object. We also add the diffusion map embedding to the `reductions` slot in the object. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndpt_est <- py$adata$obs$dpt_pseudotime\nnames(dpt_est) <- py$adata$obs$cell\nbrain <- AddMetaData(brain, metadata = dpt_est, col.name = \"scanpy_dpt\")\ndiffmap_embed <- py$adata$obsm[\"X_diffmap\"]\nrownames(diffmap_embed) <- colnames(brain)\ncolnames(diffmap_embed) <- paste0(\"DC_\", c(1:ncol(diffmap_embed)))\nbrain@reductions$diffmap <- CreateDimReducObject(embeddings = diffmap_embed, \n                                                 assay = \"RNA\", \n                                                 key = \"DC_\", \n                                                 global = TRUE)\n```\n:::\n\n\nWe can plot the DPT estimates on our UMAP embedding:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFeaturePlot(brain, \n            features = \"scanpy_dpt\", \n            reduction = \"umap\", \n            pt.size = 1) + \n  scale_color_gradientn(colours = viridisLite::inferno(n = 20), \n                        labels = scales::label_number(accuracy = .1)) + \n  labs(x = \"UMAP 1\",\n       y = \"UMAP 2\",\n       title = \"Diffusion Pseudotime\", \n       subtitle = \"Estimated using Scanpy\") + \n  theme_umap()\n```\n\n::: {.cell-output-display}\n![](Seurat_AnnData_Conversion_files/figure-html/unnamed-chunk-25-1.png)\n:::\n:::\n\n\nWe can also visualize gene dynamics over pseudotime for a few genes of interest. For example, we see that fibronectin 1 (FN1) is highly expressed towards the end of the biological process, specifically in pericyte & endothelial cells. These two celltypes form part of the blood-brain barrier, & are closely related to one another ([source](https://en.wikipedia.org/wiki/Pericyte#Blood–brain_barrier)). \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(cell = colnames(brain), \n           celltype = brain$broad_celltype, \n           dpt = brain$scanpy_dpt, \n           LGALS1 = GetAssayData(brain, \"data\")[\"LGALS1\", ], \n           COL4A1 = GetAssayData(brain, \"data\")[\"COL4A1\", ], \n           RGS5 = GetAssayData(brain, \"data\")[\"RGS5\", ], \n           FN1 = GetAssayData(brain, \"data\")[\"FN1\", ]) %>% \n  tidyr::pivot_longer(cols = !c(cell, celltype, dpt), \n                      names_to = \"gene\", \n                      values_to = \"expression\") %>% \n  ggplot(aes(x = dpt, y = expression)) + \n  facet_wrap(~gene, \n             ncol = 2, \n             nrow = 2) + \n  geom_point(aes(color = celltype), \n             size = 1, \n             alpha = 0.75) + \n  geom_smooth(method = \"gam\", \n              se = FALSE, \n              linewidth = 1.25, \n              color = \"black\") + \n  scale_x_continuous(labels = scales::label_number(accuracy = .1)) + \n  scale_y_continuous(limits = c(0, NA), labels = scales::label_number(accuracy = 1)) + \n  scale_color_manual(values = palette_celltype) + \n  labs(x = \"Diffusion Pseudotime\", \n       y = \"Expression\", \n       title = \"Pseudotemporal Gene Dynamics During Human Embryonic Neurogenesis\", \n       caption = \"Pseudotime estimated using Scanpy\") + \n  theme_classic(base_size = 14, \n                base_line_size = 0.75, \n                base_rect_size = 0.75) + \n  theme(plot.caption = element_text(size = 11, face = \"italic\"), \n        legend.title = element_blank(), \n        strip.text.x = element_text(face = \"italic\"), \n        strip.clip = \"off\", \n        strip.background = element_rect(linewidth = 0.75)) + \n  guides(color = guide_legend(override.aes = list(alpha = 1, size = 4)))\n```\n\n::: {.cell-output-display}\n![](Seurat_AnnData_Conversion_files/figure-html/unnamed-chunk-26-1.png)\n:::\n:::\n\n\n# Conclusions \n\nWith the `reticulate` package it's relatively easy to pass data back and forth between R & Python in order to take advantage of tools & workflows that are only available in one of the two languages. For larger files, or those for which datatype conversion is necessary, writing to disk for conversion is helpful as well. For more information, check out [the `reticulate` documentation](https://rstudio.github.io/reticulate/index.html) and [the `scanpy` documentation](https://scanpy.readthedocs.io/en/stable/). \n\n# Session Info \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.1 (2022-06-23)\n os       macOS Big Sur ... 10.16\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2023-11-02\n pandoc   2.19.2 @ /usr/local/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package                * version   date (UTC) lib source\n abind                    1.4-5     2016-07-21 [1] CRAN (R 4.2.0)\n AnnotationDbi            1.58.0    2022-04-26 [1] Bioconductor\n AnnotationFilter         1.20.0    2022-04-26 [1] Bioconductor\n AnnotationHub            3.4.0     2022-04-26 [1] Bioconductor\n assertthat               0.2.1     2019-03-21 [1] CRAN (R 4.2.0)\n Biobase                * 2.56.0    2022-04-26 [1] Bioconductor\n BiocFileCache            2.4.0     2022-04-26 [1] Bioconductor\n BiocGenerics           * 0.42.0    2022-04-26 [1] Bioconductor\n BiocIO                   1.6.0     2022-04-26 [1] Bioconductor\n BiocManager              1.30.18   2022-05-18 [1] CRAN (R 4.2.0)\n BiocParallel             1.30.3    2022-06-05 [1] Bioconductor\n BiocVersion              3.15.2    2022-03-29 [1] Bioconductor\n biomaRt                * 2.52.0    2022-04-26 [1] Bioconductor\n Biostrings               2.64.1    2022-08-18 [1] Bioconductor\n bit                      4.0.4     2020-08-04 [1] CRAN (R 4.2.0)\n bit64                    4.0.5     2020-08-30 [1] CRAN (R 4.2.0)\n bitops                   1.0-7     2021-04-24 [1] CRAN (R 4.2.0)\n blob                     1.2.3     2022-04-10 [1] CRAN (R 4.2.0)\n cachem                   1.0.6     2021-08-19 [1] CRAN (R 4.2.0)\n cli                      3.6.1     2023-03-23 [1] CRAN (R 4.2.0)\n cluster                  2.1.4     2022-08-22 [1] CRAN (R 4.2.0)\n codetools                0.2-18    2020-11-04 [1] CRAN (R 4.2.1)\n colorspace               2.0-3     2022-02-21 [1] CRAN (R 4.2.0)\n cowplot                  1.1.1     2020-12-30 [1] CRAN (R 4.2.0)\n crayon                   1.5.1     2022-03-26 [1] CRAN (R 4.2.0)\n curl                     4.3.2     2021-06-23 [1] CRAN (R 4.2.0)\n data.table               1.14.2    2021-09-27 [1] CRAN (R 4.2.0)\n DBI                      1.1.3     2022-06-18 [1] CRAN (R 4.2.0)\n dbplyr                   2.2.1     2022-06-27 [1] CRAN (R 4.2.0)\n DelayedArray             0.22.0    2022-04-26 [1] Bioconductor\n deldir                   1.0-6     2021-10-23 [1] CRAN (R 4.2.0)\n digest                   0.6.29    2021-12-01 [1] CRAN (R 4.2.0)\n dplyr                  * 1.0.9     2022-04-28 [1] CRAN (R 4.2.0)\n ellipsis                 0.3.2     2021-04-29 [1] CRAN (R 4.2.0)\n ensembldb                2.20.2    2022-06-21 [1] Bioconductor\n evaluate                 0.16      2022-08-09 [1] CRAN (R 4.2.0)\n ExperimentHub            2.4.0     2022-04-26 [1] Bioconductor\n fansi                    1.0.3     2022-03-24 [1] CRAN (R 4.2.0)\n farver                   2.1.1     2022-07-06 [1] CRAN (R 4.2.0)\n fastmap                  1.1.0     2021-01-25 [1] CRAN (R 4.2.0)\n filelock                 1.0.2     2018-10-05 [1] CRAN (R 4.2.0)\n fitdistrplus             1.1-8     2022-03-10 [1] CRAN (R 4.2.0)\n future                   1.27.0    2022-07-22 [1] CRAN (R 4.2.0)\n future.apply             1.9.0     2022-04-25 [1] CRAN (R 4.2.0)\n generics                 0.1.3     2022-07-05 [1] CRAN (R 4.2.0)\n GenomeInfoDb           * 1.32.3    2022-08-09 [1] Bioconductor\n GenomeInfoDbData         1.2.8     2022-08-29 [1] Bioconductor\n GenomicAlignments        1.32.1    2022-08-02 [1] Bioconductor\n GenomicFeatures          1.48.3    2022-05-31 [1] Bioconductor\n GenomicRanges          * 1.48.0    2022-04-26 [1] Bioconductor\n ggplot2                * 3.4.2     2023-04-03 [1] CRAN (R 4.2.0)\n ggrepel                  0.9.1     2021-01-15 [1] CRAN (R 4.2.0)\n ggridges                 0.5.3     2021-01-08 [1] CRAN (R 4.2.0)\n globals                  0.16.1    2022-08-28 [1] CRAN (R 4.2.1)\n glue                     1.6.2     2022-02-24 [1] CRAN (R 4.2.0)\n goftest                  1.2-3     2021-10-07 [1] CRAN (R 4.2.0)\n gridExtra                2.3       2017-09-09 [1] CRAN (R 4.2.0)\n gtable                   0.3.0     2019-03-25 [1] CRAN (R 4.2.0)\n here                     1.0.1     2020-12-13 [1] CRAN (R 4.2.0)\n hms                      1.1.2     2022-08-19 [1] CRAN (R 4.2.0)\n htmltools                0.5.3     2022-07-18 [1] CRAN (R 4.2.0)\n htmlwidgets              1.5.4     2021-09-08 [1] CRAN (R 4.2.0)\n httpuv                   1.6.5     2022-01-05 [1] CRAN (R 4.2.0)\n httr                     1.4.4     2022-08-17 [1] CRAN (R 4.2.0)\n ica                      1.0-3     2022-07-08 [1] CRAN (R 4.2.0)\n igraph                   1.3.4     2022-07-19 [1] CRAN (R 4.2.0)\n interactiveDisplayBase   1.34.0    2022-04-26 [1] Bioconductor\n IRanges                * 2.30.1    2022-08-18 [1] Bioconductor\n irlba                    2.3.5     2021-12-06 [1] CRAN (R 4.2.0)\n jsonlite                 1.8.0     2022-02-22 [1] CRAN (R 4.2.0)\n KEGGREST                 1.36.3    2022-07-14 [1] Bioconductor\n KernSmooth               2.23-20   2021-05-03 [1] CRAN (R 4.2.1)\n knitr                    1.40      2022-08-24 [1] CRAN (R 4.2.0)\n labeling                 0.4.2     2020-10-20 [1] CRAN (R 4.2.0)\n later                    1.3.0     2021-08-18 [1] CRAN (R 4.2.0)\n lattice                  0.20-45   2021-09-22 [1] CRAN (R 4.2.1)\n lazyeval                 0.2.2     2019-03-15 [1] CRAN (R 4.2.0)\n leiden                   0.4.2     2022-05-09 [1] CRAN (R 4.2.0)\n lifecycle                1.0.3     2022-10-07 [1] CRAN (R 4.2.0)\n listenv                  0.8.0     2019-12-05 [1] CRAN (R 4.2.0)\n lmtest                   0.9-40    2022-03-21 [1] CRAN (R 4.2.0)\n magrittr                 2.0.3     2022-03-30 [1] CRAN (R 4.2.0)\n MASS                     7.3-58.1  2022-08-03 [1] CRAN (R 4.2.0)\n Matrix                   1.4-1     2022-03-23 [1] CRAN (R 4.2.1)\n MatrixGenerics         * 1.8.1     2022-06-30 [1] Bioconductor\n matrixStats            * 0.62.0    2022-04-19 [1] CRAN (R 4.2.0)\n memoise                  2.0.1     2021-11-26 [1] CRAN (R 4.2.0)\n mgcv                     1.8-40    2022-03-29 [1] CRAN (R 4.2.1)\n mime                     0.12      2021-09-28 [1] CRAN (R 4.2.0)\n miniUI                   0.1.1.1   2018-05-18 [1] CRAN (R 4.2.0)\n munsell                  0.5.0     2018-06-12 [1] CRAN (R 4.2.0)\n nlme                     3.1-159   2022-08-09 [1] CRAN (R 4.2.0)\n paletteer              * 1.5.0     2022-10-19 [1] CRAN (R 4.2.0)\n parallelly               1.32.1    2022-07-21 [1] CRAN (R 4.2.0)\n patchwork              * 1.1.2     2022-08-19 [1] CRAN (R 4.2.0)\n pbapply                  1.5-0     2021-09-16 [1] CRAN (R 4.2.0)\n pillar                   1.8.1     2022-08-19 [1] CRAN (R 4.2.0)\n pkgconfig                2.0.3     2019-09-22 [1] CRAN (R 4.2.0)\n plotly                   4.10.0    2021-10-09 [1] CRAN (R 4.2.0)\n plyr                     1.8.7     2022-03-24 [1] CRAN (R 4.2.0)\n png                      0.1-7     2013-12-03 [1] CRAN (R 4.2.0)\n polyclip                 1.10-0    2019-03-14 [1] CRAN (R 4.2.0)\n prettyunits              1.1.1     2020-01-24 [1] CRAN (R 4.2.0)\n prismatic                1.1.1     2022-08-15 [1] CRAN (R 4.2.0)\n progress                 1.2.2     2019-05-16 [1] CRAN (R 4.2.0)\n progressr                0.10.1    2022-06-03 [1] CRAN (R 4.2.0)\n promises                 1.2.0.1   2021-02-11 [1] CRAN (R 4.2.0)\n ProtGenerics             1.28.0    2022-04-26 [1] Bioconductor\n purrr                    0.3.4     2020-04-17 [1] CRAN (R 4.2.0)\n R6                       2.5.1     2021-08-19 [1] CRAN (R 4.2.0)\n RANN                     2.6.1     2019-01-08 [1] CRAN (R 4.2.0)\n rappdirs                 0.3.3     2021-01-31 [1] CRAN (R 4.2.0)\n RColorBrewer             1.1-3     2022-04-03 [1] CRAN (R 4.2.0)\n Rcpp                     1.0.9     2022-07-08 [1] CRAN (R 4.2.0)\n RcppAnnoy                0.0.19    2021-07-30 [1] CRAN (R 4.2.0)\n RCurl                    1.98-1.8  2022-07-30 [1] CRAN (R 4.2.0)\n readr                    2.1.2     2022-01-30 [1] CRAN (R 4.2.0)\n rematch2                 2.1.2     2020-05-01 [1] CRAN (R 4.2.0)\n reshape2                 1.4.4     2020-04-09 [1] CRAN (R 4.2.0)\n restfulr                 0.0.15    2022-06-16 [1] CRAN (R 4.2.0)\n reticulate             * 1.28      2023-01-27 [1] CRAN (R 4.2.0)\n rgeos                    0.5-9     2021-12-15 [1] CRAN (R 4.2.0)\n rjson                    0.2.21    2022-01-09 [1] CRAN (R 4.2.0)\n rlang                    1.1.1     2023-04-28 [1] CRAN (R 4.2.0)\n rmarkdown                2.16      2022-08-24 [1] CRAN (R 4.2.0)\n ROCR                     1.0-11    2020-05-02 [1] CRAN (R 4.2.0)\n rpart                    4.1.16    2022-01-24 [1] CRAN (R 4.2.1)\n rprojroot                2.0.3     2022-04-02 [1] CRAN (R 4.2.0)\n Rsamtools                2.12.0    2022-04-26 [1] Bioconductor\n RSQLite                  2.2.16    2022-08-17 [1] CRAN (R 4.2.0)\n rtracklayer              1.56.1    2022-06-30 [1] Bioconductor\n Rtsne                    0.16      2022-04-17 [1] CRAN (R 4.2.0)\n S4Vectors              * 0.34.0    2022-04-26 [1] Bioconductor\n scales                   1.2.1     2022-08-20 [1] CRAN (R 4.2.0)\n scattermore              0.8       2022-02-14 [1] CRAN (R 4.2.0)\n scRNAseq               * 2.10.0    2022-04-28 [1] Bioconductor\n sctransform              0.3.4     2022-08-20 [1] CRAN (R 4.2.0)\n sessioninfo              1.2.2     2021-12-06 [1] CRAN (R 4.2.0)\n Seurat                 * 4.1.1     2022-05-02 [1] CRAN (R 4.2.0)\n SeuratObject           * 4.1.0     2022-05-01 [1] CRAN (R 4.2.0)\n shiny                    1.7.2     2022-07-19 [1] CRAN (R 4.2.0)\n SingleCellExperiment   * 1.18.0    2022-04-26 [1] Bioconductor\n sp                     * 1.5-0     2022-06-05 [1] CRAN (R 4.2.0)\n spatstat.core            2.4-4     2022-05-18 [1] CRAN (R 4.2.0)\n spatstat.data            3.0-0     2022-10-21 [1] CRAN (R 4.2.0)\n spatstat.geom            3.0-3     2022-10-25 [1] CRAN (R 4.2.0)\n spatstat.random          3.0-1     2022-11-03 [1] CRAN (R 4.2.0)\n spatstat.sparse          3.0-0     2022-10-21 [1] CRAN (R 4.2.0)\n spatstat.utils           3.0-1     2022-10-19 [1] CRAN (R 4.2.0)\n stringi                  1.7.8     2022-07-11 [1] CRAN (R 4.2.0)\n stringr                  1.4.1     2022-08-20 [1] CRAN (R 4.2.0)\n SummarizedExperiment   * 1.26.1    2022-05-01 [1] Bioconductor\n survival                 3.4-0     2022-08-09 [1] CRAN (R 4.2.0)\n tensor                   1.5       2012-05-05 [1] CRAN (R 4.2.0)\n tibble                   3.1.8     2022-07-22 [1] CRAN (R 4.2.0)\n tidyr                    1.2.0     2022-02-01 [1] CRAN (R 4.2.0)\n tidyselect               1.1.2     2022-02-21 [1] CRAN (R 4.2.0)\n tzdb                     0.3.0     2022-03-28 [1] CRAN (R 4.2.0)\n utf8                     1.2.2     2021-07-24 [1] CRAN (R 4.2.0)\n uwot                     0.1.16    2023-06-29 [1] CRAN (R 4.2.0)\n vctrs                    0.6.3     2023-06-14 [1] CRAN (R 4.2.0)\n viridisLite              0.4.1     2022-08-22 [1] CRAN (R 4.2.0)\n vroom                    1.5.7     2021-11-30 [1] CRAN (R 4.2.0)\n withr                    2.5.0     2022-03-03 [1] CRAN (R 4.2.0)\n xfun                     0.32      2022-08-10 [1] CRAN (R 4.2.0)\n XML                      3.99-0.10 2022-06-09 [1] CRAN (R 4.2.0)\n xml2                     1.3.3     2021-11-30 [1] CRAN (R 4.2.0)\n xtable                   1.8-4     2019-04-21 [1] CRAN (R 4.2.0)\n XVector                  0.36.0    2022-04-26 [1] Bioconductor\n yaml                     2.3.5     2022-02-21 [1] CRAN (R 4.2.0)\n zlibbioc                 1.42.0    2022-04-26 [1] Bioconductor\n zoo                      1.8-10    2022-04-15 [1] CRAN (R 4.2.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.2/Resources/library\n\n─ Python configuration ───────────────────────────────────────────────────────\n python:         /Users/jack/Desktop/Python/science/venv/bin/python\n libpython:      /usr/local/opt/python@3.8/Frameworks/Python.framework/Versions/3.8/lib/python3.8/config-3.8-darwin/libpython3.8.dylib\n pythonhome:     /Users/jack/Desktop/Python/science/venv:/Users/jack/Desktop/Python/science/venv\n virtualenv:     /Users/jack/Desktop/Python/science/venv/bin/activate_this.py\n version:        3.8.16 (default, Dec  7 2022, 01:36:11)  [Clang 14.0.0 (clang-1400.0.29.202)]\n numpy:          /Users/jack/Desktop/Python/science/venv/lib/python3.8/site-packages/numpy\n numpy_version:  1.23.5\n \n NOTE: Python version was forced by use_python function\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [
      "Seurat_AnnData_Conversion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}