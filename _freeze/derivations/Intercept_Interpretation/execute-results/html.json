{
  "hash": "0c9544c9c5bc062e5792d470ab2c94ad",
  "result": {
    "markdown": "---\ntitle: \"Understanding Intercepts in Linear Regression Models\"\nauthor:\n  name: Jack Leary\n  email: j.leary@ufl.edu\n  affiliations:\n    - name: University of Florida\n      department: Biostatistics \n      city: Gainesville\n      state: FL\ndate: \"2023-01-10\"\nformat:\n  html:\n    code-fold: show\n    code-copy: true\n    code-tools: true\n    toc: true\n    self-contained: true\n    fig-format: retina\n    df-print: kable\n    link-external-newwindow: true\nexecute: \n  cache: true\n  freeze: auto\n---\n\n::: {.cell hash='Intercept_Interpretation_cache/html/setup_140b266c27bc92b1317dcd3e462c540a'}\n\n:::\n\n\n# Libraries \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-1_13bada5f268386c2079682a763452568'}\n\n```{.r .cell-code}\nlibrary(dplyr)    # data manipulation\nlibrary(ggplot2)  # plots\n```\n:::\n\n\n# Introduction \n\nOne concept I struggled with a lot in early statistics courses was what the intercept meant in linear regression models. I tended to just ignore it unless questions specifically pertained to it, and the vast majority of homework questions focused on interpreting the effects of covariates instead. I also saw many of my master's-level students struggle with the topic in the SAS computing course I taught during Fall 2022 as well, with confusion about the effect of centering, the difference between centering and standardizing, and intercept interpretation in the different types of (generalized) linear (mixed) models being common pain points on homeworks. As such, I thought it might be useful - for myself and others - to jot down some notes on how the intercept is estimated and what it means under a variety of regression modelling frameworks. \n\n# Matrix Algebra Review \n\nWe're going to start from first principles here with a quick review on matrix algebra. Linear regression is, after, just multiplying matrices in a clever way. \n\n## Multiplication \n\n### Theory \n\nFirst define two matrices $\\mathbf{A}$ and $\\mathbf{B}$, each with 2 rows and 2 columns:\n\n$$\n\\begin{aligned}\n\\mathbf{A} &= \n    \\begin{bmatrix} \n      a_{11} & a_{21} \\\\\n      a_{12} & a_{22} \\\\\n    \\end{bmatrix} \\\\\n\\mathbf{B} &= \n  \\begin{bmatrix} \n    b_{11} & b_{21} \\\\\n    b_{12} & b_{22} \\\\\n  \\end{bmatrix} \\\\\n\\end{aligned}\n$$\n\nTheir product, another matrix $C$, also has 2 rows and 2 columns, and its elements are defined like so, with $i$ specifying the row and $j$ the column of each element. What we're doing is finding the dot product of the $i^{\\text{th}}$ row of $\\mathbf{A}$ and the $j^{\\text{th}}$ column of $\\mathbf{B}$, the expanded definition of which is below. \n\n$$\n\\begin{aligned}\nc_{ij} &= \\mathbf{A}_{i*} \\cdot \\mathbf{B}_{*j} \\\\\nc_{ij} &= \\sum_{k=1}^n a_{ik}b_{kj} \\\\\nc_{ij} &= a_{i1}b_{1j} + \\dots + a_{n1}b_{nj} \\\\\n\\end{aligned}\n$$\n\nAs such, we can define the product of $\\mathbf{A}$ and $\\mathbf{B}$ like so:\n\n$$\n\\begin{aligned}\n\\mathbf{C} &=  \\mathbf{A} \\mathbf{B} \\\\\n\\mathbf{C} &= \n  \\begin{bmatrix} \n    \\mathbf{A}_{1*} \\cdot \\mathbf{B}_{*1} & \\mathbf{A}_{2*} \\cdot \\mathbf{B}_{*1} \\\\\n    \\mathbf{A}_{2*} \\cdot \\mathbf{B}_{*1} & \\mathbf{A}_{2*} \\cdot \\mathbf{B}_{*2} \\\\\n  \\end{bmatrix} \\\\\n\\mathbf{C} &= \n  \\begin{bmatrix} \n    a_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\\\\n    a_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22} \\\\\n  \\end{bmatrix} \\\\\n\\end{aligned}\n$$\n\n**Important Note**: To multiply two matrices $\\mathbf{A}$ and $\\mathbf{B}$ together, the number of rows of $\\mathbf{B}$ must be equal to the number of columns in $\\mathbf{A}$. To generalize: \n\n$$\n\\mathbf{A}_{mn} \\cdot \\mathbf{B}_{np} = \\mathbf{C}_{mp}\n$$\n\n### Example \n\nLet's define two matrices:\n\n$$\n\\begin{aligned}\n\\mathbf{A} &= \n  \\begin{bmatrix} \n    3 & 2 \\\\\n    0 & 7 \\\\\n  \\end{bmatrix} \\\\\n\\mathbf{B} &= \n  \\begin{bmatrix} \n    1 & 4 \\\\\n    1 & 2 \\\\\n  \\end{bmatrix} \\\\\n\\end{aligned}\n$$\n\nTheir product $\\mathbf{C}$ is defined as:\n\n$$\n\\begin{aligned}\n\\mathbf{C} &= \n  \\begin{bmatrix} \n    3 \\times 1 + 2 \\times 1 & 3 \\times 4 + 2 \\times 2 \\\\\n    0 \\times 1 + 7 \\times 1 & 0 \\times 4 + 7 \\times 2 \\\\\n  \\end{bmatrix} \\\\\n\\mathbf{C} &= \n  \\begin{bmatrix} \n    5 & 16 \\\\\n    7 & 14 \\\\\n  \\end{bmatrix} \\\\\n\\end{aligned}\n$$\n\nWe can check this using R:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-2_b66bd4ee45104f7643173321b012a6c2'}\n\n```{.r .cell-code}\nA_mat <- matrix(c(3, 2, 0, 7), \n                nrow = 2, \n                ncol = 2, \n                byrow = TRUE)\nB_mat <- matrix(c(1, 4, 1, 2), \n                nrow = 2, \n                ncol = 2, \n                byrow = TRUE)\nC_mat <- A_mat %*% B_mat\nC_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    5   16\n[2,]    7   14\n```\n:::\n:::\n\n\n## Transposition \n\n### Theory \n\n### Example \n\n## Inversion \n\n### Theory \n\n### Example \n\n\n## The Identity Matrix \n\n### Theory \n\nThe identity matrix $\\mathbf{I}_{n}$ is a square matrix composed entirely of zeroes *except* along the diagonal, which is composed of ones. This matrix carries some unique properties (which are listed below) that will be helpful to us later on.  \n\n$$\n\\begin{aligned}\n\\mathbf{I}_{n} &= \n  \\begin{bmatrix} \n    1 & 0 & \\cdots & 0 \\\\ \n    0 & 1 & \\cdots & 0 \\\\ \n    \\vdots & \\vdots & \\ddots & 0 \\\\ \n    0 & 0 & 0 & 1 \\\\\n  \\end{bmatrix} \\\\\n\\mathbf{I}_{n}^\\prime &= \\mathbf{I}_{n} \\\\\n\\mathbf{I}_{n}^{-1} &= \\mathbf{I}_{n} \\\\\n\\end{aligned}\n$$\n\n### Example \n\nWe can set up a $3 \\times 3$ identity matrix $\\mathbf{I}_{3}$ in R using the `diag()` function:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-3_c0e633250aca2d20db6b94ae95bda0f4'}\n\n```{.r .cell-code}\nident_mat <- diag(nrow = 3)\nident_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n:::\n:::\n\n\nThe transpose is also equal to $\\mathbf{I}_{3}$:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-4_cddaf419452517147f8d064f0583f41e'}\n\n```{.r .cell-code}\nt(ident_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n:::\n:::\n\n\nAs is the inverse: \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-5_3a01a739467d74e02cac733cd48f8158'}\n\n```{.r .cell-code}\nsolve(ident_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n:::\n:::\n\n\n# Linear Model \n\n## Setup \n\nFor now, we'll take it for granted that the solution to a linear regression problem is defined as follows:\n\n$$\n\\widehat{\\boldsymbol{\\beta}} = \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime \\mathbf{y}\n$$\n\n## The Intercept-only Model \n\nThe intercept-only model (also sometimes called the null model) is defined as linear regression when $\\mathbf{X}$ is simply a column vector of ones:\n\n$$\n\\mathbf{X} = \n  \\begin{bmatrix} \n    1 \\\\\n    \\vdots \\\\\n    1 \\\\\n  \\end{bmatrix}\n$$\n\nWe know the intercept-only model produces the mean as the one predicted value, as the mean minimizes the sum of squared errors in the absence of any other covariates. We can check this using R - we'll first generate a vector $\\mathbf{y}$ consisting of 5 realizations of a random variable, such that $Y \\sim \\mathcal{N}(0, 3)$. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-6_4c38c4f4bd9b01f591b9f648e3914d3b'}\n\n```{.r .cell-code}\ny <- rnorm(5, mean = 0, sd = 3)\ny <- matrix(y, ncol = 1)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]\n[1,]  2.4364366\n[2,]  4.5241548\n[3,]  2.7447766\n[4,] -2.2354806\n[5,] -0.2949723\n```\n:::\n:::\n\n\nThe mean of $\\mathbf{y}$ is:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-7_d1bceb40fd4794b8fc8a7dfd42d3407f'}\n\n```{.r .cell-code}\nmean(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.434983\n```\n:::\n:::\n\n\nWe can use R to fit an intercept-only model. We can see that the intercept coefficient $\\beta_0$ is equal to the mean of $\\mathbf{y}$. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-8_f34a4f53006b799c7fe44e1ea386ec41'}\n\n```{.r .cell-code}\nnull_mod <- lm(y ~ 1)\ncoef(null_mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   1.434983 \n```\n:::\n:::\n\n\nLet's use linear algebra to figure out why this is true. Once again, we know that the linear regression closed-form solution is given by the following: \n\n$$\n\\widehat{\\boldsymbol{\\beta}} = \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime \\mathbf{y}\n$$\n\nLet's first define $\\mathbf{X}$ - just a column vector of 1s with $n = 5$ rows:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-9_f5dad9eca744e5f5c9b9492fa4e5b91b'}\n\n```{.r .cell-code}\nX <- c(1, 1, 1, 1, 1)\nX <- matrix(X, ncol = 1)\nX\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]    1\n[2,]    1\n[3,]    1\n[4,]    1\n[5,]    1\n```\n:::\n:::\n\n\nThe value of $\\mathbf{X}^\\prime \\mathbf{X}$ is given by the following - note that this is equal to our sample size $n = 5$. We knew that this quantity would be a scalar (a $1 \\times 1$ matrix) since $\\mathbf{X}^\\prime$ has 1 row and 5 columns, and $\\mathbf{X}$ has 5 rows and 1 column, thus by the rule we defined above their product has 1 row and 1 column. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-10_feae26c018c86d51bbd25c6a1bc0d182'}\n\n```{.r .cell-code}\nt(X) %*% X\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]    5\n```\n:::\n:::\n\n\nThe inverse of which, $\\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1}$, is of course $n^{-1}$:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-11_a494a077c3644022c252e9c91b7f5dfc'}\n\n```{.r .cell-code}\nsolve(t(X) %*% X)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]  0.2\n```\n:::\n:::\n\n\nWe multiply the above by $\\mathbf{X}^\\prime$ again to obtain $\\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime$, which gives us a constant vector of length $n$ with all values being equal to $n^{-1}$:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-12_e47a33bfe9f102dab58bbc8f0249e6cb'}\n\n```{.r .cell-code}\nsolve(t(X) %*% X) %*% t(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]  0.2  0.2  0.2  0.2  0.2\n```\n:::\n:::\n\n\nLastly, we multiply the above by $\\mathbf{y}$. Remember how multiplying vectors works - in this case we are multiplying each element of the above vector $\\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime$ with each element of $\\mathbf{y}$ and adding them together. We'll define $\\mathbf{Z} = \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime$ for convenience of notation: \n\n$$\n\\mathbf{Z} \\mathbf{y} = \\sum_{i=1}^n \\mathbf{Z}_i \\mathbf{y}_i\n$$\n\nSince each element of $\\mathbf{Z}$ is the same, $n^{-1}$, by the transitive property the above quantity is equivalent to:\n\n$$\n\\begin{aligned}\n  \\mathbf{Z} \\mathbf{y} &= \\left(\\mathbf{X}^\\prime \\mathbf{X} \\right)^{-1} \\mathbf{X}^\\prime \\mathbf{y} \\\\\n  \\mathbf{Z} \\mathbf{y} &= \\sum_{i=1}^n \\mathbf{Z}_i \\mathbf{y}_i \\\\\n  \\mathbf{Z} \\mathbf{y} &= n^{-1} \\sum_{i=1}^n \\mathbf{y}_i \\\\\n\\end{aligned}\n$$\n\nThis is simply the sum of all the elements of $\\mathbf{y}$ divided by $n$ - the mean! We can verify this with R by using linear algebra to compute the OLS solution:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-13_94917f02036480cc6a3ecf8d3813f929'}\n\n```{.r .cell-code}\nsolve(t(X) %*% X) %*% t(X) %*% y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         [,1]\n[1,] 1.434983\n```\n:::\n:::\n\n\nThis is equal to simply taking the mean of $\\mathbf{y}$: \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-14_e76c314aad9b0b77ae1dc2abc63a6ad1'}\n\n```{.r .cell-code}\nmean(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.434983\n```\n:::\n:::\n\n\n## Models with Categorical Predictors\n\nIn practice of course we usually build models with predictors of interest outside of the intercept. Categorical variables are composed of discrete values, each with a different meaning e.g., we could have a variable containing the type of treatment a patient has received. In order to fit models with categorical variables, it's necessary to expand a categorical variable into multiple indicator variables - variables composed of 1s and 0s depending on whether a certain observation belongs to a certain category. This is a little confusing, so let's show an example. We'll start by creating a categorical variable . \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-15_39232fe9ce86a39128a98a7cb158ef13'}\n\n```{.r .cell-code}\nX <- sample(c(\"A\", \"B\"), size = 10, replace = TRUE)\nX <- matrix(X, ncol = 1)\nX\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n [1,] \"A\" \n [2,] \"A\" \n [3,] \"A\" \n [4,] \"B\" \n [5,] \"A\" \n [6,] \"A\" \n [7,] \"A\" \n [8,] \"B\" \n [9,] \"A\" \n[10,] \"A\" \n```\n:::\n:::\n\n\nTo convert $\\mathbf{X}$ into a numeric variable that we can use in a model, we use the `model.matrix()` function. To use this function though, we need to define the model we're interested in using R's [formula syntax](https://r4ds.github.io/bookclub-tmwr/r-formula-syntax.html). The output we see shows an intercept column, which we understand, and another column composed of 1s and 0s called **XB**. This column is an indicator variable that tells us whether each observation belongs to category **B** or not - thus when **XB** is equal to 0, we know that the observation belongs to category **A**. This process of converting non-numeric categorical data to indicator variables has many names (one-hot encoding, dummifying, etc.), and there's many ways of doing it. You can read more about the various ways of doing so [here](https://stats.oarc.ucla.edu/spss/faq/coding-systems-for-categorical-variables-in-regression-analysis/), but for now we'll take it for granted that this is how it works under the hood in the `lm()` function that we use to fit linear models. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-16_abb877b922629c704f09da1e7a0ec509'}\n\n```{.r .cell-code}\nX_2 <- model.matrix(~X)\nX_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   (Intercept) XB\n1            1  0\n2            1  0\n3            1  0\n4            1  1\n5            1  0\n6            1  0\n7            1  0\n8            1  1\n9            1  0\n10           1  0\nattr(,\"assign\")\n[1] 0 1\nattr(,\"contrasts\")\nattr(,\"contrasts\")$X\n[1] \"contr.treatment\"\n```\n:::\n:::\n\n\nFrom what we already know about matrix multiplication, we can see that the **B** group is going to have a different predicted average than the **A** group. We'll also need to generate a new response variable $\\mathbf{y}$, since we've increased our sample size to $n = 10$. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-17_fd2279d1807fb08bf05fb290b55d1186'}\n\n```{.r .cell-code}\ny <- rnorm(10, mean = 0, sd = 3)\ny <- matrix(y, ncol = 1)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]\n [1,]  4.356184\n [2,] -2.261118\n [3,]  3.439089\n [4,] -2.163296\n [5,] -1.421789\n [6,]  2.038185\n [7,]  2.707313\n [8,] -3.360417\n [9,]  2.631489\n[10,] -5.837502\n```\n:::\n:::\n\n\nThe mean of $\\mathbf{y}$ for each treatment group can be computed as follows. We're going to use a little `{dplyr}` code to perform the summarization, as I find it a little more readable & replicable than base R. This will necessitate creating a `data.frame` to hold our $\\mathbf{y}$ and $\\mathbf{X}$ variables. Note that we've switched back to the categorical representation of $\\mathbf{X}$, as it's more interpretable than the indicator variable version for summaries such as this. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-18_1f89e5e4ebc5e8685579be113452613a'}\n\n```{.r .cell-code}\ndata.frame(X = X, y = y)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|X  |         y|\n|:--|---------:|\n|A  |  4.356184|\n|A  | -2.261118|\n|A  |  3.439089|\n|B  | -2.163296|\n|A  | -1.421789|\n|A  |  2.038185|\n|A  |  2.707313|\n|B  | -3.360417|\n|A  |  2.631489|\n|A  | -5.837502|\n\n</div>\n:::\n:::\n\n\nHere's the mean for each group: \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-19_ff8f8b97d5ccc5e26096f9fe85f34966'}\n\n```{.r .cell-code}\ndata.frame(X = X, y = y) %>% \n  with_groups(X, \n              summarise, \n              mu = mean(y))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|X  |         mu|\n|:--|----------:|\n|A  |  0.7064813|\n|B  | -2.7618564|\n\n</div>\n:::\n:::\n\n\nLet's use the OLS formula to solve for $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1]$. Note that we're once again using the design matrix version of $\\mathbf{X}$ with the intercept column and indicator variable for group. We see that the intercept $\\beta_0$ is equal to the mean of the **A** group - but the coefficient for the **B** group $\\beta_1$ isn't! This is because $\\beta_1$ doesn't have the same interpretation as $\\beta_0$. While $\\beta_0$ is equal to the mean of the reference group (i.e., the first level of the categorical variable, in our case group **A**), $\\beta_1$ represents the difference between the mean for group **A** and the mean for group **B**. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-20_9bf3a54654376543baf9802cbaf155b0'}\n\n```{.r .cell-code}\ncat_mod_beta <- solve(t(X_2) %*% X_2) %*% t(X_2) %*% y\ncat_mod_beta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  [,1]\n(Intercept)  0.7064813\nXB          -3.4683377\n```\n:::\n:::\n\n\nThis becomes easier to understand when we sum the coefficients and get the average for group **B**, which is -2.7618564. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-21_4b5ee12e90a901cbe982ba28099ca786'}\n\n```{.r .cell-code}\nsum(cat_mod_beta)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2.761856\n```\n:::\n:::\n\n\nThis is validated by fitting a linear model with `lm()` and checking the output, which matches our manual solution:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-22_d4e71f6dfc3f4e91f43a97f8a49bf6b5'}\n\n```{.r .cell-code}\ncat_mod <- lm(y ~ X)\ncoef(cat_mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)          XB \n  0.7064813  -3.4683377 \n```\n:::\n:::\n\n\nTo summarize: when categorical variables are used in an ordinary linear regression, the intercept represents the mean of the response variable when each of the categorical variables is at its reference level. When running regressions like this, it's important to make sure that 1) you know what the reference levels are for each of your categorical variables and 2) that those reference levels make sense. Sometimes it doesn't matter what order the categorical variables are in, but it often does - so check! A final note is that this interpretation holds when *only* categorical variables are used in your model. When continuous variables are included too, the interpretation changes. More on that in a bit. \n\n**Note**: Working with categorical variables (or factors, as R labels them) can be confusing. If you want to gain a deeper understanding of how factors work, check out [the chapter on them in the R for Data Science book](https://r4ds.had.co.nz/factors.html). For factor-related tools, try the [`{forcats}` R package](https://forcats.tidyverse.org/articles/forcats.html), which is part of the [`{tidyverse}`](https://www.tidyverse.org) ecosystem and makes dealing with factors a lot simpler. \n\n## Models with Continuous Predictors \n\nContinuous predictors differ from categorical ones in that they do not have a discrete set of possible values. The interpretation of the intercept thus differs. For any regression, the intercept interpretation is the value of the response when all predictors are equal to zero. What \"all predictors equal to zero\" means depends on the types of predictors you're using; when predictors are categorical this implies that all predictors are at their reference levels (thanks to the indicator variable encoding that's done in the background). With continuous variables, being equal to zero might have a reasonable interpretation or it might not, depending on what the variable is. In this case, think of the intercept like you would in middle school when learning $y = mx + b$. The intercept, $b$, is the value of $y$ where $x = 0$, like the plot below. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-23_e91a1bcef10a4ae86d60f44d08632eff'}\n\n```{.r .cell-code}\ndata.frame(x = rnorm(500, sd = 2)) %>% \n  mutate(y = x + rnorm(500, sd = 0.5)) %>% \n  ggplot(aes(x = x, y = y)) + \n  geom_point(alpha = 0.8) + \n  geom_vline(xintercept = 0, color = \"forestgreen\", size = 1) +\n  labs(x = \"X\", y = \"Y\") + \n  theme_classic(base_size = 14)\n```\n\n::: {.cell-output-display}\n![](Intercept_Interpretation_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\nIn some cases, this value might be meaningful - for example, if your covariate of interest was the expression of a certain gene, then zero expression has a biological meaning. In other situations it makes little sense, such as when the covariate of interest is the age of each patient in your dataset. It's unlikely that age being equal to zero would really mean much, as newborns aren't often part of clinical trials. There's ways to remedy this difficulty in interpretation, but we'll focus first on why the interpretation is the way it is. \n\nWe'll start by generating some data. The predictor variable we're interested in will be negative-binomially distributed, with $X \\sim \\text{NB}(10, 0.7)$. Note that we're using the parameterization of the negative binomial used in the `rnbinom()` function defaults, with the `size` and `probability` parameters. Our response variable $\\mathbf{y}$ will be a function of $\\mathbf{X}$ with added normally-distributed noise. Since we've increased our sample size to $n = 500$, we'll only look at the first few rows of each variable. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-24_17745cf37cdd76b2cc1fc82993cd7f92'}\n\n```{.r .cell-code}\nX <- rnbinom(500, size = 10, prob = 0.7)\ny <- 2 * X + rnorm(500, mean = 0, sd = 2)\nX <- matrix(X, ncol = 1)\ny <- matrix(y, ncol = 1)\ndata.frame(X = X[, 1], y = y[, 1]) %>% \n  slice_head(n = 5)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"X\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"5\",\"2\":\"10.287256\"},{\"1\":\"3\",\"2\":\"4.088222\"},{\"1\":\"4\",\"2\":\"8.427853\"},{\"1\":\"3\",\"2\":\"2.667721\"},{\"1\":\"2\",\"2\":\"2.340896\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nWe can plot the data using `{ggplot2}` to get an idea of what the relationship between the two variables is. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-25_d132c62af007d8213e02f1ffa253819d'}\n\n```{.r .cell-code}\ndata.frame(X = X[, 1], y = y[, 1]) %>% \n  ggplot(aes(x = X, y = y)) + \n  geom_point() + \n  labs(x = \"X\", y = \"y\") + \n  theme_classic(base_size = 14)\n```\n\n::: {.cell-output-display}\n![](Intercept_Interpretation_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nUsing `{dplyr}`, we can find the mean of $\\mathbf{y}$ when $\\mathbf{X} = 0$. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-26_1f275b34347de47acaa263db1fbabe61'}\n\n```{.r .cell-code}\ndata.frame(X = X[, 1], y = y) %>% \n  filter(X == 0) %>% \n  summarise(mu = mean(y))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|        mu|\n|---------:|\n| 0.7797701|\n\n</div>\n:::\n:::\n\n\nLet's fit a linear model manually and see what the coefficients are. We'll first need to create the design matrix again using `model.matrix()`. This gives us a two column matrix, with the first column being the intercept (all 1s), and the second column being the negative binomial random variable $\\mathbf{X}$ we just simulated. Unlike models with categorical predictors, the intercept is *not* simply equal to the expected value when $\\mathbf{X} = 0$. Instead, the intercept is the expected value of the response variable conditional on the line of best fit that has been obtained i.e., conditional on the rest of the data in $\\mathbf{X}$. See [this StackOverflow post](https://stackoverflow.com/questions/49085049/why-is-the-intercept-not-the-mean-at-the-continuous-predictor-being-zero) for another example. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-27_0eba903d03e81a586d6324cc831190e5'}\n\n```{.r .cell-code}\nX_3 <- model.matrix(~X)\ncont_mod_beta <- solve(t(X_3) %*% X_3) %*% t(X_3) %*% y\ncont_mod_beta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   [,1]\n(Intercept) -0.02556166\nX            2.02990215\n```\n:::\n:::\n\n\n\nWe can validate the above by fitting a linear model with `lm()` and checking the coefficients $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1]$, which are equal to our manually-computed coefficients. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-28_7ab76fa502ebda55f2778ac07bc6f250'}\n\n```{.r .cell-code}\ncont_mod <- lm(y ~ X)\ncoef(cont_mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)           X \n-0.02556166  2.02990215 \n```\n:::\n:::\n\n\n### Centering Continuous Predictors\n\nOne way to make models like this more interpretable is to center continuous variables around their means. Doing so ensures that the centered version of continuous variable is equal to zero when the original version of the variable is at its mean. This can give a better interpretation to some models e.g., if the continuous variable of interest was patient age, then the intercept would be the expected value of the response for a patient of mean age. Since centering doesn't change the units of the continuous variable, only the intercept $\\beta_0$ will change i.e., the coefficient for our predictor of interest will stay the same. We can validate this by creating a centered version of $\\mathbf{X}$ and re-running the regression. The `scale()` function centers (subtracts the mean) *and* standardizes (divides by the standard deviation) by default, so we need to set `scale = FALSE` in order to only center the data. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-29_415b4b9d9a50ff7658518745827faafe'}\n\n```{.r .cell-code}\nX_cent <- scale(X, scale = FALSE)\ncont_mod_centered <- lm(y ~ X_cent)\ncoef(cont_mod_centered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)      X_cent \n   8.776094    2.029902 \n```\n:::\n:::\n\n\n### Standardizing Continuous Predictors \n\nStandardizing (or scaling, as R calls it) can also occasionally be useful. Dividing by the standard deviation in addition to centering results in our continuous random variable having mean 0 and standard deviation 1. This does change the units of the variable though, which is important to remember. It does not, however, change the interpretation of the intercept - which remains unchanged from the model we fit above with only centering. The coefficient $\\beta_1$ differs though, and now represents the change in $\\mathbf{y}$ given a one standard deviation increase in $\\mathbf{X}$. For more on standardization see [this StatLect post](https://statlect.com/fundamentals-of-statistics/linear-regression-with-standardized-variables) and [this blog post from Columbia's Dr. Andrew Gelman](https://statmodeling.stat.columbia.edu/2009/07/11/when_to_standar/).\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-30_998f09aca8def2a23d8167e7f9ec6bb3'}\n\n```{.r .cell-code}\nX_scaled <- scale(X)\ncont_mod_scaled <- lm(y ~ X_scaled)\ncoef(cont_mod_scaled)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)    X_scaled \n   8.776094    4.960213 \n```\n:::\n:::\n\n\nLastly, with respect to standardization at least, it's important to note that if we standardize the response variable $\\mathbf{y}$ in addition to standardizing the predictor matrix $\\mathbf{X}$, the intercept will disappear i.e., it will become zero. This is because after standardization, the means of both the predictor and response variables are equal to zero. Since the intercept is the mean of the response when the predictor is zero, the intercept is also zero. Note that because of how integers work in computer memory the value of the intercept shown below isn't quite zero, but it is very close. For another example of this, see [this Stackoverflow post](https://stats.stackexchange.com/questions/43036/why-does-the-y-intercept-of-a-linear-model-disappear-when-i-standardize-variable). \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-31_96dea35db4dd90ae990ddfc269add504'}\n\n```{.r .cell-code}\ny_scaled <- scale(y)\ncont_mod_resp_scaled <- lm(y_scaled ~ X_scaled)\ncoef(cont_mod_resp_scaled)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n (Intercept)     X_scaled \n1.910689e-16 9.252827e-01 \n```\n:::\n:::\n\n\n## Models with Categorical & Continuous Predictors \n\nFinally, let's put it all together. In most real-life modeling scenarios you'll have a mix of categorical and continuous predictors, and thus care must be taken when preparing the data. You generally will want your intercept to be meaningful - whatever that means for the data you're analyzing. In this case, we'll simulate data under the following scenario: our response variable $\\mathbf{y}$ is the expression of some gene of interest in each of $n = 500$ patients, and our predictor matrix $\\mathbf{X}$ is composed of one categorical variable representing a treatment, a continuous variable representing patient age in years, and another categorical variable representing the facility at which each patient was treated. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-32_e671d408e77295ba87ac9949bd421253'}\n\n```{.r .cell-code}\nX_df <- data.frame(age = rpois(500, lambda = 30), \n                   treatment = sample(c(\"A\", \"B\"), 500, replace = TRUE), \n                   facility = sample(c(\"Hosp1\", \"Hosp2\"), 500, replace = TRUE)) %>% \n        mutate(y = 2 * age + rpois(500, lambda = 10), \n               y = case_when(treatment == \"A\" ~ 0.7 * y - rpois(1, lambda = 20), \n                             TRUE ~ y), \n               y = case_when(facility == \"Hosp2\" ~ y + rpois(1, lambda = 10), \n                             TRUE ~ y))\n```\n:::\n\n\nThe above code to might be a bit confusing - we simulate **age** as a Poisson random variable with a mean of 30 years, and randomly assign one of two treatments and one of two facilities to each patient. Our response variable $\\mathbf{y}$ is a function of all three predictors. We start by multiplying **age** by two and then adding Poisson-distributed random noise. We change the slope and subtract Poisson noise for treatment group **A**, and add Poisson-distributed noise for facility group **Hosp2**. Visualizing the data should help make sense of this process:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-33_e8ac3954b475f141e85772c495604740'}\n\n```{.r .cell-code}\nggplot(X_df, aes(x = age, y = y, color = treatment)) + \n  facet_wrap(~facility) + \n  geom_point(alpha = 0.8) + \n  geom_smooth(mapping = aes(group = treatment), \n              color = \"black\",\n              method = \"lm\", \n              show.legend = FALSE) + \n  labs(x = \"Age (Years)\", \n       y = \"Gene Expression\", \n       color = \"Treatment\") + \n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](Intercept_Interpretation_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\nWe can see that the lowest value of **age** in our dataset is 15, and thus it doesn't really make sense to have our intercept correspond to **age** being equal to 0. Instead, we should center **age**, which will ensure that our intercept represents the expected value of $\\mathbf{y}$ for a patient of mean age that was given treatment **A** at facility **Hosp1**. The reference groups for each categorical variable are known since R sorts categorical variables alphabetically by default (though this can be overridden through functions like `relevel()`). \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-34_e66ffd140c629986b0f22c37d8f2666d'}\n\n```{.r .cell-code}\nX_df <- mutate(X_df, \n               age_centered = scale(age, scale = FALSE))\n```\n:::\n\n\nNow that we have our centered variable, we can set up our design matrix. We use the formula syntax to specify which predictors we're interested in. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-35_8cabe9d30ac8adbbf713231012b928cd'}\n\n```{.r .cell-code}\nX_design_mat <- model.matrix(~age_centered + treatment + facility, data = X_df)\nhead(X_design_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  (Intercept) age_centered treatmentB facilityHosp2\n1           1        3.622          1             0\n2           1       -1.378          1             1\n3           1        3.622          1             1\n4           1        0.622          0             0\n5           1        3.622          1             1\n6           1        6.622          0             0\n```\n:::\n:::\n\n\nWe can now solve the ordinary linear regression problem by hand to obtain the coefficient vector $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3]$. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-36_a55eaf4687a44211de33d6ede3d37275'}\n\n```{.r .cell-code}\nfull_mod_beta <- solve(t(X_design_mat) %*% X_design_mat) %*% t(X_design_mat) %*% X_df$y\nfull_mod_beta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   [,1]\n(Intercept)   34.428233\nage_centered   1.672477\ntreatmentB    36.374068\nfacilityHosp2  8.128789\n```\n:::\n:::\n\n\nWe can verify the result once again using `lm()`. The interpretation for $\\beta_0$ is the expected response for a patient of mean **age** who is taking treatment **A** at facility **Hosp1**. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-37_af5f4f75fddc7c2f6122b7b1fd466977'}\n\n```{.r .cell-code}\nfull_mod <- lm(y ~ age_centered + treatment + facility, X_df)\ncoef(full_mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  (Intercept)  age_centered    treatmentB facilityHosp2 \n    34.428233      1.672477     36.374068      8.128789 \n```\n:::\n:::\n\n\n# Generalized Linear Model\n\n## Setup \n\nWe'll next move to the more complicated case of the generalized linear model (GLM). We'll start by defining the basic form of a GLM; the main difference from an ordinary linear model is that the model's response variable is a transformation of the actual response variable. This transformation is taken via what we call a [link function](https://en.wikipedia.org/wiki/Generalized_linear_model#Link_function). There are some detail here I'm skipping over, but in practice the link function is usually the natural log, and can be others such as the logit (for logistic regression). The link function is usually denoted $g(\\cdot)$, which gives us the following general form of a GLM with $p$ covariates:\n\n$$\ng(\\mathbb{E}[\\mathbf{y}]) = \\beta_0 + \\beta_1 \\mathbf{X}_1 + \\dots + \\beta_p\\mathbf{X}_p\n$$\n\nLike ordinary linear models, GLMs are linear in their covariates (as shown above), which is what gives them their relatively easy interpretations. However, unlike with ordinary linear regression, there is no simple closed-form solution to the above equation. Instead, a solution is estimated using something like iteratively reweighted least squares or Newton's method. As such, we won't be able to provide exact calculations of the GLM solutions like we did above with the ordinary linear models, so we'll stick to first providing the interpretation and then checking to make sure the fitted model matches that interpretation.  \n\n## The Intercept-only Model \n\nIn the intercept-only model, the GLM formula becomes: \n\n$$\n\\begin{aligned}\ng(\\mathbb{E}[\\mathbf{y}]) &= \\beta_0 \\\\\n\\mathbb{E}[\\mathbf{y}] &= g^{-1}(\\beta_0) \\\\\n\\end{aligned}\n$$\n\nIf we're using $g(\\cdot) = \\text{log}(\\cdot)$ (the log-link), then the inverse of $g(\\cdot)$ is $g^{-1}(\\cdot) = \\text{exp}(\\cdot)$. In this case, it's easy to see that the intercept $\\beta_0$ is actually the natural log of the mean of the response variable $\\mathbf{y}$. \n\nWe can verify this in R. In this example we'll use a Poisson GLM with a log link function, as it's probably the simplest to understand. We'll start by simulating a Poisson-distributed response $\\mathbf{y} \\sim \\text{Poisson}(5)$ with $n = 10$. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-38_74077d138816538ea61b1ce14793485f'}\n\n```{.r .cell-code}\ny <- rpois(10, lambda = 5)\ny <- matrix(y, ncol = 1)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n [1,]    3\n [2,]    4\n [3,]    7\n [4,]    8\n [5,]    8\n [6,]    4\n [7,]    3\n [8,]    8\n [9,]   11\n[10,]    6\n```\n:::\n:::\n\n\nThe mean of $\\mathbf{y}$ is 6.2, and the log of that quantity is:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-39_ea836b589973b305bac8db77fdfd0dd7'}\n\n```{.r .cell-code}\nlog(mean(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.824549\n```\n:::\n:::\n\n\nWe can fit a Poisson GLM like so. We can clearly see that $\\beta_0 = \\text{log}(\\bar{\\mathbf{y}})$. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-40_b6e27abc1f17f784943156d9679aabd7'}\n\n```{.r .cell-code}\nnull_mod_pois <- glm(y ~ 1, family = poisson(link = \"log\"))\ncoef(null_mod_pois)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   1.824549 \n```\n:::\n:::\n\n\nThus, when we use the inverse of the link function (exponentiation) on the estimated value of $\\beta_0$, we get the value of $\\mathbb{E}[\\mathbf{y}] = 6.2$. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-41_17dcbca4d8d56ef52565061f34c8caf3'}\n\n```{.r .cell-code}\nexp(coef(null_mod_pois))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n        6.2 \n```\n:::\n:::\n\n\n## Models with Categorical Predictors \n\nThe extension to categorical predictors is much the same as we saw before with ordinary linear models, with the primary change being that we're now working on the log scale. Let's add a categorical predictor to our model. First we simulate a categorical $\\mathbf{X}$: \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-42_a5a5fa49f3c01a464e2ad708c4f16a9b'}\n\n```{.r .cell-code}\nX <- sample(c(\"A\", \"B\"), size = 10, replace = TRUE)\nX <- matrix(X, ncol = 1)\nX\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n [1,] \"B\" \n [2,] \"B\" \n [3,] \"B\" \n [4,] \"A\" \n [5,] \"A\" \n [6,] \"A\" \n [7,] \"A\" \n [8,] \"B\" \n [9,] \"A\" \n[10,] \"A\" \n```\n:::\n:::\n\n\nAgain using `{dplyr}`, we can find $\\bar{\\mathbf{y}}$ and $\\text{log}(\\bar{\\mathbf{y}})$ for each group in our categorical variable:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-43_c561e0d1447d122f7f6816395f46965e'}\n\n```{.r .cell-code}\ndata.frame(y = y, \n           X = X[, 1]) %>% \n  with_groups(X, \n              summarise, \n              mu = mean(y), \n              log_mu = log(mean(y)))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|X  |       mu|   log_mu|\n|:--|--------:|--------:|\n|A  | 6.666667| 1.897120|\n|B  | 5.500000| 1.704748|\n\n</div>\n:::\n:::\n\n\nWe fit a Poisson GLM using the `glm()` function, again using the natural log as our link function. We see that the intercept is equal to the log of the mean of our response variable for group **A**. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-44_47becd8fb14bf63b566147547493f52f'}\n\n```{.r .cell-code}\ncat_mod_pois <- glm(y ~ X, family = poisson(link = \"log\"))\ncoef(cat_mod_pois)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)          XB \n  1.8971200  -0.1923719 \n```\n:::\n:::\n\n\nNext, if we sum the coefficients, we get the log of the response variable for group **B**:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-45_805b94a9d9b6e1b18019d917ae0857ff'}\n\n```{.r .cell-code}\nsum(coef(cat_mod_pois))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.704748\n```\n:::\n:::\n\n\nIf we exponentiate the coefficients the intercept becomes simply the mean of $\\mathbf{y}$ for group **A**. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-46_cf1f64d372270e2cbc38cad875f9a6ac'}\n\n```{.r .cell-code}\nexp(coef(cat_mod_pois))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)          XB \n   6.666667    0.825000 \n```\n:::\n:::\n\n\nLastly, if we exponentiate the sum of the coefficients (the order of these operations is important), we get the mean of $\\mathbf{y}$ for group **B**:\n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-47_8dc100c89f1d05adce74c9122fe7f5b7'}\n\n```{.r .cell-code}\nexp(sum(coef(cat_mod_pois)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n:::\n\n\n## Models with Continuous Predictors \n\nAs with ordinary linear models, in the presence of a continuous predictor the intercept becomes the expected value of the response variable conditional on the line of best fit that we generate. First we generate another $\\mathbf{y}$ with a larger sample size and a slightly lower value of $\\lambda$. Then we generate Gamma random noise, and define the predictor $\\mathbf{X} = 3.1y + \\epsilon$. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-48_0a5325e6b9534ce6845fc83d48502fca'}\n\n```{.r .cell-code}\ny <- rpois(300, lambda = 3)\ny <- matrix(y, ncol = 1)\nX <- 3.1 * y + rgamma(300, shape = 20, rate = 4)\nX <- matrix(X, ncol = 1)\n```\n:::\n\n\nWe can plot $\\mathbf{X}$ and $\\mathbf{y}$ to get an idea of what their relationship is. Since $\\mathbf{X}$ is a Gamma random variable, it doesn't actually have any zero values; the minimum value we've generated is actually 2.774473. As such, the intercept will be an extrapolation of the data that we do have. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-49_c341fc66f4c5767a63ece755d18a974c'}\n\n```{.r .cell-code}\ndata.frame(y = y, \n           X = X[, 1]) %>% \n  ggplot(aes(x = X, y = y)) + \n  geom_point(alpha = 0.8) + \n  labs(x = \"X\", y = \"Y\") + \n  theme_classic(base_size = 14)\n```\n\n::: {.cell-output-display}\n![](Intercept_Interpretation_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\nWe fit another Poisson GLM and check the coefficients. The intercept in this case is interpreted as the log of the expected value of the response when our predictor variable is equal to zero. However - since $\\mathbf{X}$ is essentially a [Gamma random variable](https://en.wikipedia.org/wiki/Gamma_distribution), it can actually never take a value of zero, as its support is $(0, \\infty)$. As such, the interpretation of $\\beta_0$ is somewhat useless here, and thus it makes sense to center $\\mathbf{X}$ as we did earlier with the ordinary linear model.   \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-50_59f923b8f4296d8234fa9c053fb33088'}\n\n```{.r .cell-code}\ncont_mod_pois <- glm(y ~ X, family = poisson(link = \"log\"))\ncoef(cont_mod_pois)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)           X \n-0.35916189  0.09221817 \n```\n:::\n:::\n\n\nAfter centering and refitting the Poisson GLM, the intercept takes on a new interpretation - the log of $\\mathbf{y}$ when $\\mathbf{X}$ is at its mean. Note that the coefficient for $\\mathbf{X}$ does not change, as centering does not change the units of $\\mathbf{X}$. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-51_ed2a57bc1e7730ce24f227b4d6a3bb9c'}\n\n```{.r .cell-code}\nX_cent <- scale(X, scale = FALSE)\ncont_mod_pois_centered <- glm(y ~ X_cent, family = poisson(link = \"log\"))\ncoef(cont_mod_pois_centered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)      X_cent \n 0.95306190  0.09221817 \n```\n:::\n:::\n\n\nLet's plot both the raw data and the fitted values obtained from our model. The blue horizontal line shows $\\text{exp}(\\beta_0)$ i.e., the expected value of $\\mathbf{y}$ when $\\mathbf{X}$ is at its mean value (again, conditional on the line of best fit that we obtained). The vertical yellow line shows where the mean of $\\mathbf{X}$ is; since we centered $\\mathbf{X}$ this is equal to zero. Lastly, the green line shows the predicted values from our model, and this line intersects nicely with the value of the intercept as we would expect.  \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-52_e45afcb10e23779e6c4842e6dd20841d'}\n\n```{.r .cell-code}\nintercept_exp <- exp(coef(cont_mod_pois_centered)[1])\ndata.frame(y = y, \n           y_pred = fitted(cont_mod_pois_centered), \n           X = X_cent[, 1]) %>% \n  ggplot(aes(x = X, y = y)) + \n  geom_point(alpha = 0.8) + \n  geom_hline(yintercept = intercept_exp, color = \"dodgerblue\", size = 1) + \n  geom_vline(xintercept = 0, color = \"goldenrod\", size = 1) + \n  geom_line(aes(y = y_pred), color = \"forestgreen\", size = 1) + \n  labs(x = \"X (centered)\", y = \"Y\") + \n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](Intercept_Interpretation_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n:::\n\n\n## Models with Categorical & Continuous Predictors \n\nLastly, we'll again examine the most common real-life situation - models with both categorical and continuous predictors. Consider a dataset where the response is a Poisson-distributed random variable, say the number of copies of viral RNA in a sample taken from a patient. First, let's say that our sample size is set to a generous $n = 1000$. Next, imagine that we have two continuous predictors; the first being patient age in years, and the second being the number of months that the patient has been in treatment. We'll simulate age as a Poisson random variable with a mean of 25 years, and months in treatment as a negative binomial random variable with a mean of 3 months and overdispersion parameter (denoted `size` in the `rnbinom()` function) of 4. Lastly, let's define a categorical predictor with 3 possible treatment categories. We store all 3 predictors in a `data.frame`. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-53_579ed179ffb96798180be4e4bac52d92'}\n\n```{.r .cell-code}\nX_age <- rpois(1000, 25)\nX_months <- rnbinom(1000, size = 4, mu = 3)\nX_treat <- sample(c(\"Drug_A\", \"Drug_B\", \"Drug_C\"), \n                  size = 1000, \n                  replace = TRUE)\nmod_df <- data.frame(age = X_age, \n                     months = X_months, \n                     treat = X_treat)\nslice_head(mod_df, n = 5)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| age| months|treat  |\n|---:|------:|:------|\n|  29|      3|Drug_A |\n|  20|      4|Drug_C |\n|  28|      4|Drug_A |\n|  29|      1|Drug_A |\n|  27|      1|Drug_C |\n\n</div>\n:::\n:::\n\n\nFinally, we'll define $\\mathbf{y}$ to be a function of all 3 predictor variables along with a large amount of Poisson-distributed random noise following the distribution $\\epsilon \\sim \\text{Poisson}(50)$. We use the handy `dplyr::case_when()` function to create $\\mathbf{y}$ as a piecewise function whose relationship to the predictor variable changes based on the treatment each patient was given. After generating $\\mathbf{y}$, we round it to ensure that it is integer-valued, since we're focused here on using Poisson GLMs. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-54_79a6b1fc4dc019cf7116c4a62b617313'}\n\n```{.r .cell-code}\nepsilon <- rpois(1000, 50)\nmod_df <- mod_df %>% \n          mutate(y = case_when(treat == \"Drug_A\" ~ 2.25 * age - 1.2 * months, \n                               treat == \"Drug_B\" ~ 2 * age - 3 * months, \n                               treat == \"Drug_C\" ~ 1.75 * age - 5 * months), \n                 y = round(y + epsilon))\nslice_head(mod_df, n = 5)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| age| months|treat  |   y|\n|---:|------:|:------|---:|\n|  29|      3|Drug_A | 111|\n|  20|      4|Drug_C |  61|\n|  28|      4|Drug_A | 117|\n|  29|      1|Drug_A | 115|\n|  27|      1|Drug_C | 111|\n\n</div>\n:::\n:::\n\n\nWe know that for our two continuous predictors, the intercept will indicate the predicted value of $\\mathbf{y}$ for patients with values of zero for those two variables. Since we also have a categorical variable, the intercept will refer to the reference group of that variable - in this case patients who were assigned **Drug_A**. Lastly, since we're using a Poisson GLM, we know that the intercept will be the natural log of that quantity. Our model will be of the following form:\n\n$$\n\\text{log}(\\mathbb{E}[\\text{Viral RNA}]) = \\beta_0 + \\beta_{\\text{age}} + \\beta_{\\text{months}} + \\beta_{\\text{treat}} + \\epsilon\n$$\n\nLet's visualize the data so that we can get some idea of what the relationships between our variables are, and what the intercept of the model we're going to fit will tell us. First let's look at the relationship between **age** and the response, splitting by treatment group. We add a purple vertical line showing where the overall mean of **age** is. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-55_7f00d969c26ffb0d5a478260dbfe7335'}\n\n```{.r .cell-code}\nggplot(mod_df, aes(x = age, y = y, color = treat)) + \n  geom_vline(aes(xintercept = mean(age)), color = \"purple\", size = 1) + \n  geom_point(alpha = 0.8) + \n  labs(x = \"Age\", y = \"Viral RNA\", color = \"Treatment\") + \n  theme_classic(base_size = 14)\n```\n\n::: {.cell-output-display}\n![](Intercept_Interpretation_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n\nWe repeat the visualization for **months**. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-56_2b8cc940bc314a5594f2aa53fb09086e'}\n\n```{.r .cell-code}\nggplot(mod_df, aes(x = months, y = y, color = treat)) + \n  geom_vline(aes(xintercept = mean(months)), color = \"purple\", size = 1) + \n  geom_point(alpha = 0.8) + \n  labs(x = \"Months Treated\", y = \"Viral RNA\", color = \"Treatment\") + \n  theme_classic(base_size = 14)\n```\n\n::: {.cell-output-display}\n![](Intercept_Interpretation_files/figure-html/unnamed-chunk-56-1.png){width=672}\n:::\n:::\n\n\nLastly, let's simply compare the distribution of the response between the three treatment groups using a beeswarm plot, which is a variation on the classic violin plot that I've preferred recently. Check out the [`ggbeeswarm` package docs]() for more. We also add a horizontal line showing $\\bar{\\mathbf{y}}$ for each group. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-57_f423b663a6b024eccfa94a4e333645af'}\n\n```{.r .cell-code}\nggplot(mod_df, aes(x = treat, y = y, color = treat)) + \n  ggbeeswarm::geom_quasirandom() + \n  stat_summary(fun = \"mean\",\n               geom = \"crossbar\", \n               width = 0.5,\n               size = 0.75, \n               color = \"black\") + \n  labs(x = \"Treatment\", y = \"Viral RNA\", color = \"Treatment\") + \n  theme_classic(base_size = 14)\n```\n\n::: {.cell-output-display}\n![](Intercept_Interpretation_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n:::\n\n\nLet's fit a model. As previously noted, we use the log link function. Since our treatment variable has three categories, we now have two coefficients for each of the non-reference group levels. The intercept $\\beta_0$ gives us the log of the expected value of the response for a patient that is 0 years old, has spent 0 months in treatment, and is assigned to be treated with **DrugA**. We can tell right away that this isn't the most useful interpretation, as there are no patients in our study who are zero years old (and even if there were, it probably wouldn't be that useful to know that quantity). \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-58_ef4a12977bdbc39dde3908e036148c8f'}\n\n```{.r .cell-code}\nfull_mod_pois <- glm(y ~ age + months + treat, \n                     data = mod_df, \n                     family = poisson(link = \"log\"))\ncoef(full_mod_pois)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)         age      months treatDrug_B treatDrug_C \n 4.18283220  0.02190533 -0.03623370 -0.12200269 -0.25328199 \n```\n:::\n:::\n\n\nSince we're using the log-link, exponentiating the intercept gives us the expected value of $\\mathbf{y}$ under the conditions we described just above. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-59_48bc903f1b844751a64eb127924f9b68'}\n\n```{.r .cell-code}\nexp(coef(full_mod_pois))[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   65.55124 \n```\n:::\n:::\n\n\nClearly, the **age** variable is a prime target for centering. While it could be useful to center **months** (depending on the goals of the study), there are a total of 111 patients in the study who have spent zero months in treatment, so it's at least somewhat anchored in reality. We center **age**, then refit the model. We see that the estimate of $\\beta_0$ changes, while none of the coefficients for our predictors do (as expected). \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-60_93b6a7002d23c154617f14cff7b090cb'}\n\n```{.r .cell-code}\nmod_df <- mutate(mod_df, \n                 age_cent = scale(age, scale = FALSE))\nfull_mod_pois_centered <- glm(y ~ age_cent + months + treat, \n                              data = mod_df, \n                              family = poisson(link = \"log\"))\ncoef(full_mod_pois_centered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)    age_cent      months treatDrug_B treatDrug_C \n 4.73046554  0.02190533 -0.03623370 -0.12200269 -0.25328199 \n```\n:::\n:::\n\n\nExponentiating $\\beta_0$ now gives us the expected value of $\\mathbf{y}$ for a patient of average age (which is 25 years) who was assigned treatment **Drug)A** and has spent zero months being treated. This quantity is useful because it tells us the baseline pre-treatment value for the average patient who takes **Drug_A**. \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-61_3b914c1b32bb92d552794027e146cb6c'}\n\n```{.r .cell-code}\nexp(coef(full_mod_pois_centered))[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   113.3483 \n```\n:::\n:::\n\n\n# Conclusions \n\nWhile regression intercepts can seem tricky at first and don't always carry a useful interpretation by default, I think they're more useful than introductory & intermediate statistics courses give them credit for. I understand those course's emphasis on interpreting estimates for covariates of interest of course, as those are what generally determine the success or failure of our scientific hypotheses, but the intercept can often help establish a useful baseline value against which you can compare your other estimates. \n\nThere's a couple important takeaways I'd like to re-emphasize. First - always make sure you know the reference group of your categorical variables, and set it to something more useful if you need to! The alphabetical order used by R is often not quite what you want. Second - keep centering (or even pseudo-centering around another useful value) in mind & use it often. There's many situations outside of just patient age where a value of 0 makes little sense in the context of your study. Lastly, when using GLMs, make sure you know your link function, its inverse, and how to interpret your coefficients on each scale. \n\nFinally, I've included some references below that have been helpful to me, and which I would recommend as further reading if you're interested in the technical details of regression & other methods. \n\n# References \n\n1. Faraway, J. [Extending the Linear Model with R, 2nd Edition](https://doi.org/10.1201/9781315382722). *Chapman and Hall*. 2016. \n\n2. Hastie, T. *et al*. [The Elements of Statistical Learning, 2nd Edition](https://doi.org/10.1007/b94608). *Springer*. 2009.\n\n3. Wakefield, J. [Bayesian and Frequentist Regression Methods](https://doi.org/10.1007/978-1-4419-0925-1). *Springer*. 2016. \n\n# Session Info \n\n\n::: {.cell hash='Intercept_Interpretation_cache/html/unnamed-chunk-62_8201d2609819e4127361261de9ebad26'}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.1 (2022-06-23)\n os       macOS Big Sur ... 10.16\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2023-01-10\n pandoc   2.19.2 @ /usr/local/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n assertthat    0.2.1   2019-03-21 [1] CRAN (R 4.2.0)\n beeswarm      0.4.0   2021-06-01 [1] CRAN (R 4.2.0)\n cli           3.3.0   2022-04-25 [1] CRAN (R 4.2.0)\n codetools     0.2-18  2020-11-04 [1] CRAN (R 4.2.1)\n colorspace    2.0-3   2022-02-21 [1] CRAN (R 4.2.0)\n crayon        1.5.1   2022-03-26 [1] CRAN (R 4.2.0)\n DBI           1.1.3   2022-06-18 [1] CRAN (R 4.2.0)\n digest        0.6.29  2021-12-01 [1] CRAN (R 4.2.0)\n dplyr       * 1.0.9   2022-04-28 [1] CRAN (R 4.2.0)\n ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.2.0)\n evaluate      0.16    2022-08-09 [1] CRAN (R 4.2.0)\n fansi         1.0.3   2022-03-24 [1] CRAN (R 4.2.0)\n farver        2.1.1   2022-07-06 [1] CRAN (R 4.2.0)\n fastmap       1.1.0   2021-01-25 [1] CRAN (R 4.2.0)\n generics      0.1.3   2022-07-05 [1] CRAN (R 4.2.0)\n ggbeeswarm    0.6.0   2017-08-07 [1] CRAN (R 4.2.0)\n ggplot2     * 3.3.6   2022-05-03 [1] CRAN (R 4.2.0)\n glue          1.6.2   2022-02-24 [1] CRAN (R 4.2.0)\n gtable        0.3.0   2019-03-25 [1] CRAN (R 4.2.0)\n highr         0.9     2021-04-16 [1] CRAN (R 4.2.0)\n htmltools     0.5.3   2022-07-18 [1] CRAN (R 4.2.0)\n htmlwidgets   1.5.4   2021-09-08 [1] CRAN (R 4.2.0)\n jsonlite      1.8.0   2022-02-22 [1] CRAN (R 4.2.0)\n knitr         1.40    2022-08-24 [1] CRAN (R 4.2.0)\n labeling      0.4.2   2020-10-20 [1] CRAN (R 4.2.0)\n lifecycle     1.0.1   2021-09-24 [1] CRAN (R 4.2.0)\n magrittr    * 2.0.3   2022-03-30 [1] CRAN (R 4.2.0)\n munsell       0.5.0   2018-06-12 [1] CRAN (R 4.2.0)\n pillar        1.8.1   2022-08-19 [1] CRAN (R 4.2.0)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.2.0)\n purrr         0.3.4   2020-04-17 [1] CRAN (R 4.2.0)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.2.0)\n rlang         1.0.4   2022-07-12 [1] CRAN (R 4.2.0)\n rmarkdown     2.16    2022-08-24 [1] CRAN (R 4.2.0)\n scales        1.2.1   2022-08-20 [1] CRAN (R 4.2.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.2.0)\n stringi       1.7.8   2022-07-11 [1] CRAN (R 4.2.0)\n stringr       1.4.1   2022-08-20 [1] CRAN (R 4.2.0)\n tibble        3.1.8   2022-07-22 [1] CRAN (R 4.2.0)\n tidyselect    1.1.2   2022-02-21 [1] CRAN (R 4.2.0)\n utf8          1.2.2   2021-07-24 [1] CRAN (R 4.2.0)\n vctrs         0.4.1   2022-04-13 [1] CRAN (R 4.2.0)\n vipor         0.4.5   2017-03-22 [1] CRAN (R 4.2.0)\n withr         2.5.0   2022-03-03 [1] CRAN (R 4.2.0)\n xfun          0.32    2022-08-10 [1] CRAN (R 4.2.0)\n yaml          2.3.5   2022-02-21 [1] CRAN (R 4.2.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.2/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}